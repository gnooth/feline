// Copyright (C) 2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: feline

public

: file-name-as-directory // string -> string'
    dup string-?last path-separator-char? [
        path-separator-char string-append-char
    ] unless ;

// returns filename without its directory component
: file-name-nondirectory ( filename )
    filename length :> len
    len 1- filename [ path-separator-char? ] find-last-from // -> index/f element/f
    [ 1+ filename tail ] [ filename nip ] if ;

// returns the filename's directory component
: file-name-directory-win64 ( filename ) // filename -> dirname/f
    filename length :> len

    {
        [ len 3 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
        [ 2 filename nth-unsafe path-separator-char? ]
    } &&
    [ f ] return-if

    {
        [ len 2 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
    } &&
    [ f ] return-if

    f :> dirname!
    len 1- filename [ path-separator-char? ] find-last-from // -> index/f element/f
    [
        filename head dirname!
        {
            [ dirname length 2 eq? ]
            [ 1 dirname nth-unsafe ':' eq? ]
        } &&
        [
            dirname path-separator-char string-append-char dirname!
        ] when
    ] when
    dirname ;

: file-name-directory-linux ( filename ) // filename -> dirname/f
    filename length :> len
    len 1- filename [ path-separator-char? ] find-last-from [
        // -> index
        dup zero? [ drop "/" ] [ filename head ] if
    ] when ;


// returns the filename's directory component
: file-name-directory                   // filename -> dirname/f
    win64? [ file-name-directory-win64 ] [ file-name-directory-linux ] if ;

win64? #if

: verify-extension // extension filename  -> filename/f
    tuck
    path-extension string-equal? [ drop f ] unless ;

: directory-files // string -> sequence/f
    1 ?enough !> arg

    arg empty? [ f ] return-if

    // canonical-path calls tilde-expand-filename
    arg canonical-path arg!

    // canonical-path might return f
    arg null? [ f ] return-if

    arg directory? [
        arg "*" path-append arg!
    ] [
        arg last path-separator-char? [ arg "*" + arg! ] when
    ] if

    arg path-extension :> extension

    arg find-first-file :> p

    p zero? [ f ] return-if

    64 <vector> :> v

    f !> filename
    extension [
        p find-file-filename alien->string filename!
        extension filename verify-extension [
            filename v push
        ] when

        [ p find-next-file ] [
            p find-file-filename alien->string filename!
            extension filename verify-extension [
                filename v push
            ] when
        ] while
    ] [
        p find-file-filename alien->string filename!
        filename v push

        [ p find-next-file ] [
            p find-file-filename alien->string filename!
            filename v push
        ] while
    ] if

    p find-close assert-true

    v ;

#endif
