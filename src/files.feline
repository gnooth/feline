// Copyright (C) 2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: feline

public

// returns filename without its directory component
: file-name-nondirectory ( filename )
    filename length :> len
    len 1- filename [ path-separator-char? ] find-last-from // -> index/f element/f
    [ 1+ filename tail ] [ filename nip ] if ;

// returns the filename's directory component
: file-name-directory-win64 ( filename ) // filename -> dirname/f
    filename length :> len

    {
        [ len 3 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
        [ 2 filename nth-unsafe path-separator-char? ]
    } &&
    [ f ] return-if

    {
        [ len 2 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
    } &&
    [ f ] return-if

    f :> dirname!
    len 1- filename [ path-separator-char? ] find-last-from // -> index/f element/f
    [
        filename head dirname!
        {
            [ dirname length 2 eq? ]
            [ 1 dirname nth-unsafe ':' eq? ]
        } &&
        [
            dirname path-separator-char string-append-char dirname!
        ] when
    ] when
    dirname ;

// returns the filename's directory component
: file-name-directory ( filename )      // filename -> dirname/f
    filename length :> len

    {
        [ win64? ]
        [ filename length 3 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
        [ 2 filename nth-unsafe path-separator-char? ]
    } &&
    [ f ] return-if

    {
        [ win64? ]
        [ filename length 2 eq? ]
        [ 1 filename nth-unsafe ':' eq? ]
    } &&
    [ f ] return-if

    f :> dirname!
    len 1- filename [ path-separator-char? ] find-last-from // -> index/f element/f
    [
        filename head dirname!
        win64? [
            {
                [ dirname length 2 eq? ]
                [ 1 dirname nth-unsafe ':' eq? ]
            } &&
            [
                dirname path-separator-char string-append-char dirname!
            ] when
        ] when
    ] when
    dirname ;
