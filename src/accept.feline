// Copyright (C) 2016 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: accept

global: prompt-string
global: buffer
global: bindings
global: dot
global: history
global: history-index
global: pattern

: reset-history ( -- )
    f history-index! f pattern! ;

: prompt ( -- )
    "in: " current-vocab vocab-name concat
    "> " concat
    dup prompt-string!
    green foreground write ;

: redisplay ( -- )
    0 at-x
    prompt
    yellow foreground
    buffer sbuf>string write
    clear-to-eol
    dot prompt-string length + at-x ;

: do-escape ( -- )
    0 buffer sbuf-shorten
    0 dot!
    reset-history
    redisplay ;

: do-kill-line ( -- )
    dot buffer length < [
        dot buffer sbuf-shorten
        reset-history
        redisplay
    ] when ;

: do-delete-char ( -- )
    dot buffer length < [
        dot buffer sbuf-remove-nth! drop
        reset-history
        redisplay
    ] when ;

: do-bs ( -- )
    dot 0 > [
        dot 1 - dot!
        dot buffer sbuf-remove-nth! drop
        reset-history
        redisplay
    ] when ;

: do-home ( -- )
    prompt-string length at-x
    0 dot!
    reset-history ;

: do-end ( -- )
    buffer length dot!
    prompt-string length dot + at-x
    reset-history ;

: do-right ( -- )
    dot buffer length <
    [ dot 1 + dot! dot prompt-string length + at-x ]
    when
    reset-history ;

: do-left ( -- )
    dot 0 > [ dot 1 - dot! dot prompt-string length + at-x ] when
    reset-history ;

: do-normal-char ( c -- )
    dot buffer length < [
        dot buffer sbuf-insert-nth! drop dot 1 + dot! redisplay
    ] [
        dup write-char dot 1 + dot! buffer push
    ] if
    reset-history ;

: do-previous ( -- )
    history-index [ history length history-index! ] unless
    history-index zero? [
        history-index 1 - history-index!
        0 buffer sbuf-shorten
        buffer history-index history nth sbuf-append-string ( -- buffer )
        length dot!
        redisplay
    ] unless ;

: do-next ( -- )
    history-index [
        history length 1 - < [
            history-index 1 + history-index!
            0 buffer sbuf-shorten
            buffer history-index history nth sbuf-append-string ( -- buffer )
            length dot!
            redisplay
        ] when
    ] when*
;

: match? ( string -- ? )
    pattern 2dup longer? [ mismatch not ] [ 2drop f ] if ;

: do-previous-matching-input ( -- )
    pattern [ buffer sbuf>string pattern! history length history-index! ] unless
    history-index 1 -
    history
    [ match? ]
    find-last-from ( -- index/f elt/f )
    [
        swap history-index!
        0 buffer sbuf-shorten
        buffer swap sbuf-append-string ( -- buffer )
        length dot!
        redisplay
    ] [ drop ] if* ;

: do-next-matching-input ( -- )
    pattern [
        history-index 1 +
        history
        [ match? ]
        find-from ( -- index/f elt/f )
        [
            swap history-index!
            0 buffer sbuf-shorten
            buffer swap sbuf-append-string ( -- buffer )
            length dot!
            redisplay
        ] [ drop ] if*
    ] [ do-next ] if ;

: history-file-pathname ( -- string )
    user-home ".feline-history" path-append ;

: initialize-history ( -- )
    history-file-pathname dup regular-file?
    [ file-lines ] [ drop 100 <vector> ] if history! ;

: save-history ( -- )
    history
    [ length dup 100 - 0 max swap ] keep
    <slice>
    history-file-pathname set-file-lines ;

: bind-key ( key action -- )
    2array bindings push ;

: lookup-key ( key -- symbol/f )
    bindings length [ bindings nth array-first over = ] find-integer // -- n/f
    nip dup [ bindings nth array-second ] [ drop f ] if ;

: initialize-bindings ( -- )
    10 <vector> bindings!
    3                   \ bye                        bind-key
    $1b                 \ do-escape                  bind-key
    127                 \ do-bs                      bind-key        // Linux
    8                   \ do-bs                      bind-key        // Windows
    k-left              \ do-left                    bind-key
    k-right             \ do-right                   bind-key
    k-home              \ do-home                    bind-key
    k-end               \ do-end                     bind-key
    k-up                \ do-previous                bind-key
    k-down              \ do-next                    bind-key
    k-delete            \ do-delete-char             bind-key
    $0b ( control k )   \ do-kill-line               bind-key
    $10 ( control p )   \ do-previous-matching-input bind-key
    $0e ( control n )   \ do-next-matching-input     bind-key ;

: accept-key ( -- tagged-char) ekey ;

: process-key ( tagged-char -- )
    dup printable?
    [ do-normal-char ]
    [ lookup-key [ call-symbol ] when* ]
    if ;

: terminator? ( tagged-char -- ? )
    { 10 13 } member? ;

: accept-string ( -- string )
    256 <sbuf> buffer!
    bindings [ initialize-bindings ] unless
    history [ initialize-history ] unless
    prompt
    0 dot!
    yellow foreground
    [ accept-key dup terminator? ] [ process-key ] until
    drop
    white foreground

    buffer sbuf>string

    [ dup empty? [ drop ] [ history push save-history ] if ] keep

    f buffer!
    reset-history
    nl ;
