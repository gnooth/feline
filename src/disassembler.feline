// Copyright (C) 2016-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: disassembler

empty

// "0 = default operand size   1 = 64-bit operand size"
8 constant rex.w

// "1-bit (high) extension of the ModRM reg field, thus permitting access to 16 registers."
4 constant rex.r

// "1-bit (high) extension of the SIB index field, thus permitting access to 16 registers."
2 constant rex.x

// "1-bit (high) extension of the ModRM r/m field, SIB base field, or opcode reg field,
// thus permitting access to 16 registers."
1 constant rex.b

global start-address
global stop-address
global #insts
global instruction-start
global ip
global prefix
global operand-size-prefix
global opcode
global byte2                            // second byte of two-byte opcode
global modrm-byte
global sib-byte

global mnemonic

global immediate-operand?
global immediate-operand
global signed?

global register-direct?
global memory-operand?
global sreg                             // source register
global ssize                            // source operand size
global sbase                            // source base register
global sindex                           // source index register
global sscale                           // source scaling factor
global sdisp                            // source displacement
global dreg                             // destination register
global dsize                            // destination operand size
global dbase                            // destination base register
global dindex                           // destination index register
global dscale                           // destination scaling factor
global ddisp                            // destination displacement

global #operands

: reset-disassembler
    0 prefix!
    0 byte2!
    0 operand-size-prefix!

    ip instruction-start!
    0 mnemonic!

    nil immediate-operand?!
    nil signed?!
    nil register-direct?!
    nil memory-operand?!

    nil sreg!
    nil dreg!
    64 ssize!
    64 dsize!
    nil sbase!
    nil dbase!
    nil sindex!
    nil dindex!
    0 sscale!
    0 dscale!
    0 sdisp!
    0 ddisp!

    2 #operands! ;

: reg64-name                            // register-number -> string
    { "rax" "rcx" "rdx" "rbx" "rsp" "rbp" "rsi" "rdi"
      "r8"  "r9"  "r10" "r11" "r12" "r13" "r14" "r15" } array-nth ;

: reg32-name                            // register-number -> string
    { "eax"  "ecx"  "edx"  "ebx"  "esp"  "ebp"  "esi"  "edi"
      "r8d"  "r9d"  "r10d" "r11d" "r12d" "r13d" "r14d" "r15d" } array-nth ;

: reg8-name                             // register-number -> string
    { "al"  "cl"  "dl"   "bl"   "spl"  "bpl"  "sil"  "dil"
      "r8b" "r9b" "r10b" "r11b" "r12b" "r13b" "r14b" "r15b" } array-nth ;

: .register-name                        // register-number size -> void
    :> size
    :> n
    {
        { [ size 64 = ] [ n reg64-name write-string ] }
        { [ size 32 = ] [ n reg32-name write-string ] }
        { [ size  8 = ] [ n  reg8-name write-string ] }
    } cond ;

: .reg64                                // register-number -> void
    reg64-name write-string ;

: .size                                 // n -> void
    {
        {  8 [ "byte"  ] }
        { 16 [ "word"  ] }
        { 32 [ "dword" ] }
        { 64 [ "qword" ] }
    } case
    write-string space ;

: .relative                             // base index scale disp size -> void
    :> size
    !> disp
    :> scale
    :> index
    :> base

    mnemonic "lea" = [ size .size ] unless

    "[" write-string
    base .reg64
    index [
        "+" write-string
        scale zero? [ 1 scale lshift dec. "*" write-string ] unless
        index .reg64
    ] when
    disp 0 = [
        disp 0 > [ "+" write-string ] [ "-" write-string disp negate disp! ] if
        disp dec.
    ] unless
    "]" write-string ;

: .memory-operand                       // disp size -> void
    .size "[" write-string hex. "]" write-string ;

: .ip ?nl ip hex. space ;

: ++ip ip 1+ ip! ;

: mnemonic-col 42 tab ;

: dest-col 50 tab ;

: comment-col 64 tab ;

: .mnemonic mnemonic [ mnemonic-col write-string ] when* ;

: .hexbyte                              // unsigned-byte -> void
    >hex dup length 2 < [ '0' write-char ] when write-string ;

: .bytes                                // u -> void
    [ instruction-start + c@ .hexbyte space ] each-integer ;

: .instruction-bytes ip instruction-start - .bytes ;

: .sep ", " write-string ;

: .immediate-operand
    immediate-operand {
        { [ signed? ]     [ dec. ] }
        { [ dup uint64? ] [ hex. ] }
        { [ dup 10 < ]    [ dec. ] }
        [ hex. ]
    } cond ;

: .dest
    dest-col
    {
        { [ dreg ] [ dreg dsize .register-name ] }
        { [ dbase ] [ dbase dindex dscale ddisp dsize .relative ]  }
        { [ memory-operand? ] [ ddisp dsize .memory-operand nil memory-operand?! ] }
        { [ immediate-operand? ] [ .immediate-operand ] }
        [ ".dest" error ]
    } cond ;

: .source
    {
        { [ immediate-operand? ] [ .sep .immediate-operand ] }
        { [ sbase ] [ .sep sbase sindex sscale sdisp ssize .relative ] }
        { [ memory-operand? ] [ .sep sdisp ssize .memory-operand ] }
        { [ sreg ] [ .sep sreg ssize .register-name ] }
        [ ".source" error ]
    } cond ;

: .inst
    .instruction-bytes
    .mnemonic
    #operands 0 > [ .dest ] when
    #operands 1 > [ .source ] when ;

global handlers 256 make-array/1 handlers!

: install-handler                       // handler opcode -> void
    handlers array-set-nth ;

: handler                               // opcode -> handler
    handlers array-nth ;

: execute-handler                       // handler -> void
    [ call-symbol ] [ "no handler" error ] if* ;

: next-byte                             // void -> byte
    ip c@ ++ip ;

: next-signed-byte                      // void -> signed-byte
    ip c@s ++ip ;

: next-int32                            // void -> int32
    ip l@s ip 4 + ip! ;

: next-uint32                           // void -> uint32
    ip l@ ip 4 + ip! ;

: next-uint64                           // void -> uint64
    ip @ ip 8 + ip! ;

: next-uint16                           // void -> int16
    ip w@ ip 2 + ip! ;

: %modrm-mod                            // modrm-byte -> mod
    0b11000000 bitand 6 rshift ;
: %modrm-reg                            // modrm-byte -> reg
    0b00111000 bitand 3 rshift ;
: %modrm-rm                             // modrm-byte -> rm
    0b00000111 bitand ;

global modrm-mod
global modrm-reg
global modrm-rm

// regop is a synonym of modrm-reg
global regop    // REGister or OPcode extension (depending on the instruction)

: !modrm-byte
    next-byte dup modrm-byte!
    dup %modrm-mod modrm-mod!
    dup %modrm-reg modrm-reg!
    %modrm-rm modrm-rm!
    modrm-reg regop! ;

: register-reg                          // n1 -> n2
    prefix 4 rshift 4 = [
        prefix rex.r bitand zero? not [
            8 bitor
        ] when
    ] when ;

: register-rm                           // n1 -> n2
    prefix 4 rshift 4 = [
        prefix rex.b bitand zero? not [
            8 bitor
        ] when
    ] when ;

: .2                                    // ub -> void
    fixnum>binary dup length 2 < [ '0' write-char ] when write-string ;
: .3                                    // ub -> void
    fixnum>binary dup length 3 swap - [ '0' write-char ] times write-string ;

: .modrm                                // modrm-byte -> void
   ?nl " mod: " write-string dup %modrm-mod .2
   nl  " reg: " write-string dup %modrm-reg .3
   nl  "  rm: " write-string     %modrm-rm  .3 ;

: !sib-byte next-byte sib-byte! ;

: %sib-scale                            // sib -> scale
    0b11000000 bitand 6 rshift ;
: %sib-index                            // sib -> index
    0b00111000 bitand 3 rshift ;
: %sib-base                             // sib -> base
    0b00000111 bitand ;

: sib-scale                             // void -> scale
    sib-byte %sib-scale ;
: sib-index                             // void -> index
    sib-byte %sib-index ;
: sib-base                              // void -> base
    sib-byte %sib-base ;

: .sib                                  // sib -> void
   ?nl " scale: " write-string dup %sib-scale .2
   nl  " index: " write-string dup %sib-index .3
   nl  "  base: " write-string     %sib-base  .3 ;

: register-index                        // n1 -> n2
    prefix 4 rshift 4 = [
        prefix rex.x bitand zero? not [
            8 bitor
        ] when
    ] when ;

: unsupported
    ?nl "unsupported instruction at " write-string instruction-start hex.
    instruction-start 16 dump
    "unsupported instruction" error ;

: instruction-operand-size              // void -> n
    operand-size-prefix 0x66 eq? [ 16 ] [ prefix 0x48 bitand 0x48 = 64 32 ? ] if ;

: set-instruction-size instruction-operand-size dup dsize! ssize! ;

: /r-r/m-reg
    // /r
    // source is r32/64
    // dest is r/m32/64
    set-instruction-size
    !modrm-byte
    modrm-reg register-reg sreg!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-base {
                        { 5 [
                            next-int32 ddisp!
                            t memory-operand?!
                        ] }
                        [
                            // default case
                            drop
                            sib-base register-rm dbase!
                            sib-index register-index dindex!
                            sib-scale dscale!
                        ]
                    } case
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                ]
            } case
        ] }
        { 1 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-base register-rm dbase!
                    sib-index 4 eq? [
                        sib-index register-index dindex!
                    ] unless
                    sib-scale dscale!
                    next-signed-byte ddisp!
                ] }
                [
                    // default case
                    drop
                    next-signed-byte ddisp!
                    modrm-rm register-rm dbase!
                ]
            } case
        ] }
        { 3 [ modrm-rm register-rm dreg! ] }
    } case
    .inst ;

: al,imm8                               // mnemonic -> void
    mnemonic!
    next-byte immediate-operand!
    .instruction-bytes
    .mnemonic
    dest-col "al, " write-string .immediate-operand ;

: find-word-from-exact-code-address     // tagged-code-address -> word/f
    :> x
    all-words [
        symbol-code-address x =
    ] find nip ;

: jcc-rel32                             // mnemonic -> void
    mnemonic!
    next-int32 ip + :> jump-target

    .instruction-bytes
    .mnemonic
    dest-col jump-target hex.

    jump-target find-word-from-exact-code-address [
        comment-col symbol-name write
    ] when* ;

: regop-mnemonic                        // void -> string
    {
        {
            [ opcode 0x80 0x83 between? ]
            [ regop { "add" "or" "adc" "sbb" "and" "sub" "xor" "cmp" } nth ]
        }
        {
            [ opcode 0xc0 0xc1 between? opcode 0xd0 0xd3 between? or ]
            [ regop { "rol" "ror" "rcl" "rcr" "shl" "shr" "shl" "sar" } nth ]
        }
        {
            [ opcode 0xf6 0xf7 between? ]
            [ regop { "test" "test" "not" "neg" "mul" "imul" "div" "idiv" } nth ]
        }
    } cond ;

: /r-reg-r/m
    // /r
    // source is r/m32/64
    // dest is r32/64
    set-instruction-size
    !modrm-byte
    modrm-reg register-reg dreg!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    {
                        { [ sib-base 4 = sib-byte 0x24 = and ] [ sib-base sbase! ] }
                        { [ sib-base 5 = ] [ next-int32 sdisp! t memory-operand?! ] }
                        [
                            sib-base register-rm sbase!
                            sib-index register-index sindex!
                            sib-scale sscale!
                        ]
                    } cond
                ] }
                { 5 [
                    // RIP-relative addressing, 32-bit offset
                    next-int32 ip + sdisp! t memory-operand?!
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm sbase!
                ]
            } case
        ] }
        { 1 [
            modrm-rm 4 = [
                !sib-byte
                next-signed-byte sdisp!
                sib-byte 0x24 = [
                    sib-base  sbase!
                ] [
                    sib-base register-rm sbase!
                    sib-index register-index sindex!
                    sib-scale sscale!
                ] if
            ] [
                modrm-rm register-rm sbase!
                next-signed-byte sdisp!
            ] if
        ] }
    } case
    .inst ;

: .push
    "push" mnemonic!
    opcode 0x50 - register-rm dreg!
    1 #operands!
    .inst ;

8 [ 0x50 + ' .push swap install-handler ] each-integer

: .pop
    "pop" mnemonic!
    opcode 0x58 - register-rm dreg!
    1 #operands!
    .inst ;

8 [ 0x58 + ' .pop swap install-handler ] each-integer

: .01
    // /r
    // source is r32/64
    // dest is r/m32/64
    "add" mnemonic!
    /r-r/m-reg ;

last-word 0x01 install-handler

: .03
    // /r
    // source is r/m32/64
    // dest is r32/64
    "add" mnemonic!
    /r-reg-r/m ;

last-word 0x03 install-handler

: .08
    // /r
    // source is r8
    // dest is r/m8
    "or" mnemonic!
    8 dup ssize! dsize!
    !modrm-byte
    modrm-mod {
        { 3 [
            modrm-reg register-reg sreg!
            modrm-rm register-rm dreg!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x08 install-handler

: .09
    // /r
    // ModR/M byte contains both a register and an r/m operand
    // source is r32/64
    // dest is r/m32/64
    "or" mnemonic!
    /r-r/m-reg ;

last-word 0x09 install-handler

: .0b
    // /r
    // ModR/M byte contains both a register and an r/m operand
    // source is r/m32/64
    // dest is r32/64
    "or" mnemonic!
    /r-reg-r/m ;

last-word 0x0b install-handler

: .19 "sbb" mnemonic! /r-r/m-reg ;

last-word 0x19 install-handler

: .21
    // /r
    // source is r32/64
    // dest is r/m32/64
    "and" mnemonic!
    /r-r/m-reg ;

last-word 0x21 install-handler

: .23
    // /r
    // source is r/m32/64
    // dest is r32/64
    "and" mnemonic!
    /r-reg-r/m ;

last-word 0x23 install-handler

: .24 "and" al,imm8 ;

last-word 0x24 install-handler

: .29 "sub" mnemonic! /r-r/m-reg ;

last-word 0x29 install-handler

: .2b
    // /r
    // dest is r32/64
    // source is r/m32/64
    "sub" mnemonic!
    /r-reg-r/m ;

last-word 0x2b install-handler

: .30
    // /r
    // dest is r/m8
    // source is r8
    "xor" mnemonic!
    8 dup ssize! dsize!
    !modrm-byte
    modrm-mod {
        { 3 [
            modrm-reg register-reg sreg!
            modrm-rm register-rm dreg!
        ] }
        [ unsupported ]
    } case
    .inst
;

last-word 0x30 install-handler

: .31
    set-instruction-size
   "xor" mnemonic!
   /r-r/m-reg ;

last-word 0x31 install-handler

: .33
    set-instruction-size
   "xor" mnemonic!
   /r-reg-r/m ;

last-word 0x33 install-handler

: .38
    // /r
    // dest is r/m8
    // source is r8
    "cmp" mnemonic!
    8 dup ssize! dsize!
    !modrm-byte
    modrm-mod {
        { 3 [
            modrm-reg register-reg sreg!
            modrm-rm register-rm dreg!
        ] }
        [ unsupported ]
    } case
    .inst
;

last-word 0x38 install-handler

: .39
    // /r
    // dest is r/m32/64
    // source is r32/64
    set-instruction-size
    "cmp" mnemonic!
    /r-r/m-reg ;

last-word 0x39 install-handler

: .3a
    // dest is r8
    // source is r/m8
    "cmp" mnemonic!
    8 dup ssize! dsize!
    !modrm-byte
    modrm-mod {
        { 1 [
            modrm-rm 4 = [
                !sib-byte
                next-signed-byte sdisp!
                sib-byte 0x24 = [
                    sib-base sbase!
                ] [
                    sib-base register-rm sbase!
                    sib-index register-index sindex!
                    sib-scale sscale!
                ] if
            ] [
                modrm-rm register-rm sbase!
                next-signed-byte sdisp!
            ] if
            modrm-reg register-reg dreg!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x3a install-handler

: .3b
    "cmp" mnemonic!
    // /r
    // source is r/m32/64
    // dest is r32/64
    /r-reg-r/m ;

last-word 0x3b install-handler

: .3c "cmp" al,imm8 ;

last-word 0x3c install-handler

: .63
    // /r
    // source is r/m32
    // dest is r32/64
    "movsx" mnemonic!
    !modrm-byte
    modrm-reg register-reg dreg!
    modrm-rm  register-rm  sbase!
    .inst ;

last-word 0x63 install-handler

: .6a
    "push" mnemonic!
    next-signed-byte immediate-operand!
    t immediate-operand?!
    1 #operands!
    .inst ;

last-word 0x6a install-handler

: .6b
    "imul" mnemonic!
    !modrm-byte
    modrm-mod 3 eq? modrm-reg modrm-rm eq? and [
        next-signed-byte immediate-operand!
        t immediate-operand?!
        modrm-rm dreg!
        2 #operands!
        .inst
    ] [ unsupported ] if ;

last-word 0x6b install-handler

: jmp/jcc-rel8                          // mnemonic -> void
    mnemonic!
    next-signed-byte ip + :> jump-target
    .instruction-bytes
    .mnemonic
    dest-col jump-target hex.

    jump-target find-word-from-exact-code-address [
        comment-col symbol-name write
    ] when* ;

: .70 "jo"  jmp/jcc-rel8 ; last-word 0x70 install-handler
: .71 "jno" jmp/jcc-rel8 ; last-word 0x71 install-handler
: .72 "jc"  jmp/jcc-rel8 ; last-word 0x72 install-handler
: .73 "jnc" jmp/jcc-rel8 ; last-word 0x73 install-handler
: .74 "jz"  jmp/jcc-rel8 ; last-word 0x74 install-handler
: .75 "jne" jmp/jcc-rel8 ; last-word 0x75 install-handler
: .76 "jna" jmp/jcc-rel8 ; last-word 0x76 install-handler
: .77 "ja"  jmp/jcc-rel8 ; last-word 0x77 install-handler
: .78 "js"  jmp/jcc-rel8 ; last-word 0x78 install-handler
: .79 "jns" jmp/jcc-rel8 ; last-word 0x79 install-handler
: .7a "jpe" jmp/jcc-rel8 ; last-word 0x7a install-handler
: .7b "jpo" jmp/jcc-rel8 ; last-word 0x7b install-handler
: .7c "jl"  jmp/jcc-rel8 ; last-word 0x7c install-handler
: .7d "jge" jmp/jcc-rel8 ; last-word 0x7d install-handler
: .7e "jle" jmp/jcc-rel8 ; last-word 0x7e install-handler
: .7f "jg"  jmp/jcc-rel8 ; last-word 0x7f install-handler

: .80
    // modrm-reg encodes opcode extension
    // source is imm8
    // dest is r/m8
    8 dsize!
    t immediate-operand?!
    !modrm-byte
    regop-mnemonic mnemonic!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-index 4 =
                    sib-base 5 = and [
                        next-int32 ddisp!
                        t memory-operand?!
                        next-byte immediate-operand!
                    ] [ unsupported ] if
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    next-byte immediate-operand!
                ]
            } case
        ] }
        { 1  [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-index 4 = not
                    sib-base 5 = not and [
                        sib-scale zero? [
                            sib-base dbase!
                            sib-index dindex!
                            next-signed-byte ddisp!
                            next-byte immediate-operand!
                        ] [ unsupported ] if
                    ] [ unsupported ] if
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    next-signed-byte ddisp!
                    next-byte immediate-operand!
                ]
            } case
        ] }
        { 3  [
            // register-direct
            modrm-rm dreg!
            next-byte immediate-operand!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x80 install-handler

: .81
    // modrm-reg encodes opcode extension
    // source is imm32
    // dest is r/m32/64
    set-instruction-size
    !modrm-byte
    regop-mnemonic mnemonic!
    modrm-mod {
        { 1 [
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
            next-int32 immediate-operand!
            t immediate-operand?!
        ] }
        { 3 [
            // register-direct addressing mode
            modrm-rm register-rm dreg!
            next-int32 immediate-operand!
            t immediate-operand?!
            t signed?!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x81 install-handler

: .83
    // modrm-reg encodes opcode extension
    // source is imm8
    // dest is r/m16/32/64
    set-instruction-size
    !modrm-byte
    regop-mnemonic mnemonic!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-base {
                        { 4 [
                            sib-index 4 eq? sib-scale zero? and [
                                sib-base dbase!
                            ] [
                                unsupported
                            ] if
                        ] }
                        { 5 [
                            next-int32 ddisp!
                            t memory-operand?!
                        ] }
                        [ unsupported ]
                    } case
                    // source is imm8
                    t immediate-operand?!
                    next-byte immediate-operand!
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    // source is imm8
                    t immediate-operand?!
                    next-byte immediate-operand!
                ]
            } case
        ] }
        { 1 [
            // register-indirect addressing mode, 8-bit displacement
            modrm-rm {
                { 4 [
                    !sib-byte
                    next-signed-byte ddisp!
                    sib-base {
                        { 4 [
                            sib-index 4 eq? sib-scale zero? and [
                                sib-base dbase!
                            ] [
                                unsupported
                            ] if
                        ] }
                        [ unsupported ]
                    } case
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    next-signed-byte ddisp!
                ]
            } case
            // source is imm8
            t immediate-operand?!
            next-byte immediate-operand!
        ] }
        { 3 [
            // register-direct addressing mode
            modrm-rm register-rm dreg!
            next-signed-byte immediate-operand!
            t immediate-operand?!
            t signed?!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x83 install-handler

: .84
    // /r
    // source is r8
    // dest is r/m8
    "test" mnemonic!
    !modrm-byte
    modrm-mod {
        { 3 [
            t register-direct?!
            modrm-reg sreg!
            8 ssize!
            modrm-rm dreg!
            8 dsize!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x84 install-handler

: .85
    // /r
    // source is r32/64
    // dest is r/m32/64
    "test" mnemonic!
    /r-r/m-reg ;

last-word 0x85 install-handler

: .87
    // /r
    // source is r/m32/64
    // dest is r32/64
    "xchg" mnemonic!
    /r-reg-r/m ;

last-word 0x87 install-handler

: .88
    // /r
    // source is r8
    // dest is r/m8
    "mov" mnemonic!
    !modrm-byte
    modrm-reg register-reg sreg!
    8 ssize!
    8 dsize!
    {
        { [ modrm-rm 4 = ] [
            !sib-byte
            sib-base {
                { 5 [
                    next-int32 ddisp!
                    t memory-operand?!
                ] }
                [
                    // default case
                    drop
                    sib-base register-rm dbase!
                    sib-index register-index dindex!
                    sib-scale dscale!
                ]
            } case
            .inst
        ] }
        { [ modrm-mod 0 = ] [ modrm-rm dbase! .inst ] }
        { [ modrm-mod 3 = ] [ modrm-rm dreg!  .inst ] }
        [ unsupported ]
    } cond ;

last-word 0x88 install-handler

: .89
    // /r
    // source is r32/64
    // dest is r/m32/64
    "mov" mnemonic!
    /r-r/m-reg ;

last-word 0x89 install-handler

: .8a
    // /r
    // source is r/m8
    // dest is r8
    "mov" mnemonic!
    !modrm-byte
    modrm-reg dreg!
    8 ssize!
    8 dsize!
    {
        { [ modrm-mod 3 = ] [ modrm-rm register-rm sreg! ] }
        { [ modrm-rm 4 = ] [
            !sib-byte
            sib-base {
                { 5 [
                    next-int32 sdisp!
                    t memory-operand?!
                ] }
                [
                    // default case
                    drop
                    sib-base register-rm sbase!
                    sib-index register-index sindex!
                    sib-scale sscale!
                ]
            } case
        ] }
        { [ modrm-mod 0 = ] [ modrm-rm register-rm sbase! ] }
        { [ modrm-mod 1 = ] [ modrm-rm register-rm sbase! next-signed-byte sdisp! ] }
        [ unsupported ]
    } cond
    .inst ;

last-word 0x8a install-handler

: .8b
    // /r
    // source is r/m32/64
    // dest is r32/64
    "mov" mnemonic!
    /r-reg-r/m ;

last-word 0x8b install-handler

: .8d
    "lea" mnemonic!
    !modrm-byte
    modrm-reg register-reg dreg!

    modrm-rm 4 = [ !sib-byte ] when

    modrm-mod {
        { 1 [
            // 1-byte displacement
            modrm-reg register-reg dreg!
            modrm-rm register-rm sbase!
            next-signed-byte sdisp!
        ] }
        { 2 [
            // disp32
            modrm-rm {
                { 4 [
                    sib-index 4 =
                    sib-base 4 = and
                    sib-scale 0 = and [
                        sib-base register-rm sbase!
                        ip l@s sdisp!
                        ip 4 + ip!
                    ] [ unsupported ] if
                ] }
            } case
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0x8d install-handler

: .8f
    "pop" mnemonic!
    1 #operands!
    !modrm-byte
    regop zero? [ unsupported ] unless
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-index 4 =
                    sib-base 5 = or [
                        // [disp32]
                        next-int32 ddisp!
                        t memory-operand?!
                    ] [ unsupported ] if
                ] }
            } case
        ] }
        { 1 [
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
        ] }
    } case
    .inst ;

last-word 0x8f install-handler

: .90
   "nop" mnemonic!
   0 #operands!
   .inst ;

last-word 0x90 install-handler

: .99
    prefix zero? "cqd" "cqo" ? mnemonic!
    0 #operands!
    .inst ;

last-word 0x99 install-handler

: .a1
    "movabs" mnemonic!
    0 dreg!     // ax/eax/rax
    next-uint64 sdisp!
    t memory-operand?!
    .inst ;

last-word 0xa1 install-handler

: .a4
    "movsb" mnemonic!
    0 #operands!
    .inst ;

last-word 0xa4 install-handler

: .a5
    instruction-operand-size {
        { 16 [ "movsw" ] }
        { 32 [ "movsd" ] }
        { 64 [ "movsq" ] }
    } case mnemonic!
    0 #operands!
    .inst ;

last-word 0xa5 install-handler

: .a6
    "cmpsb" mnemonic!
    0 #operands!
    .inst ;

last-word 0xa6 install-handler

: .a8
    // source is imm8
    // dest is al
    "test" mnemonic!
    8 dsize!
    0 dreg!     // al
    next-byte immediate-operand!
    t immediate-operand?!
    .inst ;

last-word 0xa8 install-handler

: .a9
    // source is imm16/32
    // dest is ax/eax/rax
    set-instruction-size
    "test" mnemonic!
    0 dreg!     // ax/eax/rax
    next-int32 immediate-operand!
    t immediate-operand?!
    .inst ;

last-word 0xa9 install-handler

: .aa
    "stosb" mnemonic!
    0 #operands!
    .inst ;

last-word 0xaa install-handler

: .ab
    prefix zero? "stosd" "stosq" ? mnemonic!
    0 #operands!
    .inst ;

last-word 0xab install-handler

: .b8
    // source is imm32/64
    // dest is r32/64
    "mov" mnemonic!
    opcode 0xb8 - register-rm dreg!
    prefix rex.w bitand zero? [
        next-uint32
        32 dsize!
    ] [
        next-uint64
    ] if
    immediate-operand!
    t immediate-operand?!
    .inst ;

8 [ 0xb8 + ' .b8 swap install-handler ] each-integer

: .c1
    // modrm-reg encodes opcode extension
    // source is imm8
    // dest is r/m32/64
    !modrm-byte
    t immediate-operand?!
    regop-mnemonic mnemonic!
    modrm-mod {
        { 1 [
            // dest is [r/m + disp8]
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
            next-signed-byte immediate-operand!
        ] }
        { 3 [
            // direct-mode register addressing
            t register-direct?!
            modrm-rm register-rm dreg!
            next-signed-byte immediate-operand!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0xc1 install-handler

: .c3
    "ret" mnemonic!
    0 #operands!
    .inst ;

last-word 0xc3 install-handler

: .c6
    // /0
    // source is imm8
    // dest is r/m8
    !modrm-byte
    regop zero? [ unsupported ] unless
    "mov" mnemonic!
    8 dup dsize! ssize!
    t immediate-operand?!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-index 4 = sib-base 5 = and [
                        next-int32 ddisp!
                        t memory-operand?!
                    ] [
                        sib-base register-rm dbase!
                        sib-index register-index dindex!
                        sib-scale dscale!
                    ] if
                    next-byte immediate-operand!
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    next-byte immediate-operand!
                ]
            } case
        ] }
        { 1 [
            // [r/m + disp8]
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
            next-byte immediate-operand!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0xc6 install-handler

: .c7
    // /0
    // source is imm16/32
    // dest is r/m16/32/64
    set-instruction-size
    !modrm-byte
    regop zero? [ unsupported ] unless
    "mov" mnemonic!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-base {
                        { 2 [
                            next-int32 immediate-operand!
                            t immediate-operand?!
                            sib-base register-rm dbase!
                            sib-index register-index dindex!
                            sib-scale dscale!
                        ] }
                        { 5 [
                            next-int32 ddisp!
                            t memory-operand?!
                            next-uint32 immediate-operand!
                            t immediate-operand?!
                        ] }
                    } case
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                    operand-size-prefix 0x66 = [
                        next-uint16 immediate-operand!
                    ] [
                        next-int32 immediate-operand!
                    ] if
                    t immediate-operand?!
                ]
            } case
        ] }
        { 1 [
            // [r/m + disp8]
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
            next-int32 immediate-operand!
            t immediate-operand?!
        ] }
        { 3 [
            modrm-rm register-rm dreg!
            next-int32 immediate-operand!
            t immediate-operand?!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0xc7 install-handler

: .cc
    "int3" mnemonic!
    0 #operands!
    .inst ;

last-word 0xcc install-handler

: .d1
    !modrm-byte
    regop-mnemonic mnemonic!
    modrm-mod {
        { 1 [
            // 1-byte displacement
            modrm-rm register-rm dbase!
            next-signed-byte ddisp!
            1 immediate-operand!
            t immediate-operand?!
        ] }
        { 3 [
            // register-direct
            modrm-rm register-rm dreg!
            1 immediate-operand!
            t immediate-operand?!
        ] }
    } case
    .inst ;

last-word 0xd1 install-handler

: .d3
    // dest is r/m32/64
    !modrm-byte
    regop-mnemonic mnemonic!
    modrm-mod 3 = [
        // register-direct
        modrm-rm register-rm dreg!
        // source is cl register
        1 sreg!
        8 ssize!
        .inst
    ] [ unsupported ] if ;

last-word 0xd3 install-handler

: .e2
   "loop" mnemonic!
   next-signed-byte ip + :> code-address
   .instruction-bytes
   .mnemonic
   dest-col code-address hex. ;

last-word 0xe2 install-handler

: .e3
    // jump short if rcx == 0
    "jrcxz" mnemonic!
    next-signed-byte ip + :> target
    ip instruction-start - .bytes
    .instruction-bytes
    .mnemonic
    dest-col target hex. ;

last-word 0xe3 install-handler

: .eb "jmp" jmp/jcc-rel8 ;

last-word 0xeb install-handler

: .e8
   "call" mnemonic!
   next-int32 ip + :> code-address
   .instruction-bytes
   .mnemonic
   dest-col
   code-address dup hex.
   find-word-from-exact-code-address [ comment-col symbol-name write ] when* ;

last-word 0xe8 install-handler

: .e9
   "jmp" mnemonic!
   next-int32 ip + :> jump-target
   .instruction-bytes
   .mnemonic
   dest-col
   jump-target dup hex.
   find-word-from-exact-code-address [ comment-col symbol-name write ] when* ;

last-word 0xe9 install-handler

: .f2
    "repne" mnemonic!
    0 #operands!
    .inst ;

last-word 0xf2 install-handler

: .f3
    "rep" mnemonic!
    0 #operands!
    .inst ;

last-word 0xf3 install-handler

: .f6
    !modrm-byte
    regop-mnemonic mnemonic!
    regop {
        { 0 [
            modrm-mod {
                { 1 [ modrm-rm register-rm dbase! next-signed-byte ddisp! ] }
                { 3 [ modrm-rm dreg! ] }
            } case
            next-byte immediate-operand!
            t immediate-operand?!
            8 dsize!
        ] }
        [
            // default case
            drop
            modrm-rm dreg!
            8 dsize!
            1 #operands!
        ]
    } case
    .inst ;

last-word 0xf6 install-handler

: .f7
    set-instruction-size
    !modrm-byte
    regop-mnemonic mnemonic!
    regop {
        { 0 [
            // test
            // source is imm16/32
            // dest is r/m16/32/64
            modrm-mod {
                { 1 [
                    modrm-rm register-rm dbase!
                    next-signed-byte ddisp!
                    next-int32 immediate-operand!
                    t immediate-operand?!
                ] }
                { 3 [
                    modrm-rm register-rm dreg!
                    next-int32 immediate-operand!
                    t immediate-operand?!
                ] }
                [ unsupported ]
            } case
        ] }
        { 5 [
            // imul
            modrm-mod {
                { 1 [
                    modrm-rm register-rm dbase!
                    next-signed-byte ddisp!
                ] }
                [ unsupported ]
            } case
            1 #operands!
        ] }
        [
            // default case
            drop
            modrm-rm dreg!
            1 #operands!
        ]
    } case
    .inst ;

last-word 0xf7 install-handler

: .fc
    "cld" mnemonic!
    0 #operands!
    .inst ;

last-word 0xfc install-handler

: .fd
    "std" mnemonic!
    0 #operands!
    .inst ;

last-word 0xfd install-handler

: .ff
    !modrm-byte
    regop { "inc" "dec" "call" "callf" "jmp" "jmpf" "push" } nth mnemonic!
    1 #operands!
    modrm-mod {
        { 0 [
            modrm-rm {
                { 4 [
                    !sib-byte
                    sib-index 4 = [
                        sib-base {
                            { 4 [ modrm-rm register-rm dbase! ] }
                            { 5 [ next-int32 ddisp! t memory-operand?! ] }
                        } case
                    ] when
                ] }
                { 5 [
                    // RIP-relative addressing, 32-bit offset
                    next-int32 ip + ddisp! t memory-operand?!
                ] }
                [
                    // default case
                    drop
                    modrm-rm register-rm dbase!
                ]
            } case
        ] }
        { 1 [
            modrm-rm 4 = [
                !sib-byte
                next-signed-byte ddisp!
                sib-byte 0x24 = [
                    sib-base dbase!
                ] [
                    sib-base register-rm dbase!
                    sib-index register-index dindex!
                    sib-scale dscale!
                ] if
            ] [
                modrm-rm register-rm dbase!
                next-signed-byte ddisp!
            ] if
        ] }
        { 3 [ modrm-rm register-rm dreg! ] }
    } case
    .inst ;

last-word 0xff install-handler

// 2-byte opcodes beginning with 0x0f

global 0x0f-handlers 256 make-array/1 0x0f-handlers!

: install-0x0f-handler                  // handler opcode -> void
    0x0f-handlers array-set-nth ;

: 0x0f-handler                          // opcode -> handler
    0x0f-handlers array-nth ;

: .0f
    next-byte dup byte2! 0x0f-handler
    [ execute-handler ] [ unsupported ] if* ;

last-word 0x0f install-handler

: .0f-31
    "rdtsc" mnemonic!
    0 #operands!
    .inst ;

last-word 0x31 install-0x0f-handler

: cmovcc-mnemonic                       // byte2 -> void
    0x0f bitand {
        "cmovo" "cmovno" "cmovc"  "cmovnc" "cmovz" "cmovnz" "cmovna" "cmova"
        "cmovs" "cmovns" "cmovpe" "cmovpo" "cmovl" "cmovge" "cmovle" "cmovg"
    } array-nth ;

: .0f-4x
    set-instruction-size
    byte2 cmovcc-mnemonic mnemonic!
    !modrm-byte
    modrm-reg register-reg dreg!
    modrm-mod {
        { 3 [
            // register-direct addressing mode
            modrm-rm register-rm sreg!
        ] }
        [ unsupported ]
    } case
    .inst ;

16 [ 0x40 + ' .0f-4x swap install-0x0f-handler ] each-integer

: .0f-80 "jo"  jcc-rel32 ; last-word 0x80 install-0x0f-handler
: .0f-81 "jno" jcc-rel32 ; last-word 0x81 install-0x0f-handler
: .0f-82 "jc"  jcc-rel32 ; last-word 0x82 install-0x0f-handler
: .0f-83 "jnc" jcc-rel32 ; last-word 0x83 install-0x0f-handler
: .0f-84 "jz"  jcc-rel32 ; last-word 0x84 install-0x0f-handler
: .0f-85 "jne" jcc-rel32 ; last-word 0x85 install-0x0f-handler
: .0f-86 "jna" jcc-rel32 ; last-word 0x86 install-0x0f-handler
: .0f-87 "ja"  jcc-rel32 ; last-word 0x87 install-0x0f-handler
: .0f-88 "js"  jcc-rel32 ; last-word 0x88 install-0x0f-handler
: .0f-8c "jl"  jcc-rel32 ; last-word 0x8c install-0x0f-handler
: .0f-8d "jge" jcc-rel32 ; last-word 0x8d install-0x0f-handler
: .0f-8e "jle" jcc-rel32 ; last-word 0x8e install-0x0f-handler
: .0f-8f "jg"  jcc-rel32 ; last-word 0x8f install-0x0f-handler

: setcc-mnemonic                        // byte -> string
    0x0f bitand {
        "seto" "setno" "setc"  "setnc" "setz" "setnz" "setna" "seta"
        "sets" "setns" "setpe" "setpo" "setl" "setge" "setle" "setg"
    } array-nth ;

: .0f-9x
    byte2 setcc-mnemonic mnemonic!
    !modrm-byte
    modrm-mod {
        { 3 [ modrm-rm dreg! 8 dsize! 1 #operands! ] }
        [ unsupported ]
    } case
    .inst ;

16 [ 0x90 + ' .0f-9x swap install-0x0f-handler ] each-integer

: .0f-a2
    "cpuid" mnemonic!
    0 #operands!
    .inst ;

last-word 0xa2 install-0x0f-handler

: .0f-af
    "imul" mnemonic!
    /r-reg-r/m ;

last-word 0xaf install-0x0f-handler

: .0f-b6
    // ModR/M byte contains both a register and an r/m operand
    // source is r/m8
    // dest is r32/64
    set-instruction-size
    "movzx" mnemonic!
    8 ssize!
    !modrm-byte
    modrm-reg register-reg dreg!
    instruction-operand-size dsize!
    modrm-mod {
        { 0 [
            modrm-rm 4 = [
                !sib-byte
                sib-base register-rm sbase!
                sib-index register-index sindex!
                sib-scale sscale!
            ] [
                modrm-rm register-rm sbase!
            ] if
        ] }
        { 1 [
            modrm-rm 4 = [
                !sib-byte
                next-signed-byte sdisp!
                sib-byte 0x24 = [
                    sib-base sbase!
                ] [
                    sib-base register-rm sbase!
                    sib-index register-index sindex!
                    sib-scale sscale!
                ] if
            ] [
                modrm-rm register-rm sbase!
                next-signed-byte sdisp!
            ] if
        ] }
        { 3 [
            t register-direct?!
            modrm-rm register-rm sreg!
        ] }
        [ unsupported ]
    } case
    .inst ;

last-word 0xb6 install-0x0f-handler

: .0f-b7
    // source is r/m16
    16 ssize!
    // dest is r32/64
    instruction-operand-size dsize!
    "movzx" mnemonic!
    !modrm-byte
    modrm-reg register-reg dreg!
    modrm-mod {
        { 0 [ modrm-rm register-rm sbase! ] }
        { 1 [ modrm-rm register-rm sbase! next-signed-byte sdisp! ] }
        { 3 [ t register-direct?! modrm-rm register-rm sreg! ] }
        [ unsupported ]
    } case .inst ;

last-word 0xb7 install-0x0f-handler

: .0f-be
    "movsx" mnemonic!
    !modrm-byte
    modrm-rm register-rm dreg!
    modrm-mod {
        { 0 [
            modrm-rm register-rm sbase!
            8 ssize!
        ] }
        [
            // default case
            drop
            modrm-reg sreg!
            8 ssize!
        ]
    } case
    .inst ;

last-word 0xbe install-0x0f-handler

: .opcode
    opcode handler [ execute-handler ] [ unsupported ] if* ;

: decode
    reset-disassembler
    .ip
    ip c@ !> byte
    byte 0x66 eq? [
        byte operand-size-prefix!
        ++ip
        ip c@ byte!
    ] when
    byte 0x40 0x4f between? [
        byte prefix!
        ip 1 + c@ opcode!
        ip 2 + ip!
    ] [
        byte opcode!
        0 prefix!
        ++ip
    ] if
    .opcode
    #insts 1+ #insts! ;

: print-header
    start-address find-word-from-exact-code-address [
        dup symbol-qualified-name write space
        symbol-location 2dup and [ swap write space dec. ] [ 2drop ] if
        nl
    ] when* ;

: disasm                                // code-address code-size -> void
    2 ?enough
    over start-address!
    + stop-address!

    print-header

    start-address ip!
    0 #insts!

    [ ip stop-address >= ] [ decode ] until

    ?nl
    #insts dec. " instructions " write-string
    ip start-address - dec. " bytes" write-string ;

: disasm/1                              // code-address -> void
    start-address!

    print-header

    start-address ip!
    0 #insts!

    [ ip c@ 0xc3 eq? ] [ decode ] until

    decode

    ?nl
    #insts dec. " instructions " write-string
    ip start-address - dec. " bytes" write-string ;

: disassemble                           // symbol -> void
    [ symbol-code-address ] [ symbol-code-size ] bi disasm ;

global choices

: maybe-choose-symbol                   // index -> symbol/f
    1- choices ?nth ;

: find-symbol                           // string -> symbol/f
    find-qualified-name [
        all-words [ symbol-name over = ] filter nip
        dup length {
            { 0 [ drop nil ] }
            { 1 [ first ] }
            [
                // more than 1 match
                drop
                dup choices!
                [
                    1+ dec. space
                    symbol-qualified-name write-string nl
                ] each-index
                nil
            ]
        } case
    ] unless ;

: d/1 ( token1 )
    token1 string->index :> n
    local sym
    n [
        token1 find-symbol sym!
    ] unless
    {
        { [ n ] [
            n 1024 > [ n disasm/1 ] [
                choices [ n maybe-choose-symbol sym! ] when
            ] if
        ] }
        // default
        [ ]
    } cond
    sym [ sym disassemble ] when ;

: d/2 ( token1 token2 )
    token1 string->index :> addr
    local len
    local sym1
    local sym2
    addr [
        token2 string->index len!
    ] [
        token1 find-symbol sym1!
        token2 find-symbol sym2!
    ] if
    {
        { [ addr len and ] [
            addr len disasm
        ] }
        { [ sym1 sym2 and ] [
            sym1 sym2 find-method [
                method-callable callable-code-address disasm/1
            ] when*
        ] }
        // default
        [ ]
    } cond ;

: d
    parse-token :> token1
    token1 nil? ?exit
    parse-token :> token2
    token2 [ token1 token2 d/2 ] [ token1 d/1 ] if ;

: test-all
    all-words [ nl nl dec. space dup . disassemble ] each-index ;
