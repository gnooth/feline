LANGUAGE: feline

USING: feline ;
IN: feline

// this is a comment
( this is another comment )

: failed ( -- )
    ?cr "failed" print
;

: check-t ( x -- )
    t eq? [ failed ] unless
;

: check-false ( x -- )
    f eq? [ failed ] unless
;

1 2 + 3 eq? check-t
1 2 + 4 eq? check-false

"test" "test" eq? check-false

V{ 1 2 3 } length 3 = check-t
V{ "this is a test" } length 1 = check-t

V{ 1 2 3 } [ dup + ] map V{ 2 4 6 } sequence= check-t

"this is a multiline
string" length 26 = check-t

clear

: multiline-string-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    "this is
a multiline string"
    length 26 = check-t
;

multiline-string-test-1

: fixnum-test-1 ( -- )
    1 fixnum? check-t
    2 fixnum? check-t
    3 fixnum? check-t
    1 2 + 3 = check-t
    1 2 + fixnum? check-t
;

fixnum-test-1

: fixnum-test-2 ( -- )
    -1 fixnum? check-t
    -2 fixnum? check-t
    -3 fixnum? check-t
    -1 -2 + -3 = check-t
;

fixnum-test-2

: fixnum-test-3 ( -- )
    0 fixnum? check-t
    0 0 = check-t
    1 0 = check-false
    -1 0 = check-false
    1 -1 + 0 = check-t
    4 -4 + 0 = check-t
;

fixnum-test-3

// fixnum<
: fixnum-test-4 ( -- )
    1 2 fixnum< check-t
    2 1 fixnum< check-false
    -2 -1 fixnum< check-t
    -1 -2 fixnum< check-false
    -2 1 fixnum< check-t
    1 -2 fixnum< check-false
    1 2 < check-t
    2 1 fixnum>= check-t
    2 1 >= check-t
;

fixnum-test-4

: fixnum-test-5 ( -- )
    1 2 fixnum- -1 = check-t
    1 2 - -1 = check-t
;

fixnum-test-5

: fixnum-test-6 ( -- )
    2 3 fixnum* 6 = check-t
    2 3 * 6 = check-t
;

fixnum-test-6

: fixnum-test-7 ( -- )
    8 3 fixnum/i 2 = check-t
    8 3 / 2 = check-t
    -8 3 fixnum/i -2 = check-t
    -8 3 / -2 = check-t
;

fixnum-test-7

: fixnum-test-8 ( -- )
    7 3 fixnum-mod 1 = check-t
    7 3 mod 1 = check-t
    -7 3 fixnum-mod -1 = check-t
    -7 3 mod -1 = check-t
;

fixnum-test-8

// fixnum-bitand, bitand
: fixnum-test-9 ( -- )
    15 7 bitand 7 = check-t
    15 $f0 bitand 0 = check-t
    3 1 bitand 1 = check-t
;

fixnum-test-9

// fixnum+
: fixnum-test-10 ( -- )
    42 87 fixnum+ 129 = check-t
    -42 87 fixnum+ 45 = check-t
    42 -87 fixnum+ -45 = check-t
    -42 -87 fixnum+ -129 = check-t
;

fixnum-test-10

: fixnum-test-11 ( -- )
    MOST_POSITIVE_FIXNUM tag-fixnum most-positive-fixnum = check-t
    MOST_NEGATIVE_FIXNUM tag-fixnum most-negative-fixnum = check-t
    most-positive-fixnum untag-fixnum MOST_POSITIVE_FIXNUM = check-t
    most-negative-fixnum untag-fixnum MOST_NEGATIVE_FIXNUM = check-t
;

fixnum-test-11

: dip-test-1 ( -- )
    87 42 [ 3 * ] dip get-datastack V{ 261 42 } sequence= check-t
    clear
;

dip-test-1

: keep-test-1 ( -- )
    42 [ dup ] keep get-datastack V{ 42 42 42 } sequence= check-t
    clear
;

keep-test-1

: bi@-test-1
    3 4 [ dup ] bi@ get-datastack V{ 3 3 4 4 } sequence= check-t
    clear
;

bi@-test-1

: array-test-1 ( -- )
    10 42 <array>
    [ object? check-t ] keep
    [ array? check-t ] keep
    [ length 10 = check-t ] keep
    10 [ over nth 42 eq? check-t ] each-integer
    drop
;

array-test-1

: array-test-2 ( -- )
    10 f <array>
    10 [ ( array index ) [ number>string ] keep pick set-nth ] each-integer
    drop
;

array-test-2

// vector-insert-nth!
: vector-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    17 0 V{ 0 1 2 3 } [ vector-insert-nth! ] keep
    V{ 17 0 1 2 3 } sequence= check-t
    clear
;

vector-test-1

: vector-test-2 ( -- )
    << last-word symbol-name >> ?cr write
    10 <vector> [ vector? check-t ] keep
    10 [ dup pick vector-set-nth ] each-integer
    [ [ eq? check-t ] vector-each-index ] keep
    clear
;

vector-test-2

: vector-test-3 ( -- )
    << last-word symbol-name >> ?cr write
    1 <vector> [ vector? check-t ] keep
    10 [ over vector-push ] each-integer
    10 [ dup pick vector-nth eq? check-t ] each-integer
    10 [ 9 swap - over vector-pop eq? check-t ] each-integer
    vector-length zero? check-t
;

vector-test-3

// vector-pop*
: vector-test-4 ( -- )
    << last-word symbol-name >> ?cr write
    V{ 1 2 3 } [ vector-pop* ] keep
    [ length 2 = check-t ] keep
    [ vector-pop* ] keep
    [ length 1 = check-t ] keep
    [ vector-pop* ] keep
    [ length zero? check-t ]
;

vector-test-4

// vector-last
: vector-test-5 ( -- )
    << last-word symbol-name >> ?cr write
    clear
    V{ 1 2 3 } vector-last get-datastack { 3 } sequence= check-t
    clear
    V{ "test" } vector-last "test" = check-t
;

: %local-test-1 ( -- )
    42 :> foo
    foo
;

: local-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    %local-test-1 42 eq? check-t
;

local-test-1

: if-test-1 ( -- )
    t [ 42 ] [ 17 ] if 42 eq? check-t
    f [ 42 ] [ 17 ] if 17 eq? check-t
    0 [ 42 ] [ 17 ] if 42 eq? check-t
;

if-test-1

: if*-test-1 ( -- )
    clear
    t [ 42 ] [ 17 ] if* get-datastack { t 42 } sequence= check-t
    clear
    f [ 42 ] [ 17 ] if* get-datastack { 17 } sequence= check-t
    clear
    0 [ 42 ] [ 17 ] if* get-datastack { 0 42 } sequence= check-t
    clear
;

if*-test-1

: symbol?-test-1 ( -- )
    \ dup symbol? check-t
    \ check-t symbol? check-t
    42 symbol? check-false
    -3 symbol? check-false
    "test" symbol? check-false
;

symbol?-test-1

: string>number-test-1 ( -- )
    "." string>number check-false
    "-" string>number check-false
;

string>number-test-1

: \-test-1 ( -- )
    [ \ dup ] call symbol? check-t
    3 [ dup ] call get-datastack { 3 3 } sequence= check-t
    clear
;

\-test-1

: hashcode-test-1 ( -- )
    "test"
    [ string-hashcode check-false ] keep
    [ hashcode dup fixnum? check-t ] keep
    string-hashcode eq? check-t
;

hashcode-test-1

: hashcode-test-2 ( -- )
    \ dup
    [ symbol-name "dup" string= check-t ] keep
    [ symbol-vocab-name "feline" string= check-t ] keep
    [ symbol-hashcode ] keep
    [ symbol-name hashcode ] keep
    symbol-vocab-name hashcode hash-combine eq? check-t
;

hashcode-test-2

: length-test-1 ( -- )
    "test" length 4 eq? check-t
    "testing" string>sbuf length 7 eq? check-t
    { 1 2 3 } length 3 eq? check-t
    V{ 1 2 3 "test" } length 4 eq? check-t
;

length-test-1

: globals-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    clear
    42 \ dup set-global get-datastack { } sequence= check-t
    \ dup get-global get-datastack { 42 } sequence= check-t
    clear
    \ dup get get-datastack { 42 } sequence= check-t
    clear
;

globals-test-1

: find-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    V{ 1 2 3 4 5 6 } [ 3 = ] find
    get-datastack V{ 2 3 } sequence= check-t
    clear
    V{ 1 2 3 4 5 6 } [ 17 = ] find
    get-datastack f f 2array sequence= check-t
    clear
    4 V{ 1 2 3 4 5 6 } [ dupd = ] find
    get-datastack V{ 4 3 4 } sequence= check-t
    clear
;

find-test-1

: map-find-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    clear
    V{ 1 2 3 4 5 6 } [ 3 = ] map-find get-datastack { t 3 } sequence= check-t
    clear
    V{ 1 2 3 4 5 6 } [ 17 = ] map-find get-datastack { f f } sequence= check-t
    clear
    4 V{ 1 2 3 4 5 6 } [ dupd = ] map-find get-datastack { 4 t 4 } sequence= check-t
    clear
;

map-find-test-1

: ?lookup-symbol-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    "dup" "feline" ?lookup-symbol \ dup eq? check-t
    "xxx" "feline" ?lookup-symbol check-false
    "dup" "xxx" ?lookup-symbol check-false
;

?lookup-symbol-test-1

: parsing-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    V{ SYMBOL: dup } V{ } sequence= check-t
    clear
;

parsing-test-1

: %parsing-test-2 ( -- )
    SYMBOL: dup
    42
;

: parsing-test-2 ( -- )
    << last-word symbol-name >> ?cr write
    clear
    %parsing-test-2 get-datastack { 42 } sequence= check-t
    clear
;

parsing-test-2

: sequence=-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    { "this is a test" } { "this is a test" } sequence= check-t
;

sequence=-test-1

: symbol-props-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    clear
    "foo" \ dup symbol-prop get-datastack { f } sequence= check-t
    clear
    "this is a test" "foo" \ dup symbol-set-prop
    "foo" \ dup symbol-prop get-datastack { "this is a test" } sequence= check-t
    clear
;

symbol-props-test-1

: times-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    0 10 [ 1 + ] times 10 eq? check-t
;

times-test-1

: filter-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    V{ 1 2 3 4 } [ 3 < ] filter V{ 1 2 } sequence= check-t
     { 1 2 3 4 } [ 3 < ] filter  { 1 2 } sequence= check-t
;

filter-test-1

: member?-test-1 ( -- )
    << last-word symbol-name >> ?cr write
    17 { 1 2 3 } member? check-false
    1  { 1 2 3 } member? check-t
    f  { 1 2 3 } member? check-false
    f  { 1 f 3 } member? check-t
;

member?-test-1

?cr "Reached end of test.feline" write
