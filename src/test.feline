using: unit-test feline ;
in: test

empty

default-visibility get ' feline:public assert-eq

public

// this is a comment

interactive? get assert-false

1 2 + 3 assert-eq
1 2 + 4 eq? assert-false

"test" "test" eq? assert-false

vector{ 1 2 3 } length 3 assert=
vector{ "this is a test" } length 1 assert=

fixnum-tag-bits 1 assert-eq
most-positive-fixnum 4611686018427387903 assert-eq
most-negative-fixnum -4611686018427387904 assert-eq

"this is a multiline
string" length 26 assert=

clear

test: multiline-string-test-1
    "this is
a multiline string"
    dup string? assert
    dup length 26 assert=
    "this is\na multiline string" assert=
;

multiline-string-test-1

test: string-literal-escapes-test-1
    "this is a \"test\"!\n" string-length 18 assert-eq
;

string-literal-escapes-test-1

test: string?-test
    t string? assert-false
    nil string? assert-false
    42 string? assert-false
    2000000 string? assert-false
    "test" string? assert
    "test" dup string? assert-eq
    ' dup string? assert-false
    ' dup symbol-name dup string? assert-eq ;

string?-test

// Test for the Factor/Feline version of pick.
// The Forth version of pick is different.
test: pick-test-1
    clear
    1 2 3 pick get-datastack { 1 2 3 1 } sequence= assert-true
    clear
;

pick-test-1

// Test for the Factor/Feline version of 2over.
// The Forth version of 2over is different.
test: 2over-test-1
    clear
    1 2 3 2over get-datastack { 1 2 3 1 2 } sequence= assert-true
    clear
;

2over-test-1

test: fixnum?-test-1
    most-negative-fixnum dup fixnum? assert-eq
    -3 dup fixnum? assert-eq
    -2 dup fixnum? assert-eq
    -1 dup fixnum? assert-eq
    0 dup fixnum? assert-eq
    1 dup fixnum? assert-eq
    2 dup fixnum? assert-eq
    3 dup fixnum? assert-eq
    most-positive-fixnum dup fixnum? assert-eq
    "test" fixnum? assert-false
    ' dup fixnum? assert-false
    { 1 2 3 } fixnum? assert-false
;

fixnum?-test-1

test: fixnum-test-1
    1 2 + 3 assert=
    1 2 + dup fixnum? assert-eq ;

fixnum-test-1

test: fixnum-test-2
    -1 -2 + -3 assert=
;

fixnum-test-2

test: fixnum-test-3
    0 dup fixnum? assert-eq
    0 0 assert=
    1 0 = assert-false
    -1 0 = assert-false
    1 -1 + 0 assert=
    4 -4 + 0 assert=
;

fixnum-test-3

// fixnum<
test: fixnum<-test-1
    0 0 fixnum< assert-false
    1 1 fixnum< assert-false
    1 2 fixnum< assert-true
    2 1 fixnum< assert-false
    -2 -1 fixnum< assert-true
    -1 -2 fixnum< assert-false
    -2 1 fixnum< assert-true
    1 -2 fixnum< assert-false
    most-negative-fixnum 0 fixnum< assert-true
    most-negative-fixnum most-positive-fixnum fixnum< assert-true
    0 most-positive-fixnum fixnum< assert-true
;

fixnum<-test-1

// fixnum<=
test: fixnum<=-test-1
    0 0 fixnum<= assert-true
    1 1 fixnum<= assert-true
    1 2 fixnum<= assert-true
    2 1 fixnum<= assert-false
    -2 -1 fixnum<= assert-true
    -1 -2 fixnum<= assert-false
    -2 1 fixnum<= assert-true
    1 -2 fixnum<= assert-false
    most-negative-fixnum 0 fixnum<= assert-true
    most-negative-fixnum most-positive-fixnum fixnum<= assert-true
    most-negative-fixnum most-negative-fixnum fixnum<= assert-true
    most-positive-fixnum most-positive-fixnum fixnum<= assert-true
    0 most-positive-fixnum fixnum<= assert-true
;

fixnum<=-test-1

test: fixnum>-test-1
    0 0 fixnum> assert-false
    1 1 fixnum> assert-false
    1 2 fixnum> assert-false
    2 1 fixnum> assert-true
    -2 -1 fixnum> assert-false
    -1 -2 fixnum> assert-true
    -2 1 fixnum> assert-false
    1 -2 fixnum> assert-true
    most-negative-fixnum 0 fixnum> assert-false
    most-negative-fixnum most-positive-fixnum fixnum> assert-false
    most-positive-fixnum most-negative-fixnum fixnum> assert-true
    0 most-positive-fixnum fixnum> assert-false

    most-positive-fixnum 1 + most-positive-fixnum fixnum> assert-true
;

fixnum>-test-1

test: fixnum>=-test-1
    0 0 fixnum>= assert-true
    1 1 fixnum>= assert-true
    1 2 fixnum>= assert-false
    2 1 fixnum>= assert-true
    -2 -1 fixnum>= assert-false
    -1 -2 fixnum>= assert-true
    -2 1 fixnum>= assert-false
    1 -2 fixnum>= assert-true
    most-negative-fixnum 0 fixnum>= assert-false
    most-negative-fixnum most-positive-fixnum fixnum>= assert-false
    most-negative-fixnum most-negative-fixnum fixnum>= assert-true
    most-positive-fixnum most-positive-fixnum fixnum>= assert-true
    0 most-positive-fixnum fixnum>= assert-false
;

fixnum>=-test-1

test: >=-test-1
     0  0 >= assert-true
     1  1 >= assert-true
     1  2 >= assert-false
     2  1 >= assert-true
    -2 -1 >= assert-false
    -1 -2 >= assert-true
    -2  1 >= assert-false
     1 -2 >= assert-true

    most-negative-fixnum 0 >= assert-false
    0 most-positive-fixnum >= assert-false

    most-negative-fixnum most-positive-fixnum >= assert-false
    most-negative-fixnum most-negative-fixnum >= assert-true
    most-positive-fixnum most-positive-fixnum >= assert-true
    most-positive-fixnum most-negative-fixnum >= assert-true

    most-positive-int64 0.0 >= assert-true
    most-negative-int64 0.0 >= assert-false
;

>=-test-1

test: fixnum-test-5
    1 2 fixnum- -1 assert=
    1 2 - -1 assert=
;

fixnum-test-5

test: fixnum-test-6
    2 3 fixnum* 6 assert=
    2 3 * 6 assert=
;

fixnum-test-6

test: fixnum-test-7
    8 3 fixnum/i 2 assert=
    8 3 / float? assert
    8 3 / 2 = assert-false
    8 3 / 2 swap = assert-false
    8 3 / 2 equal? assert-false
    8 3 / 2 swap equal? assert-false
    -8 3 fixnum/i -2 assert=
    -8 3 / -2 = assert-false
;

fixnum-test-7

test: mod-test-1
     7  3 mod  1 assert=
     7 -3 mod  1 assert=
    -7  3 mod -1 assert=

     7  3 fixnum>int64 mod  1 assert=
     7 -3 fixnum>int64 mod  1 assert=
    -7  3 fixnum>int64 mod -1 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 17 mod 15 assert=
//         most-positive-fixnum 1 + dup int64? assert 17 mod 16 assert=
//         most-positive-fixnum 2 + dup int64? assert 17 mod  0 assert=
//         most-positive-fixnum 3 + dup int64? assert 17 mod  1 assert=
//
//         most-positive-fixnum 17 mod 15 fixnum>int64 assert=
//         most-positive-fixnum 1 + 17 fixnum>int64 mod 16 assert=
//         most-positive-fixnum 2 + 17 fixnum>int64 mod  0 assert=
//         most-positive-fixnum 3 + 17 fixnum>int64 mod  1 assert=
//     ] when
;

mod-test-1

test: fixnum-abs-test-1
     17 fixnum-abs 17 assert-eq
    -17 fixnum-abs 17 assert-eq

    most-positive-fixnum dup fixnum-abs assert-eq
    most-positive-fixnum 1 - dup fixnum-abs assert-eq

    most-negative-fixnum 1 + fixnum-abs most-positive-fixnum assert-eq
    most-negative-fixnum fixnum-abs dup int64? assert most-positive-fixnum 1 + assert=
;

fixnum-abs-test-1

// fixnum-bitand, bitand
test: fixnum-test-9
    15 7 bitand 7 assert=
    15 0xf0 bitand 0 assert=
    3 1 bitand 1 assert=
;

fixnum-test-9

// fixnum+
test: fixnum-test-10
     42  87 fixnum+  129 assert=
    -42  87 fixnum+   45 assert=
     42 -87 fixnum+  -45 assert=
    -42 -87 fixnum+ -129 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 1152921504606846975 assert-eq
//         most-positive-fixnum 1 - 1152921504606846974 assert-eq
//         most-positive-fixnum 1 + dup int64? assert 1152921504606846976 assert=
//
//         most-negative-fixnum -1152921504606846976 assert-eq
//         most-negative-fixnum 1 + -1152921504606846975 assert-eq
//         most-negative-fixnum 1 - dup int64? assert -1152921504606846977 assert=
//     ] when
;

fixnum-test-10

test: fixnum>string-test-1
    -17 fixnum>string "-17" assert=
      0 fixnum>string   "0" assert=
     42 fixnum>string  "42" assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-negative-fixnum fixnum>string "-1152921504606846976" assert=
//         most-negative-fixnum 1 + fixnum>string "-1152921504606846975" assert=
//         most-negative-fixnum 2 + fixnum>string "-1152921504606846974" assert=
//         most-positive-fixnum fixnum>string "1152921504606846975" assert=
//     ] when
;

fixnum>string-test-1

test: fixnum->hex-test
    -17 fixnum->hex "-11" assert=
      0 fixnum->hex   "0" assert=
     42 fixnum->hex  "2a" assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-negative-fixnum     fixnum>hex "-1000000000000000" assert=
//         most-negative-fixnum 1 + fixnum>hex  "-fffffffffffffff" assert=
//         most-negative-fixnum 2 + fixnum>hex  "-ffffffffffffffe" assert=
//         most-positive-fixnum     fixnum>hex   "fffffffffffffff" assert=
//     ] when

    most-negative-fixnum     fixnum->hex "-4000000000000000" assert=
    most-negative-fixnum 1 + fixnum->hex "-3fffffffffffffff" assert=
    most-negative-fixnum 2 + fixnum->hex "-3ffffffffffffffe" assert=

    most-positive-fixnum fixnum->hex "3fffffffffffffff" assert=

    -576460752303423488 fixnum->hex "-800000000000000" assert=
     576460752303423487 fixnum->hex  "7ffffffffffffff" assert= ;

fixnum->hex-test

test: number>string-test-1
    -17 number>string "-17" assert=
    0 number>string "0" assert=
    42 number>string "42" assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-negative-fixnum number>string "-1152921504606846976" assert=
//         most-positive-fixnum number>string  "1152921504606846975" assert=
//     ] when
;

number>string-test-1

test: fixnum-max-test-1
    1 2 fixnum-max 2 assert-eq
    2 1 fixnum-max 2 assert-eq
    -1 2 fixnum-max 2 assert-eq
    2 -1 fixnum-max 2 assert-eq
    most-positive-fixnum 0 fixnum-max most-positive-fixnum assert-eq
    most-negative-fixnum 0 fixnum-max 0? assert
    0 most-positive-fixnum fixnum-max most-positive-fixnum assert-eq
    0 most-negative-fixnum fixnum-max 0? assert
;

fixnum-max-test-1

test: max-test-1
    1 2 max 2 assert-eq
    2 1 max 2 assert-eq
    -1 2 max 2 assert-eq
    2 -1 max 2 assert-eq
    most-positive-fixnum 0 max most-positive-fixnum assert-eq
    most-negative-fixnum 0 max zero? assert-true
    0 most-positive-fixnum max most-positive-fixnum assert-eq
    0 most-negative-fixnum max zero? assert-true
;

max-test-1

test: fixnum-min-test-1
    1 2 fixnum-min 1 assert-eq
    2 1 fixnum-min 1 assert-eq
    -1 2 fixnum-min -1 assert-eq
    2 -1 fixnum-min -1 assert-eq
    most-positive-fixnum 0 fixnum-min zero? assert-true
    most-negative-fixnum 0 fixnum-min most-negative-fixnum assert-eq
    0 most-positive-fixnum fixnum-min zero? assert-true
    0 most-negative-fixnum fixnum-min most-negative-fixnum assert-eq
;

fixnum-min-test-1

test: min-test-1
    1 2 min 1 assert-eq
    2 1 min 1 assert-eq
    -1 2 min -1 assert-eq
    2 -1 min -1 assert-eq
    most-positive-fixnum 0 min zero? assert-true
    most-negative-fixnum 0 min most-negative-fixnum assert-eq
    0 most-positive-fixnum min zero? assert-true
    0 most-negative-fixnum min most-negative-fixnum assert-eq
;

min-test-1

test: min-length-test-1
    "test"     "this is a test" min-length 4 assert=
    ""         "effluvia"       min-length 0 assert=
    { 1 2 3 }  { 4 }            min-length 1 assert=
    vector{ 1 2 3 } ""          min-length 0 assert= ;

min-length-test-1

test: each-index-test-1
    clear
    { "a" "b" "c" } [ 2array ] each-index get-datastack
    { { "a" 0 } { "b" 1 } { "c" 2 } } sequence= assert-true
    clear
;

each-index-test-1

test: map-test-1
    vector{ 1 2 3 } [ dup + ] map vector{ 2 4 6 } assert=
    clear
    { { 1 2 } { 3 4 } { 5 6 } } [ first ] map get-datastack { { 1 3 5 } } assert=
    clear
    { 3 -4 2 -5 -6 } [ abs ] map get-datastack { { 3 4 2 5 6 } } assert=
    clear
;

map-test-1

test: map-index-test-1
    clear
    { "a" "b" "c" } [ 2array ] map-index get-datastack
    { { { "a" 0 } { "b" 1 } { "c" 2 } } } assert=
    clear
    vector{ "a" "b" "c" } [ 2array ] map-index get-datastack
    { vector{ { "a" 0 } { "b" 1 } { "c" 2 } } } assert=
    clear
;

map-index-test-1

test: tri@-test-1
    clear
    10 20 30 ' 1+ tri@ get-datastack { 11 21 31 } sequence= assert-true
    clear
    1 2 3 [ dup ] tri@ get-datastack { 1 1 2 2 3 3 } sequence= assert-true
    clear
;

tri@-test-1

test: array-test-1
    10 42 make-array/2
    [ dup array? assert-eq ] keep
    [ length 10 assert= ] keep
    10 [ over nth 42 assert-eq ] each-integer
    drop
;

array-test-1

test: array-test-2
    10 make-array/1 :> a
    10 [ [ number>string ] keep a array-set-nth ] each-integer
    a [ number>string assert= ] each-index
    [ -1 a array-nth ] assert-must-fail
    [ 10 a array-nth ] assert-must-fail
    [ "test" a array-nth ] assert-must-fail
;

array-test-2

test: array-test-3
    { "one" "two" "three" } array-first "one" assert=
    { "one" "two" } array-first "one" assert=
    { 42 } array-first 42 assert=
    [ { } array-first ] assert-must-fail ;

array-test-3

test: 1array-test-1
    clear
    71 1array get-datastack { { 71 } } sequence= assert-true
    clear
    "test" 1array [ dup array? assert-eq ] [ array-first "test" assert= ] bi
;

1array-test-1

test: 2array-test-1
    clear
    "test1" "test2" 2array get-datastack { { "test1" "test2" } } sequence= assert-true
    clear
    "test1" "test2" 2array [ dup array? assert-eq ] [ array-first "test1" assert= ] bi
;

2array-test-1

test: 3array-test-1
    clear
    1 2 3 3array get-datastack { { 1 2 3 } } sequence= assert-true
    clear
    "ready" "steady" "go!" 3array
    [ dup array? assert-eq ] [ array-first "ready" assert= ] bi
;

3array-test-1

test: 4array-test-1
    clear
    1 2 3 4 4array get-datastack { { 1 2 3 4 } } sequence= assert-true
    clear
    "fee" "fie" "fo" "fum" 4array
    [ dup array? assert-eq ] [ array-first "fee" assert= ] bi
;

4array-test-1

test: array-?last-test-1
    { 3 } [ { 1 2 3 } array-?last ] unit-test
    { "test" } [ "test" 1array array-?last ] unit-test
    { f } [ { } array-?last ] unit-test
;

array-?last-test-1

test: vector-insert-nth-test
    4 <vector> :> v
    { } [
        v vector-capacity 4 assert-eq
        0 v push
        1 v push
        2 v push
        3 v push

        v vector-capacity 4 assert-eq
        v vector-length 4 assert-eq
        v { 0 1 2 3 } sequence= assert-true

        17 0 v vector-insert-nth

        v vector-capacity 4 > assert-true
        v vector-length 5 assert-eq
        v { 17 0 1 2 3 } sequence= assert-true

        43 0 v vector-insert-nth

        v vector-capacity 5 > assert-true
        v vector-length 6 assert-eq
        v { 43 17 0 1 2 3 } sequence= assert-true

        // REVIEW insertion works at the end of the vector
        v vector-length 6 assert-eq
        713 6 v vector-insert-nth
        v vector-capacity 6 > assert-true
        v vector-length 7 assert-eq
        v { 43 17 0 1 2 3 713 } sequence= assert-true
    ] unit-test ;

vector-insert-nth-test

test: vector-remove-nth!-test-1
    3 vector{ 0 1 2 3 4 5 } [ vector-remove-nth! ] keep
    [ length 5 assert-eq ] keep
    vector{ 0 1 2 4 5 } assert=

    [ 17 vector{ 0 1 2 3 4 5 } vector-remove-nth! ] assert-must-fail
;

vector-remove-nth!-test-1

test: vector-test-2
    1 make-vector [ vector? assert ] keep
    100 [ dup pick vector-set-nth ] each-integer
    [ [ assert-eq ] vector-each-index ] keep
    clear

    1 make-vector
    "test" [ 100 pick vector-set-nth ] keep
    100 pick vector-nth assert-eq

    // verify that new cells are initialized to f
    100 [ over vector-nth assert-false ] each-integer
    clear

    1 make-vector :> v
    42 9 v set-nth
    87 v push
    v vector{ nil nil nil nil nil nil nil nil nil 42 87 } sequence= assert-true

    // FIXME this fails Nov 25 2016 9:42 AM
    // 14 19 v set-nth
    // v vector{ f f f f f f f f f 42 87 f f f f f f f f 14 } sequence= assert-true
;

vector-test-2

test: vector-test-3
    1 make-vector [ vector? assert ] keep
    10 [ over vector-push ] each-integer
    10 [ dup pick vector-nth assert-eq ] each-integer
    [ [ assert-eq ] each-index ] keep
    10 [ 9 swap - over vector-pop assert-eq ] each-integer
    vector-length 0? assert-true ;

vector-test-3

test: vector-pop-test-1
    vector{ 1 2 3 } :> v
    { 3 } [ v vector-pop ] unit-test
    v vector-length 2 assert-eq
    v vector{ 1 2 } assert=
    { 2 } [ v vector-pop ] unit-test
    v vector-length 1 assert-eq
    v vector{ 1 } assert=
    { 1 } [ v vector-pop ] unit-test
    v vector-length zero? assert
    v vector{ } assert=
    [ v vector-pop ] assert-must-fail
    v vector-length zero? assert
    v vector{ } assert= ;

vector-pop-test-1

test: vector-pop*-test-1
    vector{ 1 2 3 } :> v
    { } [ v vector-pop* ] unit-test
    v vector-length 2 assert-eq
    v vector{ 1 2 } assert=
    { } [ v vector-pop* ] unit-test
    v vector-length 1 assert-eq
    v vector{ 1 } assert=
    { } [ v vector-pop* ] unit-test
    v vector-length zero? assert
    v vector{ } assert=
    [ v vector-pop* ] assert-must-fail
    v vector-length zero? assert
    v vector{ } assert= ;

vector-pop*-test-1

test: vector-test-5
    // vector-last
    { 3 } [ vector{ 1 2 3 } vector-last ] unit-test
    { "test" } [ vector{ "test" } vector-last ] unit-test
    [ vector{ } vector-last ] assert-must-fail

    // vector-set-last
    { vector{ 1 2 42 } } [ 42 vector{ 1 2 3 } tuck vector-set-last ] unit-test
    [ 42 vector{ } vector-set-last ] assert-must-fail

    // vector-?last
    { 3 } [ vector{ 1 2 3 } vector-?last ] unit-test
    { "test" } [ vector{ "test" } vector-?last ] unit-test
    { f } [ vector{ } vector-?last ] unit-test
;

vector-test-5

test: vector-nth-test-1
    vector{ 0 1 2 3 } :> v
    0 v vector-nth 0 assert=
    1 v vector-nth 1 assert=
    2 v vector-nth 2 assert=
    3 v vector-nth 3 assert=

    [ 4 v vector-nth ] assert-must-fail
    [ most-positive-fixnum v vector-nth ] assert-must-fail

    [ -1 v vector-nth ] assert-must-fail
    [ most-negative-fixnum v vector-nth ] assert-must-fail
    [ "test" v vector-nth ] assert-must-fail
;

vector-nth-test-1

test: vector-?nth-test-1
    vector{ 0 1 2 3 } :> v
    0 v vector-?nth 0 assert=
    1 v vector-?nth 1 assert=
    2 v vector-?nth 2 assert=
    3 v vector-?nth 3 assert=

    4 v vector-?nth assert-false
    most-positive-fixnum v vector-?nth assert-false

    [ -1 v vector-?nth ] assert-must-fail
    [ most-negative-fixnum v vector-?nth ] assert-must-fail
    [ "test" v vector-?nth ] assert-must-fail
;

vector-?nth-test-1

test: vector->array-test-1
    vector{ 1 2 3 } vector->array
    [ dup array? assert-eq ] keep
    { 1 2 3 } assert=
;

vector->array-test-1

: %local-test-1                         // -> 42
    42 :> foo
    foo
;

test: local-test-1
    %local-test-1 42 assert-eq
;

local-test-1

: %local-test-2
    42 :> foo
    17 :> bar
    foo bar -
;

test: local-test-2
    %local-test-2 25 assert-eq
;

local-test-2

test: local-test-3
    42 :> x
    87 :> y
    x 42 assert-eq
    y 87 assert-eq
;

local-test-3

test: local-test-4
    42 :> x!
    87 :> y!
    x 42 assert-eq
    y 87 assert-eq
    17 x!
    31 y!
    x 17 assert-eq
    y 31 assert-eq
;

local-test-4

test: local-test-5
    local x
    x nil? assert
    59 x!
    x 59 assert-eq
;

local-test-5

test: symbol?-test
    // static symbol
    ' dup symbol? assert
    ' dup symbol? ' dup assert-eq

    // heap symbol
    ' symbol?-test symbol? assert
    ' symbol?-test symbol? ' symbol?-test assert-eq

    42 symbol? assert-false
    -3 symbol? assert-false
    "test" symbol? assert-false ;

symbol?-test

test: decimal>unsigned-test-1
    "" decimal>unsigned assert-false
    "test" decimal>unsigned assert-false
    "3.14159" decimal>unsigned assert-false
    "3." decimal>unsigned assert-false
    ".3" decimal>unsigned assert-false
    "-1" decimal>unsigned assert-false

    "0" decimal>unsigned 0 assert-eq

    // avoid confusion with t and f
    "6" decimal>unsigned 6 assert-eq
    "14" decimal>unsigned 14 assert-eq

    "4611686018427387903"  decimal>unsigned most-positive-fixnum assert-eq
    "9223372036854775807"  decimal>unsigned dup int64? over assert-eq most-positive-int64 assert=
    "18446744073709551615" decimal>unsigned dup uint64? over assert-eq max-uint64 assert=

    64 [ 2 swap lshift dup number>string decimal>unsigned assert= ] each-integer

    // overflow
    "18446744073709551616" decimal>unsigned assert-false
    "18446744073709551617" decimal>unsigned assert-false
    "18446744073709551618" decimal>unsigned assert-false
    "18446744073709551619" decimal>unsigned assert-false
    "18446744073709551620" decimal>unsigned assert-false
    "18446744073709551621" decimal>unsigned assert-false
    "18446744073709551622" decimal>unsigned assert-false
    "18446744073709551623" decimal>unsigned assert-false
    "18446744073709551624" decimal>unsigned assert-false
    "18446744073709551625" decimal>unsigned assert-false
    "18446744073709551626" decimal>unsigned assert-false

    "100000000000000000000" decimal>unsigned assert-false
;

decimal>unsigned-test-1


test: decimal>signed-test-1
    // too short
    "" decimal>signed assert-false
    "-" decimal>signed assert-false

    // first char must be '-'
    "0" decimal>signed assert-false
    "1" decimal>signed assert-false

    // all chars after '-' must be decimal digits
    "-test" decimal>signed assert-false
    "-3.14159" decimal>signed assert-false
    "-3." decimal>signed assert-false
    "-.3" decimal>signed assert-false

    "-1" decimal>signed -1 assert-eq
    "-2" decimal>signed -2 assert-eq
    "-3" decimal>signed -3 assert-eq

    // avoid confusion with t and f
    "-6" decimal>signed -6 assert-eq
    "-14" decimal>signed -14 assert-eq

    "-4611686018427387900"  decimal>signed most-negative-fixnum 4 + assert-eq
    "-4611686018427387901"  decimal>signed most-negative-fixnum 3 + assert-eq
    "-4611686018427387902"  decimal>signed most-negative-fixnum 2 + assert-eq
    "-4611686018427387903"  decimal>signed most-negative-fixnum 1 + assert-eq
    "-4611686018427387904"  decimal>signed most-negative-fixnum assert-eq
    "-4611686018427387905"  decimal>signed dup int64? over assert-eq most-negative-fixnum 1 - assert=
    "-4611686018427387906"  decimal>signed dup int64? over assert-eq most-negative-fixnum 2 - assert=
    "-4611686018427387907"  decimal>signed dup int64? over assert-eq most-negative-fixnum 3 - assert=
    "-4611686018427387908"  decimal>signed dup int64? over assert-eq most-negative-fixnum 4 - assert=
    "-4611686018427387909"  decimal>signed dup int64? over assert-eq most-negative-fixnum 5 - assert=
    "-4611686018427387910"  decimal>signed dup int64? over assert-eq most-negative-fixnum 6 - assert=

    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 8 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 7 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 6 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 5 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 4 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 3 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 2 - assert=
    "-9223372036854775800"  decimal>signed dup int64? over assert-eq most-negative-int64 1 - assert=
    "-9223372036854775808"  decimal>signed dup int64? over assert-eq most-negative-int64 assert=
    "-9223372036854775809"  decimal>signed assert-false
    "-9223372036854775810"  decimal>signed assert-false
    "-9223372036854775811"  decimal>signed assert-false

    "-100000000000000000000" decimal>signed assert-false
;

decimal>signed-test-1

test: string>number-test-1
    "." string>number assert-false
    "-" string>number assert-false
;

string>number-test-1

test: string>number-test-2
    "0b11"    string>number   3 assert-eq
    "0b1100"  string>number  12 assert-eq

    "-0b11"   string>number  -3 assert-eq
    "-0b1100" string>number -12 assert-eq
;

string>number-test-2

test: string>number-test-3
    17   50   expt 3.3300140732146817e+61 assert=
    17.0 50   expt 3.3300140732146817e+61 assert=
    17   50.0 expt 3.3300140732146817e+61 assert=
    17.0 50.0 expt 3.3300140732146817e+61 assert=
;

string>number-test-3

test: string>number-test-4
     "0x7fffffffffffffff" string>number most-positive-int64 assert=
    "-0x8000000000000000" string>number most-negative-int64 assert=
;

string>number-test-4

test: string>number-test-5
    most-positive-fixnum number>string string>number
    dup fixnum? assert
    most-positive-fixnum assert-eq

    most-negative-fixnum number>string string>number
    dup fixnum? assert
    most-negative-fixnum assert-eq

    most-positive-fixnum 1 + number>string string>number
    dup int64? over assert-eq
    most-positive-fixnum 1 + assert=

    most-negative-fixnum 1 - number>string string>number
    dup int64? over assert-eq
    most-negative-fixnum 1 - assert= ;

string>number-test-5

test: '-test
    [ ' dup ] call symbol? assert
    3 [ dup ] call get-datastack { 3 3 } sequence= assert-true
    clear ;

'-test

test: hashcode-test-1
    "test"
    [ string-hashcode fixnum? assert ] keep
    [ hashcode dup fixnum? assert ] keep
    string-hashcode assert-eq ;

hashcode-test-1

test: hashcode-test-2
    ' dup
    [ symbol-name "dup" string=? assert-true ] keep
    [ symbol-vocab-name "feline" string=? assert-true ] keep
    [ symbol-hashcode ] keep
    [ symbol-name hashcode ] keep
    symbol-vocab-name hashcode hash-combine assert-eq
;

hashcode-test-2

test: hashtable-test-1
    16 <hashtable> :> ht
    42 "parker" ht set-at
    ht hashtable-count 1 assert=
    87 "penelope" ht set-at
    ht hashtable-count 2 assert=
    "parker" ht at* assert-true
    42 assert=
    "penelope" ht at* assert-true
    87 assert=
    "cody may" ht at* assert-false
    assert-false
;

hashtable-test-1

test: hashtable-test-2
    72 <hashtable> hashtable-capacity 128 assert=
;

hashtable-test-2

test: hashtable-test-3
    16 <hashtable> :> ht
    1000 [ dup number>string ht set-at ] each-integer
    1000 [ dup number>string ht at assert= ] each-integer
    "charlie" ht at* assert-false assert-false
;

hashtable-test-3

global ht

100 constant n1         // total number of entries
40  constant n2         // number of entries to delete

test: hashtable-test-4
    1 <hashtable> ht!
    n1 [ dup number>string ht set-at ] each-integer
    n1 [ dup number>string ht at assert= ] each-integer

    // delete first n2 entries
    n2 [ number>string ht delete-at ] each-integer

    // verify remaining entries are findable
    n1 n2 - [ n2 + dup number>string ht at assert= ] each-integer

    // delete first n2 entries again (should make no difference)
    n2 [ number>string ht delete-at ] each-integer

    // verify remaining entries are findable
    n1 n2 - [ n2 + dup number>string ht at assert= ] each-integer

    // add deleted entries back
    n2 [ dup number>string ht set-at ] each-integer

    // verify all entries are findable
    n1 [ dup number>string ht at assert= ] each-integer

    ht hashtable-keys length n1 assert-eq
    ht hashtable-keys [ dup string? assert-eq ] each
    ht hashtable-values length n1 assert-eq
    ht hashtable-values [ fixnum? assert ] each

    nil ht! ;

hashtable-test-4

test: hashtable-test-5
    16 <hashtable> :> ht
    // fixnum keys
    1000 [ dup ht set-at ] each-integer
    1000 [ dup ht at assert= ] each-integer
    "charlie" ht at* assert-false assert-false
;

hashtable-test-5

test: length-test-1
    "test" length 4 assert-eq
    "testing" string>sbuf length 7 assert-eq
    { 1 2 3 } length 3 assert-eq
    vector{ 1 2 3 "test" } length 4 assert-eq
    [ dup + ] length 2 assert-eq
    3 [ + ] curry length 2 assert-eq
    3 ' + curry length 2 assert-eq
;

length-test-1

test: find-test-1
    vector{ 1 2 3 4 5 6 } [ 3 = ] find
    get-datastack vector{ 2 3 } sequence= assert-true
    clear
    vector{ 1 2 3 4 5 6 } [ 17 = ] find
    get-datastack f f 2array sequence= assert-true
    clear
    4 vector{ 1 2 3 4 5 6 } [ dupd = ] find
    get-datastack vector{ 4 3 4 } sequence= assert-true
    clear
;

find-test-1

test: find-from-test-1
    4 "this is a test" [ 'e' = ] find-from
    get-datastack { 11 'e' } sequence= assert-true
    clear
    0 "this is a test" [ 's' = ] find-from
    get-datastack { 3 's' } sequence= assert-true
    clear
    99 "this is a test" [ 'e' = ] find-from
    get-datastack { f f } sequence= assert-true
    clear
    -1 "this is a test" [ 'e' = ] find-from
    get-datastack { f f } sequence= assert-true
    clear
;

find-from-test-1

test: find-last-from-test-1
    13 "this is a test" [ 'e' = ] find-last-from
    get-datastack { 11 'e' } sequence= assert-true
    clear
    99 "this is a test" [ 'e' = ] find-last-from
    get-datastack { f f } sequence= assert-true
    clear
    -99 "this is a test" [ 'e' = ] find-last-from
    get-datastack { f f } sequence= assert-true
    clear
    4 vector{ 1 2 3 4 5 3 } [ 3 = ] find-last-from
    get-datastack { 2 3 } sequence= assert-true
    clear
    3 4 vector{ 1 2 3 4 5 3 } [ dupd = ] find-last-from
    get-datastack { 3 2 3 } sequence= assert-true
    clear
;

find-last-from-test-1

test: map-find-test-1
    clear
    vector{ 1 2 3 4 5 6 } [ 3 = ] map-find get-datastack { t 3 } sequence= assert-true
    clear
    vector{ 1 2 3 4 5 6 } [ 17 = ] map-find get-datastack { f f } sequence= assert-true
    clear
    4 vector{ 1 2 3 4 5 6 } [ dupd = ] map-find get-datastack { 4 t 4 } sequence= assert-true
    clear
;

map-find-test-1

test: lookup-symbol-test-1
    "dup" "feline" lookup-symbol ' dup assert-eq
    "xxx" "feline" lookup-symbol assert-false
    "dup" "xxx" lookup-symbol assert-false
;

lookup-symbol-test-1

test: immediate?-test-1
    ' symbol: immediate? assert-true
    ' dup immediate? assert-false
    42 immediate? assert-false
    f immediate? assert-false
    ' f immediate? assert-true
;

immediate?-test-1

test: sequence=-test-1
    { "this is a test" } { "this is a test" } sequence= assert-true
;

sequence=-test-1

test: symbol-props-test-1
    { f } [ "foo" ' dup symbol-prop ] unit-test
    "this is a test" "foo" ' dup symbol-set-prop
    { "this is a test" } [ "foo" ' dup symbol-prop ] unit-test

    // clean up
    f "foo" ' dup symbol-set-prop
;

symbol-props-test-1

test: symbol-props-gc-test-1
    "this is a test" "foo" ' dup symbol-set-prop
    "foo" ' dup symbol-prop get-datastack { "this is a test" } sequence= assert-true
    clear

    gc

    "foo" ' dup symbol-prop get-datastack { "this is a test" } sequence= assert-true
    clear

    // clean up
    f "foo" ' dup symbol-set-prop
;

symbol-props-gc-test-1

test: times-test-1
    0 10 [ 1 + ] times 10 assert-eq
;

times-test-1

test: filter-test-1
    vector{ 1 2 3 4 } [ 3 < ] filter vector{ 1 2 } assert=
    { 1 2 3 4 } [ 3 < ] filter { 1 2 } assert=

    3 vector{ 1 2 3 4 } [ over = ] filter nip vector{ 3 } assert=
    3 { 1 2 3 4 } [ over = ] filter nip { 3 } assert=
;

filter-test-1

test: in-bounds?-test-1
    { 1 2 3 }
    0 over in-bounds? assert-true
    1 over in-bounds? assert-true
    2 over in-bounds? assert-true
    3 over in-bounds? assert-false
    -1 swap in-bounds? assert-false
;

in-bounds?-test-1

test: empty?-test-1
    { } empty? assert-true
    { 1 } empty? assert-false
    vector{ } empty? assert-true
    vector{ 1 } empty? assert-false

    f empty? assert-true
    [ 42 empty? ] assert-must-fail
;

empty?-test-1

test: blank?-test-1
    'a' blank? assert-false
    { 9 10 13 32 } [ code-char blank? assert ] each
    "BeTheBestRabbitYouCanBe!" [ blank? assert-false ] each
;

blank?-test-1

test: until-test-1
    clear
    1 [ dup 1 = ] [ 1 + ] until get-datastack { 1 } sequence= assert-true
    clear
    1 [ dup 4 = ] [ 1 + ] until get-datastack { 4 } sequence= assert-true
    clear
    [ t ] [ 42 ] until get-datastack empty? assert-true
    clear
;

until-test-1

test: while-test
    { 1 2 3 4 43 } [ 1 2 3 4 42 [ dup 42 = ] [ 1 + ] while ] unit-test
    { 1 2 3 4 42 } [ 1 2 3 4 42 [ dup 7 = ] [ 1 + ] while ] unit-test
    { 1 2 3 4 } [ 1 2 3 4 [ nil ] [ 42 ] while ] unit-test ;

while-test

test: verify-type-test-1
    42 type-of dup verify-type assert-eq
    "test" type-of dup verify-type assert-eq
    ' string symbol-value dup verify-type assert-eq

    [ 42 verify-type ] assert-must-fail
    [ ' string verify-type ] assert-must-fail
;

verify-type-test-1

tuple: foo a b c ;

: %tuple-layout-test-1
    foo dup verify-type assert-eq
    foo dup type? assert-eq
    foo type-symbol dup symbol? assert ' foo assert-eq
    foo type-layout dup array? assert-eq
    foo type-layout length 3 assert-eq
    foo type-layout [ slot? assert-true ] each
    foo type-layout [ slot-index ] map { 1 2 3 } equal? assert-true
    foo type-layout [ slot-name ] map { "a" "b" "c" } equal? assert-true ;

test: tuple-layout-test-1
    %tuple-layout-test-1
    gc
    %tuple-layout-test-1 ;

tuple-layout-test-1

test: tuple-instance?-test-1
    t tuple-instance? assert-false
    f tuple-instance? assert-false
    42 tuple-instance? assert-false
    2000000 tuple-instance? assert-false
    "test" tuple-instance? assert-false
    ' dup tuple-instance? assert-false
    ' dup symbol-name tuple-instance? assert-false

    foo tuple-instance? assert-false
    foo make-instance tuple-instance? assert-true
;

tuple-instance?-test-1

test: tuple-instance-test-1
    foo make-instance

    [ foo? assert-true ] keep
    [ tuple-instance? assert-true ] keep
    [ tuple-size 3 assert= ] keep
    [ object-typecode foo type-typecode assert-eq ] keep

    drop
;

tuple-instance-test-1

test: vocab?-test-1
    42 vocab? assert-false
    "feline" vocab? assert-false
    "feline" lookup-vocab assert-true dup vocab? assert-eq
;

vocab?-test-1

test: lookup-vocab-test-1
    "feline" lookup-vocab assert-true vocab? dup assert-eq
    "feline" lookup-vocab assert-true lookup-vocab assert-true vocab? dup assert-eq
    "feline" lookup-vocab assert-true dup lookup-vocab assert-true assert-eq
    current-vocab lookup-vocab assert-true vocab? dup assert-eq
    "not a vocab" lookup-vocab assert-false vocab? assert-false
;

lookup-vocab-test-1

test: vocab-empty?-test-1
    feline-vocab vocab-empty? assert-false
    "asdf" dup delete-vocab ensure-vocab vocab-empty? assert-true
;

vocab-empty?-test-1

test: set-current-vocab-test-1
    [ 42 set-current-vocab ] assert-must-fail
;

set-current-vocab-test-1

test: unless-test-1
    { 42 } [ nil [ 42 ] unless ] unit-test
    { } [ t [ 42 ] unless ] unit-test
    { } [ "test" [ 42 ] unless ] unit-test

    { 1 2 } [ 1 2 3 [ 42 ] unless ] unit-test
    { 1 2 42 } [ 1 2 nil [ 42 ] unless ] unit-test
;

unless-test-1

test: unless*-test-1
    { 42 } [ nil [ 42 ] unless* ] unit-test
    { t } [ t [ 42 ] unless* ] unit-test
    { "test" } [ "test" [ 42 ] unless* ] unit-test

    { 17 42 } [ 17 nil [ 42 ] unless* ] unit-test
;

unless*-test-1

global zork

test: global-test-1
    42 zork! zork 42 assert-eq
;

global-test-1

// : global-test-2
//     << last-word symbol-name >> ?nl write-string
//     87 ' zork set-global
//     ' zork get-global 87 eq? assert-true

//     [
//         "test" dup zork! zork eq? assert-true
//         ' zork get-global 87 eq? assert-true
//         19 ' zork set-global
//         zork "test" assert=
//         ' zork get-global 19 eq? assert-true
//     ] with-scope

//     ' zork get-global 19 eq? assert-true
// ;

// global-test-2

// : global-test-3
//     << last-word symbol-name >> ?nl write-string
//     f zork!
//     zork assert-false
//     [ [ 71 zork! zork ] with-scope ] [ ] recover 71 eq? assert-true
//     [ [ 71 zork! "error" error ] with-scope ] [ drop zork ] recover assert-false
// ;

// global-test-3

test: index-test-1
    3 { 1 2 3 4 } index 2 assert-eq
    99 { 1 2 3 4 } index assert-false
    's' "this is a test" index 3 assert-eq
    'a' "this is a test" index 8 assert-eq
    "bar" { "foo" "bar" "baz" } index 1 assert-eq
;

index-test-1

test: index-from-test-1
    0 0 { 0 1 2 3 4 5 } index-from 0 assert-eq
    3 3 { 0 1 2 3 4 5 } index-from 3 assert-eq
    3 4 { 0 1 2 3 4 5 } index-from assert-false
    0 4 { 0 1 2 3 4 5 } index-from assert-false
    5 5 { 0 1 2 3 4 5 } index-from 5 assert-eq

    99 0 { 0 1 2 3 4 } index-from assert-false
    0 99 { 0 1 2 3 4 } index-from assert-false
;

index-from-test-1

test: member?-test-1
    17 { 1 2 3 } member? assert-false
    1  { 1 2 3 } member? assert-true
    f  { 1 2 3 } member? assert-false
    f  { 1 f 3 } member? assert-true
;

member?-test-1

test: member?-test-2
    "bar" { "foo" "bar" "baz" } member? assert-true
    "bag" { "foo" "bar" "baz" } member? assert-false
    4 { 1 2 3 4 } member? assert-true
    1 { 1 2 3 4 } member? assert-true
    "test" { 1 2 3 4 } member? assert-false
    0 { 1 2 3 4 } member? assert-false
;

member?-test-2

test: member-eq?-test-1
    { 1 2 3 4 } :> a
    0 a member-eq? assert-false
    1 a member-eq? assert-true
    2 a member-eq? assert-true
    "test" :> s
    s a member-eq? assert-false
    vector{ 1 2 3 4 } :> v
    a [ v member-eq? assert-true ] each
    v [ a member-eq? assert-true ] each
    s v member-eq? assert-false
    s v push
    s v member-eq? assert-true ;

member-eq?-test-1

test: any?-test-1
    { 1 2 3 4 } [ char? ] any? assert-false
    { 1 2 3 4 't' } [ char? ] any? assert-true
    { 't' 1 2 3 4 } [ char? ] any? assert-true ;

any?-test-1

test: string-head-test-1
    "this is a test"
    [ 4 swap string-head "this" assert= ] keep
    [ 0 swap string-head [ string? "" assert= ] [ length 0? assert-true ] bi ] keep
    [ 14 swap string-head "this is a test" assert= ] keep
    drop
;

string-head-test-1

test: string-tail-test-1
    "this is a test"
    [ 10 swap string-tail "test" assert= ] keep
    [ 14 swap string-tail [ string? "" assert= ] [ length 0? assert-true ] bi ] keep
    [ 0 swap string-tail "this is a test" assert= ] keep
    drop
;

string-tail-test-1

test: head-test-1
    "this is a test"
    [ 4 swap head "this" assert= ] keep
    [ 0 swap head [ string? "" assert= ] [ length 0? assert-true ] bi ] keep
    [ 14 swap head "this is a test" assert= ] keep
    drop ;

head-test-1

test: tail-test-1
    "this is a test"
    [ 10 swap tail "test" assert= ] keep
    [ 14 swap tail [ string? "" assert= ] [ length 0? assert-true ] bi ] keep
    [ 0 swap tail "this is a test" assert= ] keep
    drop ;

tail-test-1

test: head?-test-1
    "this" "this is a test" head? assert-true
    "this is a test" "this is a test" head? assert-true

    "this is a test" "this" head? assert-false

    "" "this is a test" head? assert-true
    "" "" head? assert-true ;

head?-test-1

test: tail?-test-1
    "test" "this is a test" tail? assert-true
    "this is a test" "this is a test" tail? assert-true

    "this is a test" "test" tail? assert-false

    "" "this is a test" tail? assert-true
    "" "" tail? assert-true
;

tail?-test-1

test: head*-test-1
    0 "quarter" head* "quarter" assert=
    2 "quarter" head* "quart" assert=
    7 "quarter" head* "" assert=

    [ -1 "quarter" head* ] assert-must-fail
    [ 8 "quarter" head* ] assert-must-fail
;

head*-test-1

test: tail*-test-1
    0 "quarter" tail* "" assert=
    2 "quarter" tail* "er" assert=
    7 "quarter" tail* "quarter" assert=

    [ -1 "quarter" tail* ] assert-must-fail
    [ 8 "quarter" tail* ] assert-must-fail
;

tail*-test-1

test: but-last-test-1
    "gadzooks" but-last "gadzook" assert=
    "g" but-last "" assert=

    [ "" but-last ] assert-must-fail
;

but-last-test-1

magenta constant test-magenta

test: constant-test-1
    test-magenta 5 assert-eq
;

constant-test-1

test: string-skip-whitespace-test-1
    "   this is a test   " :> s
    { 3 }  [  0 s string-skip-whitespace ] unit-test
    { 3 }  [  2 s string-skip-whitespace ] unit-test
    { 3 }  [  3 s string-skip-whitespace ] unit-test
    { 6 }  [  6 s string-skip-whitespace ] unit-test
    { 8 }  [  7 s string-skip-whitespace ] unit-test
    { 16 } [ 16 s string-skip-whitespace ] unit-test
    { f }  [ 17 s string-skip-whitespace ] unit-test
    { f }  [ 18 s string-skip-whitespace ] unit-test
    { f }  [ 19 s string-skip-whitespace ] unit-test
    { f }  [ 20 s string-skip-whitespace ] unit-test
    { f }  [ 99 s string-skip-whitespace ] unit-test ;

string-skip-whitespace-test-1

// multiline string
test: string-skip-whitespace-test-2
    "   this is
a multiline string   " :> s
    { 3 }  [  0 s string-skip-whitespace ] unit-test
    { 3 }  [  2 s string-skip-whitespace ] unit-test
    { 3 }  [  3 s string-skip-whitespace ] unit-test
    { 6 }  [  6 s string-skip-whitespace ] unit-test
    { 8 }  [  7 s string-skip-whitespace ] unit-test
    { 11 } [ 10 s string-skip-whitespace ] unit-test
    { 11 } [ 11 s string-skip-whitespace ] unit-test
    { 13 } [ 12 s string-skip-whitespace ] unit-test ;

string-skip-whitespace-test-2

test: string-skip-to-whitespace-test-1
    "   this is a test   "
    [  0 swap string-skip-to-whitespace  0 assert-eq ] keep
    [  2 swap string-skip-to-whitespace  2 assert-eq ] keep
    [  3 swap string-skip-to-whitespace  7 assert-eq ] keep
    [  6 swap string-skip-to-whitespace  7 assert-eq ] keep
    [  7 swap string-skip-to-whitespace  7 assert-eq ] keep
    [  8 swap string-skip-to-whitespace 10 assert-eq ] keep
    [ 16 swap string-skip-to-whitespace 17 assert-eq ] keep
    [ 17 swap string-skip-to-whitespace 17 assert-eq ] keep
    [ 18 swap string-skip-to-whitespace 18 assert-eq ] keep
    [ 19 swap string-skip-to-whitespace 19 assert-eq ] keep
    [ 20 swap string-skip-to-whitespace  f assert-eq ] keep
    [ 99 swap string-skip-to-whitespace  f assert-eq ] keep
    drop
;

string-skip-to-whitespace-test-1

// multiline string
test: string-skip-to-whitespace-test-2
    "   this is
a multiline string   "
    [  3 swap string-skip-to-whitespace  7 assert-eq ] keep
    [  7 swap string-skip-to-whitespace  7 assert-eq ] keep
    [  8 swap string-skip-to-whitespace 10 assert-eq ] keep
    [ 10 swap string-skip-to-whitespace 10 assert-eq ] keep
    [ 11 swap string-skip-to-whitespace 12 assert-eq ] keep
    drop
;

string-skip-to-whitespace-test-2

test: ?-test-1
    t "yes" "no" ? "yes" assert=
    f "yes" "no" ? "no"  assert=
    0 "yes" "no" ? "yes" assert=
;

?-test-1

test: slice-test-1
    2 5 { 11 12 13 14 15 16 17 18 } <slice>    { 13 14 15 } sequence= assert-true
    2 5 { 11 12 13 14 15 16 17 18 } <slice> gc { 13 14 15 } sequence= assert-true

    2 5 { 11 12 13 14 15 16 17 18 } <slice> dup slice? assert-true

    [ slice-length      3 assert-eq ] keep
    [ 0 swap slice-nth 13 assert-eq ] keep
    [ 1 swap slice-nth 14 assert-eq ] keep
    [ 2 swap slice-nth 15 assert-eq ] keep

    [ 0 swap slice-nth-unsafe 13 assert-eq ] keep
    [ 1 swap slice-nth-unsafe 14 assert-eq ] keep
    [ 2 swap slice-nth-unsafe 15 assert-eq ] keep

    [ length      3 assert-eq ] keep
    [ 0 swap nth 13 assert-eq ] keep
    [ 1 swap nth 14 assert-eq ] keep
    [ 2 swap nth 15 assert-eq ] keep

    drop
;

slice-test-1

test: index?-test-1
    0 dup index? assert-eq
    1 dup index? assert-eq
    most-positive-fixnum dup index? assert-eq
    -1 index? assert-false
    most-negative-fixnum index? assert-false
    "test" index? assert-false
    { } index? assert-false ;

index?-test-1

test: curry-nth-test-1
    3 [ + ] curry
    0 over nth 3 assert-eq
    1 over nth ' + assert-eq
    0 over nth 3 assert-eq
    1 over nth ' + assert-eq
    clear
;

curry-nth-test-1

test: curry-nth-unsafe-test-1
    3 [ + ] curry
    0 over nth-unsafe 3 assert-eq
    1 over nth-unsafe ' + assert-eq
    0 over nth-unsafe 3 assert-eq
    1 over nth-unsafe ' + assert-eq
    clear
;

curry-nth-unsafe-test-1

test: ?nth-test-1
    4 { 0 1 2 3 } [ ?nth ] curry each-integer
    get-datastack { 0 1 2 3 } sequence= assert-true
    clear

    { 0 1 2 3 }
    -1 over ?nth assert-false
    4 over ?nth assert-false
    42  over ?nth assert-false
    drop
;

?nth-test-1

test: ?nth-test-2
    4 vector{ 0 1 2 3 } [ ?nth ] curry each-integer
    get-datastack { 0 1 2 3 } sequence= assert-true
    clear

    vector{ 0 1 2 3 }
    -1 over ?nth assert-false
    4 over ?nth assert-false
    42  over ?nth assert-false
    drop
;

?nth-test-2

test: and-test
    { nil } [ true nil and ] unit-test
    { nil } [ nil true and ] unit-test
    { true } [ 0 true and ] unit-test
    { 0 } [ true 0 and ] unit-test

    { nil } [ nil 71 and ] unit-test
    { 71 } [ true 71 and ] unit-test
    { 42 } [ "test" 42 and ] unit-test ;

and-test

test: or-test
    { true } [ true nil or ] unit-test
    { true } [ nil true or ] unit-test
    { 0 } [ 0 true or ] unit-test
    { true } [ true 0 or ] unit-test

    { 71 } [ nil 71 or ] unit-test
    { true } [ true 71 or ] unit-test
    { -1 } [ -1 1 or ] unit-test
    { "test" } [ "test" 42 or ] unit-test ;

or-test

test: sbuf-insert-nth!-test-1
    "oat" string>sbuf :> sb
    'b' 0 sb sbuf-insert-nth!
    sb "boat" sequence= assert-true
    's' 3 sb sbuf-insert-nth!
    sb "boast" sequence= assert-true
;

sbuf-insert-nth!-test-1

test: sbuf-?last-test-1
    "testing" string>sbuf sbuf-?last 'g' assert-eq
    16 <sbuf> sbuf-?last assert-false
;

sbuf-?last-test-1

test: sbuf-reverse!-test-1
    "12345678"  string>sbuf sbuf-reverse!  "87654321" sequence= assert-true
    "123456789" string>sbuf sbuf-reverse! "987654321" sequence= assert-true
    "1" string>sbuf sbuf-reverse! "1" sequence= assert-true
    "" string>sbuf sbuf-reverse! "" sequence= assert-true
;

sbuf-reverse!-test-1

test: sbuf-shorten-test-1
    "12345678" string>sbuf :> sb
    sb sbuf-length 8 assert-eq
    sb sbuf-validate
    16 sb sbuf-shorten
    sb sbuf-length 8 assert-eq
    sb sbuf-validate
    sb "12345678" sequence= assert-true
    4 sb sbuf-shorten
    sb sbuf-length 4 assert-eq
    sb sbuf-validate
    sb "1234" sequence= assert-true

    most-positive-fixnum sb sbuf-shorten
    sb sbuf-length 4 assert-eq
    sb sbuf-validate
    sb "1234" sequence= assert-true

    [ -1 sb sbuf-shorten ] assert-must-fail
    [ most-negative-fixnum sb sbuf-shorten ] assert-must-fail
;

sbuf-shorten-test-1

test: base>integer-test-1
    "0" 10 base>integer 0 assert-eq
    "42" 10 base>integer 42 assert-eq
    "-42" 10 base>integer -42 assert-eq

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//          "1152921504606846975" 10 base>integer most-positive-fixnum assert-eq
//         "-1152921504606846976" 10 base>integer most-negative-fixnum assert-eq
//
//          "2305843009213693950" 10 base>integer most-positive-fixnum dup + assert=
//      ] when
;

base>integer-test-1

test: decimal>number-test-1
    "0" decimal>number 0 assert-eq
    "-0" decimal>number 0 assert-eq
    "1" decimal>number 1 assert-eq
    "-1" decimal>number -1 assert-eq
    "0.0" decimal>number 0.0 assert=
    "-0.0" decimal>number -0.0 assert=
    most-positive-fixnum fixnum>string decimal>number most-positive-fixnum assert-eq
    most-negative-fixnum fixnum>string decimal>number most-negative-fixnum assert-eq
;

decimal>number-test-1

test: negate-test-1
    0 negate 0 assert-eq
    42 negate -42 assert-eq

    most-positive-fixnum 4611686018427387903 assert-eq
    most-positive-fixnum negate -4611686018427387903 assert-eq
    most-positive-fixnum 1 + negate dup fixnum? assert -4611686018427387904 assert-eq
    most-positive-fixnum 1- negate dup fixnum? assert -4611686018427387902 assert-eq

    most-negative-fixnum -4611686018427387904 assert-eq
    most-negative-fixnum negate dup int64? over assert-eq 4611686018427387904 assert=
    most-negative-fixnum 1+ negate dup fixnum? assert 4611686018427387903 assert-eq
    most-negative-fixnum 1 - negate dup int64? over assert-eq 4611686018427387905 assert=

    most-positive-int64 9223372036854775807 assert=
    most-positive-int64 negate dup int64? over assert-eq -9223372036854775807 assert=

    most-negative-int64 -9223372036854775808 assert=
    most-negative-int64 negate dup uint64? over assert-eq dup 9223372036854775808 assert=
    negate dup int64? over assert-eq most-negative-int64 assert=
    most-negative-int64 1 + negate dup int64? over assert-eq 9223372036854775807 assert=
;

negate-test-1

test: string-substring-test-1
    "this is a test" :> s

     0  4 s string-substring "this"  assert=
    10 14 s string-substring "test"  assert=
     5 10 s string-substring "is a " assert=
    13 14 s string-substring "t"     assert=

     0  0 s string-substring "" assert=
     4  4 s string-substring "" assert=
    14 14 s string-substring "" assert=

     0 14 s string-substring "this is a test" assert=

    [  0 15 s string-substring ] assert-must-fail
    [  0 -4 s string-substring ] assert-must-fail
    [ -2 14 s string-substring ] assert-must-fail
    [  4  3 s string-substring ] assert-must-fail
;

string-substring-test-1

test: sbuf-substring-test-1
    "this is a test" string>sbuf
     0  4 pick sbuf-substring "this"  assert=
    10 14 pick sbuf-substring "test"  assert=
     5 10 pick sbuf-substring "is a " assert=
    13 14 pick sbuf-substring "t"     assert=

    0 0 pick sbuf-substring "" assert=
    4 4 pick sbuf-substring "" assert=


    0 14 rot sbuf-substring "this is a test" assert=
;

sbuf-substring-test-1

// generic
test: substring-test-1
    "this is a test"
     0  4 pick substring "this"  assert=
    10 14 pick substring "test"  assert=
     5 10 pick substring "is a " assert=
    13 14 pick substring "t"     assert=

    0 0 pick substring "" assert=
    4 4 pick substring "" assert=

    0 14 pick substring "this is a test" assert=

    string>sbuf
     0  4 pick substring "this"  assert=
    10 14 pick substring "test"  assert=
     5 10 pick substring "is a " assert=
    13 14 pick substring "t"     assert=

    0 0 pick substring "" assert=
    4 4 pick substring "" assert=

    0 14 rot substring "this is a test" assert=
;

substring-test-1

test: string-has-prefix?-test-1
    "foo" "foobar" string-has-prefix? assert-true
    "foobar" "foo" string-has-prefix? assert-false
    "foo" "foo" string-has-prefix? assert-true
    "0x" "0" string-has-prefix? assert-false
    "0x" "0x0" string-has-prefix? assert-true

    "" "foo" string-has-prefix? assert-true
    "foo" "" string-has-prefix? assert-false
    "" "" string-has-prefix? assert-true

    [ 42 "test" string-has-prefix? ] assert-must-fail
    [ "test" 42 string-has-prefix? ] assert-must-fail
;

string-has-prefix?-test-1

test: string-has-suffix?-test-1
    "bar" "foobar" string-has-suffix? assert-true
    "foobar" "bar" string-has-suffix? assert-false
    "foo" "foo" string-has-suffix? assert-true

    "" "foo" string-has-suffix? assert-true
    "foo" "" string-has-suffix? assert-false
    "" "" string-has-suffix? assert-true

    [ 42 "test" string-has-suffix? ] assert-must-fail
    [ "test" 42 string-has-suffix? ] assert-must-fail
;

string-has-suffix?-test-1

test: substring-start-test
    { 10 } [ "test" "this is a test" substring-start ] unit-test
    { 0 } [ "test" "testing" substring-start ] unit-test
    { 0 } [ "test" "test" substring-start ] unit-test

    { nil } [ "test" "no match" substring-start ] unit-test
    { nil } [ "this string is much too long" "test" substring-start ] unit-test
    { nil } [ "test1" "test" substring-start ] unit-test
;

substring-start-test

: %case-test-1                          // x -> y
    {
        { 1 [ "one" ] }
        { 2 [ "two" ] }
        { 3 [ "three" ] }
        { 4 [ "four" ] }
        [ drop "not found" ]
    } case ;

test: case-test-1
    clear

    7 %case-test-1 get-datastack { "not found" } assert= clear
    2 %case-test-1 get-datastack { "two" }       assert= clear
    4 %case-test-1 get-datastack { "four" }      assert= clear
    1 %case-test-1 get-datastack { "one" }       assert= clear
    3 %case-test-1 get-datastack { "three" }     assert= clear
;

case-test-1

: %case-test-2                          // x -> y
    {
        { 1 [ "one" ] }
        { 2 [ "two" ] }
        { 3 [ "three" ] }
        { 4 [ "four" ] }
        // no default
    } case ;

test: case-test-2
    clear

    [ 7 %case-test-2 ] assert-must-fail

    2 %case-test-2 get-datastack { "two" }     assert= clear
    4 %case-test-2 get-datastack { "four" }    assert= clear
    1 %case-test-2 get-datastack { "one" }     assert= clear
    3 %case-test-2 get-datastack { "three" }   assert= clear
;

case-test-2

test: case-test-3
    3 {
        { 1 [ "one" ] }
        { 2 [ "two" ] }
        [ drop "early" ]
        { 3 [ "three" ] }
        { 4 [ "four" ] }
    } case
    "early" assert=
;

case-test-3

: %case-test-4                          // x -> y
    {
        { "fee"  [ 1 ] }
        { "fie"  [ 2 ] }
        { "pho"  [ 3 ] }
        { "phum" [ 4 ] }
    } case
;

test: case-test-4
    "pho"  %case-test-4 3 assert=
    "fee"  %case-test-4 1 assert=
    "phum" %case-test-4 4 assert=
    "fie"  %case-test-4 2 assert=
    [ "effluvia" %case-test-4 ] assert-must-fail
;

case-test-4

: %cond-test-1                          // x -> y
    {
        { [ dup 1 = ] [ drop "one" ] }
        { [ dup 2 = ] [ drop "two" ] }
        { [ dup 3 = ] [ drop "three" ] }
        { [ dup 4 = ] [ drop "four" ] }
        // no default
    } cond ;

test: cond-test-1
    3 %cond-test-1 "three" assert=
    1 %cond-test-1 "one" assert=
    4 %cond-test-1 "four" assert=
    2 %cond-test-1 "two" assert=
    [ 17 %cond-test-1 ] assert-must-fail
;

cond-test-1

: %cond-test-2                          // x -> y
    {
        { [ dup 1 = ] [ drop "one" ] }
        { [ dup 2 = ] [ drop "two" ] }
        { [ dup 3 = ] [ drop "three" ] }
        { [ dup 4 = ] [ drop "four" ] }
        [ drop "something else" ]
    } cond ;

test: cond-test-2
    3 %cond-test-2 "three" assert=
    1 %cond-test-2 "one" assert=
    4 %cond-test-2 "four" assert=
    2 %cond-test-2 "two" assert=
    9 %cond-test-2 "something else" assert=
;

cond-test-2

test: cond-test-3
    3 {
        { [ dup 1 = ] [ drop "one" ] }
        [ drop "early" ]
        { [ dup 2 = ] [ drop "two" ] }
        { [ dup 3 = ] [ drop "three" ] }
        { [ dup 4 = ] [ drop "four" ] }
    } cond
    "early" assert=
;

cond-test-3

test: cond-test-4
    [ { } cond ] assert-must-fail
;

cond-test-4

: %?return-test-1
    [ "yes" ] ?return
    "no" ;

test: ?return-test-1
    clear
    t %?return-test-1 get-datastack { "yes" } assert=
    clear
    f %?return-test-1 get-datastack { "no"  } assert=
    clear
    0 %?return-test-1 get-datastack { "yes" } assert=
    clear ;

?return-test-1

: %?return-test-2
    :> arg

    arg [ arg ] ?return
    arg ;

test: ?return-test-2
    clear
    "foo" dup %?return-test-2 assert-eq
    depth zero? assert

    f %?return-test-2 assert-false
    depth zero? assert ;

?return-test-2

// ?return before first local
: %?return-test-3
    dup 3 = [ drop 47 ] ?return
    :> arg
    arg 9 = [ arg 1 + ] ?return
    arg ;

test: ?return-test-3
    clear
    3 %?return-test-3 get-datastack { 47 } assert=
    clear
    9 %?return-test-3 get-datastack { 10 } assert=
    clear
    5 %?return-test-3 get-datastack {  5 } assert=
    clear
;

?return-test-3

test: ?return-test-4
    { 3 } [ 17 19 = [ 4 ] [ 3 ] if ] unit-test
    { 3 } [ 17 [ 19 = [ 4 ] ?return 3 ] call ] unit-test
    { 4 } [ 19 19 = [ 4 ] [ 3 ] if ] unit-test
    { 4 } [ 19 [ 19 = [ 4 ] ?return 3 ] call ] unit-test
;

?return-test-4

// : %?return-test-5
//     87 :> x
//     19 [ 19 = [ 4 ] ?return 3 ] call
// ;

// test: ?return-test-5
//     %?return-test-5
// ;

// ?return-test-5

test: vector-?pop-test-1
    vector{ 1 2 }
    [ vector-?pop 2 assert= ] keep
    [ vector-?pop 1 assert= ] keep
    [ empty? assert-true ] keep
    vector-?pop assert-false ;

vector-?pop-test-1

test: vector-reverse!-test-1
    vector{ 1 2 3 4 5 } :> v!
    v vector-reverse! v assert-eq
    v vector{ 5 4 3 2 1 } sequence= assert
    vector{ 1 2 3 4 } v!
    v vector-reverse! v assert-eq
    v vector{ 4 3 2 1 } sequence= assert
    vector{ 17 } v!
    v vector-reverse! v assert-eq
    v vector{ 17 } sequence= assert
    vector{ } v!
    v vector-reverse! v assert-eq
    v vector{ } sequence= assert
;

vector-reverse!-test-1

test: count-test-1
    vector{ 1 2 3 4 5 }
    dup ' odd?   count 3 assert=
    dup ' even?  count 2 assert=
    dup [ odd? ] count 3 assert=
    [ even? ]    count 2 assert= ;

count-test-1

test: format-test-1
    1 2 3 4 "the numbers %d, %d, %d and %d" format
    "the numbers 1, 2, 3 and 4" assert=
;

format-test-1

test: format-test-2
    "this is a %%test%%" format "this is a %test%" assert=
;

format-test-2

test: string>float-test-1
    "42.0" string>float 42.0 assert=
    "42" string>float 42.0 assert=
    "-42.0" string>float -42.0 assert=
    "-42" string>float -42.0 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum fixnum>string string>float 1.152921504606847e+18 assert=
//         most-negative-fixnum fixnum>string string>float -1.152921504606847e+18 assert=
//     ] when
;

string>float-test-1

test: int64>float-test-1
    42 fixnum>int64 int64>float 42.0 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum dup + dup int64? assert-true
//         int64>float 2.305843009213694e+18 assert=
//     ] when
;

int64>float-test-1

test: int64-fixnum+-test-1
    42 fixnum>int64 87 int64-fixnum+ 129 assert-eq

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 10 + dup int64? assert-true
//         5 + dup int64? assert-true
//         1152921504606846990 assert=
//
//         "0x7fffffffffffffff" 16 base>integer most-positive-fixnum int64-fixnum+
//         1.0376293541461623e+19 assert=
//     ] when
;

int64-fixnum+-test-1

test: fixnum-fixnum<=-test-1
    1 2 fixnum-fixnum<= assert-true
    2 2 fixnum-fixnum<= assert-true
    2 1 fixnum-fixnum<= assert-false
    -1 0 fixnum-fixnum<= assert-true
    0 -1 fixnum-fixnum<= assert-false
    0 0 fixnum-fixnum<= assert-true
    -1 -1 fixnum-fixnum<= assert-true
    -1 0 fixnum-fixnum<= assert-true
;

fixnum-fixnum<=-test-1

test: <=-test-1
    1 2 <= assert-true
    2 2 <= assert-true
    2 1 <= assert-false
    -1 0 <= assert-true
    0 -1 <= assert-false
    0 0 <= assert-true
    -1 -1 <= assert-true
    -1 0 <= assert-true

    most-negative-fixnum most-positive-fixnum <= assert-true
    most-positive-fixnum most-negative-fixnum <= assert-false

    most-negative-fixnum 10 - dup <= assert-true
    most-negative-fixnum 10 - dup 5 + <= assert-true

    most-positive-fixnum 10 + dup <= assert-true
    most-positive-fixnum 10 + dup 5 + <= assert-true
;

<=-test-1

test: fixnum-fixnum>=-test-1
    43 42 fixnum-fixnum>= assert-true
    43 43 fixnum-fixnum>= assert-true
    42 43 fixnum-fixnum>= assert-false
    -1 1 fixnum-fixnum>= assert-false
    1 -1 fixnum-fixnum>= assert-true
    most-negative-fixnum most-positive-fixnum fixnum-fixnum>= assert-false
    most-positive-fixnum most-negative-fixnum fixnum-fixnum>= assert-true
    most-positive-fixnum dup fixnum-fixnum>= assert-true
    most-negative-fixnum dup fixnum-fixnum>= assert-true
    0 0 fixnum-fixnum>= assert-true
;

fixnum-fixnum>=-test-1

test: >=-test-2
    1 2 >= assert-false
    2 2 >= assert-true
    2 1 >= assert-true
    -1 0 >= assert-false
    0 -1 >= assert-true
    0 0 >= assert-true
    -1 -1 >= assert-true
    -1 0 >= assert-false

    most-negative-fixnum most-positive-fixnum >= assert-false
    most-positive-fixnum most-negative-fixnum >= assert-true

    most-negative-fixnum dup 10 - >= assert-true
    most-negative-fixnum 10 - dup 5 + swap >= assert-true

    most-positive-fixnum 10 + dup >= assert-true
    most-positive-fixnum 10 + dup 5 + swap >= assert-true
;

>=-test-2

test: fixnum-fixnum+-test-1
    1  2 fixnum-fixnum+  3 assert-eq
    1 -2 fixnum-fixnum+ -1 assert-eq

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 0 fixnum-fixnum+ most-positive-fixnum assert-eq
//
//         most-positive-fixnum   1 fixnum-fixnum+  1152921504606846976 assert=
//         most-negative-fixnum  -1 fixnum-fixnum+ -1152921504606846977 assert=
//         most-positive-fixnum dup fixnum-fixnum+  2305843009213693950 assert=
//         most-negative-fixnum dup fixnum-fixnum+ -2305843009213693952 assert=
//     ] when
;

fixnum-fixnum+-test-1

test: fixnum-1+-test-1
    42 fixnum-1+ 43 assert-eq
    -1 fixnum-1+  0 assert-eq

    most-negative-fixnum fixnum-1+
    [ fixnum? assert ]
    [ most-negative-fixnum 1 fixnum-fixnum+ assert= ]
    [ most-negative-fixnum 1 + assert= ]
    tri

    // overflow
    most-positive-fixnum fixnum-1+
    [ dup int64? assert-eq ]
    [ most-positive-fixnum fixnum>int64 1 int64-fixnum+ assert= ]
    [ most-positive-fixnum 1 + assert= ]
    tri
;

fixnum-1+-test-1

test: fixnum-1--test-1
    43 fixnum-1- 42 assert-eq
     0 fixnum-1- -1 assert-eq
    -1 fixnum-1- -2 assert-eq

    most-positive-fixnum fixnum-1-
    [ fixnum? assert ]
    [ most-positive-fixnum fixnum>int64 1 int64-fixnum- assert= ]
    [ most-positive-fixnum 1 - assert= ]
    tri

    // overflow
    most-negative-fixnum fixnum-1-
    [ dup int64? assert-eq ]
    [ most-negative-fixnum 1 fixnum-fixnum- assert= ]
    [ most-negative-fixnum 1 - assert= ]
    tri
;

fixnum-1--test-1

test: fixnum-fixnum*-test-1
    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 1 fixnum-fixnum* 1152921504606846975 assert-eq
//         most-positive-fixnum 2 fixnum-fixnum* 2305843009213693950 assert=
//         most-positive-fixnum 3 fixnum-fixnum* 3458764513820540925 assert=
//
//         most-positive-fixnum dup fixnum-fixnum* 1329227995784915870597964051066650625 assert=
//         most-positive-fixnum dup fixnum-fixnum* most-positive-fixnum 2 expt assert=
//
//         most-negative-fixnum 1 fixnum-fixnum* -1152921504606846976 assert=
//
//         most-positive-fixnum most-negative-fixnum fixnum-fixnum*
//         -1329227995784915871750885555673497600 assert=
//     ] when
;

fixnum-fixnum*-test-1

test: int64-int64*-test-1
    42 fixnum>int64 dup int64-int64* dup fixnum? assert 1764 assert-eq

    most-positive-fixnum dup fixnum-fixnum* dup *
    most-positive-fixnum 4 expt assert=
;

int64-int64*-test-1

test: fixnum-fixnum/i-test-1
    3  2 fixnum-fixnum/i  1 assert=
    3 -2 fixnum-fixnum/i -1 assert=
    most-positive-fixnum -1 fixnum-fixnum/i most-positive-fixnum negate assert=
    most-negative-fixnum -1 fixnum-fixnum/i most-positive-fixnum 1 + assert=
;

fixnum-fixnum/i-test-1

test: float-float/f-test-1
    15.0 4.0 float-float/f 3.75 assert=
    56323.0 4000.0 float-float/f 14.08075 assert=
    -17.67 7.2 float-float/f -2.454166666666667 assert=
;

float-float/f-test-1

test: float-float<-test-1
    3.0 4.0 float-float< assert-true
    4.0 3.0 float-float< assert-false
    -3.0 -4.0 float-float< assert-false
    -4.0 -3.0 float-float< assert-true
    3.0 3.0 float-float< assert-false
    -3.0 -3.0 float-float< assert-false
;

float-float<-test-1

test: float-float<=-test-1
    3.0 4.0 float-float<= assert-true
    4.0 3.0 float-float<= assert-false
    -3.0 -4.0 float-float<= assert-false
    -4.0 -3.0 float-float<= assert-true
    3.0 3.0 float-float<= assert-true
    -3.0 -3.0 float-float<= assert-true
;

float-float<=-test-1

test: float-float>-test-1
    3.0 4.0 float-float> assert-false
    4.0 3.0 float-float> assert-true
    -3.0 -4.0 float-float> assert-true
    -4.0 -3.0 float-float> assert-false
    3.0 3.0 float-float> assert-false
    -3.0 -3.0 float-float> assert-false
;

float-float>-test-1

test: float-float>=-test-1
    3.0 4.0 float-float>= assert-false
    4.0 3.0 float-float>= assert-true
    -3.0 -4.0 float-float>= assert-true
    -4.0 -3.0 float-float>= assert-false
    3.0 3.0 float-float>= assert-true
    -3.0 -3.0 float-float>= assert-true
;

float-float>=-test-1

test: fixnum-equal?-test-1
    42 42 fixnum-equal? assert-true
    42 dup >float swap fixnum-equal? assert-true
    "test" 42 fixnum-equal? assert-false
;

fixnum-equal?-test-1

test: float-sqrt-test-1
    2.0 float-sqrt 1.4142135623730951 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum >float float-sqrt 1073741824.0 assert=
//     ] when

    2 53 expt >float float-sqrt 94906265.624251559 assert=
;

float-sqrt-test-1

test: sqrt-test-1
    2 sqrt 1.4142135623730951 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum sqrt 1073741824.0 assert=
//     ] when

    2 53 expt sqrt 94906265.624251559 assert=
    pi sqrt 1.7724538509055159 assert=
    0 sqrt 0.0 assert=
    [ -1 sqrt ] assert-must-fail
;

sqrt-test-1

test: int32?-test-1
    most-negative-fixnum int32? assert-false
    min-int32 1 - int32? assert-false
    min-int32 dup int32? assert-eq      // int32? returns its argument instead of true
    min-int32 1 + dup int32? assert-eq
    -1 dup int32? assert-eq
    0 dup int32? assert-eq
    1 dup int32? assert-eq
    max-int32 1 - dup int32? assert-eq
    max-int32 dup int32? assert-eq
    max-int32 1 + int32? assert-false
    most-positive-fixnum int32? assert-false

    pi int32? assert-false
    "test" int32? assert-false ;

int32?-test-1

public

: this-is-a-public-word ;

public: this-is-another-public-word ;

private: this-is-not-a-public-word ;

private

: this-is-a-private-word ;

private: this-is-another-private-word ;

public: this-is-not-a-private-word ;

public

test: visibility-test-1
    ' this-is-a-public-word             [ symbol-private? assert-false ] [ symbol-public? assert-true ]  bi
    ' this-is-another-public-word       [ symbol-private? assert-false ] [ symbol-public? assert-true ]  bi
    ' this-is-not-a-public-word         [ symbol-private? assert-true ]  [ symbol-public? assert-false ] bi
    ' this-is-a-private-word            [ symbol-private? assert-true ]  [ symbol-public? assert-false ] bi
    ' this-is-another-private-word      [ symbol-private? assert-true ]  [ symbol-public? assert-false ] bi
    ' this-is-not-a-private-word        [ symbol-private? assert-false ] [ symbol-public? assert-true ]  bi
;

visibility-test-1

test: generic?-test-1
    ' length generic? assert-true
    ' dup generic? assert-false
;

generic?-test-1

test: vector-remove-test-1
    3 vector{ } vector-remove vector{ } assert=
    3 vector{ 17 } vector-remove vector{ 17 } assert=
    17 vector{ 17 } vector-remove vector{ } assert=
    3 vector{ 3 1 2 3 4 5 3 6 3 } vector-remove vector{ 1 2 4 5 6 } assert=

    vector{ 3 1 2 3 4 5 3 6 3 } :> v1
    3 v1 vector-remove :> v2
    v1 vector{ 3 1 2 3 4 5 3 6 3 } assert=
    v2 vector{ 1 2 4 5 6 } assert=
    v1 v2 eq? assert-false
;

vector-remove-test-1

test: vector-remove!-test-1
    3 vector{ } vector-remove! vector{ } assert=
    3 vector{ 17 } vector-remove! vector{ 17 } assert=
    17 vector{ 17 } vector-remove! vector{ } assert=
    3 vector{ 3 1 2 3 4 5 3 6 3 } vector-remove! vector{ 1 2 4 5 6 } assert=

    vector{ 3 1 2 3 4 5 3 6 3 } :> v1
    3 v1 vector-remove! :> v2
    v1 vector{ 1 2 4 5 6 } assert=
    v2 vector{ 1 2 4 5 6 } assert=
    v1 v2 assert-eq
;

vector-remove!-test-1

test: vector-remove-eq!-test-1
    3 vector{ } vector-remove-eq! vector{ } assert=
    3 vector{ 17 } vector-remove-eq! vector{ 17 } assert=
    17 vector{ 17 } vector-remove-eq! vector{ } assert=
    3 vector{ 3 1 2 3 4 5 3 6 3 } vector-remove-eq! vector{ 1 2 4 5 6 } assert=

    vector{ 3 1 2 3 4 5 3 6 3 } :> v1
    3 v1 vector-remove-eq! :> v2
    v1 vector{ 1 2 4 5 6 } assert=
    v2 vector{ 1 2 4 5 6 } assert=
    v1 v2 assert-eq
;

vector-remove-eq!-test-1

test: vector-adjoin-test-1
    vector{ 1 2 3 4 5 6 } :> v
    42 v vector-adjoin
    v vector{ 1 2 3 4 5 6 42 } assert=
    4 v vector-adjoin
    v vector{ 1 2 3 5 6 42 4 } assert=
    // no change if element is already at the end of the sequence
    4 v vector-adjoin
    v vector{ 1 2 3 5 6 42 4 } assert=
;

vector-adjoin-test-1

test: string-nth-test-1
    "this is a test" :> s
    0 s string-nth 't' assert-eq
    1 s string-nth 'h' assert-eq
    13 s string-nth 't' assert-eq

    [ -1 s string-nth ] assert-must-fail
    [ 14 s string-nth ] assert-must-fail
;

string-nth-test-1

test: sbuf-nth-unsafe-test-1
    "this is a test" string>sbuf :> sb
    0 sb sbuf-nth-unsafe 't' assert-eq
    1 sb sbuf-nth-unsafe 'h' assert-eq
    13 sb sbuf-nth-unsafe 't' assert-eq ;

sbuf-nth-unsafe-test-1

test: sbuf-nth-test-1
    "this is a test" string>sbuf :> sb
    0 sb sbuf-nth 't' assert-eq
    1 sb sbuf-nth 'h' assert-eq
    13 sb sbuf-nth 't' assert-eq

    [ -1 sb sbuf-nth ] assert-must-fail
    [ 14 sb sbuf-nth ] assert-must-fail ;

sbuf-nth-test-1

test: type-of-test-1
    "test" type-of string assert-eq
    "test" string>sbuf type-of sbuf assert-eq
    "test" type-of type-of type assert-eq
    42 type-of fixnum assert-eq
    t type-of boolean assert-eq
    f type-of boolean assert-eq
    vector{ 1 2 3 } type-of vector assert-eq
    { 1 2 3 } type-of array assert-eq
    16 <hashtable> type-of hashtable assert-eq
    ' dup type-of symbol assert-eq
    current-vocab type-of vocab assert-eq
    [ dup + ] type-of quotation assert-eq
    ' dup <wrapper> dup wrapper? dup assert-eq
    type-of wrapper assert-eq
    3 [ + ] curry dup quotation? assert // quotation? returns its argument or nil
    type-of quotation assert-eq
    2 5 { 11 12 13 14 15 16 17 18 } <slice> dup slice? assert-true
    type-of slice assert-eq
    3 5 <range> dup range? assert-true
    type-of range assert-eq
    "this is a test" make-lexer dup lexer? over assert-eq
    type-of lexer assert-eq
    pi type-of float assert-eq
    "test" <iterator> dup iterator? assert-true
    type-of iterator assert-eq
    ' length symbol-def type-of generic-function assert-eq
    max-uint64 type-of uint64 assert-eq ;

type-of-test-1

test: symbol-equal?-test-1
    ' dup dup symbol-equal? assert-true
    ' drop ' dup symbol-equal? assert-false

    42 ' dup symbol-equal? assert-false
    ' dup 42 symbol-equal? assert-false

    42 42 symbol-equal? assert-false

    // generic
    ' dup dup equal? assert-true
    ' drop ' dup equal? assert-false
;

symbol-equal?-test-1

test: boolean-equal?-test-1
    t t boolean-equal? assert-true
    f f boolean-equal? assert-true
    t f boolean-equal? assert-false
    f t boolean-equal? assert-false

    0 t boolean-equal? assert-false
    t 0 boolean-equal? assert-false
    0 f boolean-equal? assert-false
    f 0 boolean-equal? assert-false

    1 t boolean-equal? assert-false
    t 1 boolean-equal? assert-false
    1 f boolean-equal? assert-false
    f 1 boolean-equal? assert-false

    -1 t boolean-equal? assert-false
    t -1 boolean-equal? assert-false
    -1 f boolean-equal? assert-false
    f -1 boolean-equal? assert-false

    "test" "test" boolean-equal? assert-false
    "test" 42 boolean-equal? assert-false

    // generic
    t t equal? assert-true
    f f equal? assert-true
    t f equal? assert-false
    f t equal? assert-false
;

boolean-equal?-test-1

test: boolean?-test-1
    t boolean? assert-true
    f boolean? assert-true
    0 boolean? assert-false
    1 boolean? assert-false
    -1 boolean? assert-false
;

boolean?-test-1

test: callable?-test-1
    ' dup callable? assert-true
    ' callable?-test-1 callable? assert-true

    [ dup ] callable? assert-true

    // quotation? returns its argument or nil
    3 [ + ] curry dup quotation? assert callable? assert-true

    42 callable? assert-false
    "test" callable? assert-false
;

callable?-test-1

test: abs-test-1
      0 abs  0 assert-eq

     42 abs 42 assert-eq
    -42 abs 42 assert-eq

    most-positive-fixnum dup abs assert-eq
    most-positive-fixnum dup negate abs assert-eq

    most-negative-fixnum abs int64? assert
    most-negative-fixnum abs most-negative-fixnum negate assert=

    most-positive-int64 dup abs assert=
    most-positive-int64 dup negate abs assert=

    most-negative-int64 abs float? assert
    most-negative-int64 abs most-positive-int64 assert=

    pi dup abs assert-eq
    pi dup negate abs assert=
;

abs-test-1

test: floor-test-1
    0.0 float-floor 0 assert-eq

    pi float-floor 3 assert-eq
    pi negate float-floor -4 assert-eq

    most-positive-int64 dup int64-int64+ float-floor 1.8446744073709552e+19 assert=
;

floor-test-1

test: float-truncate-test-1
     42.7 float-truncate  42 assert-eq
    -42.7 float-truncate -42 assert-eq

    most-positive-int64 dup int64-int64+ float-truncate 1.8446744073709552e+19 assert=
;

float-truncate-test-1

test: fixnum/f-test-1
    42 4 fixnum/f 10.5 assert=
    42 fixnum>int64 dup int64? over assert-eq 4 fixnum/f 10.5 assert=
    42.0 4 fixnum/f 10.5 assert=

    fixnum-tag-bits 1 assert-eq
//     fixnum-tag-bits 3 = [
//         most-positive-fixnum 1 + 2 fixnum/f  5.7646075230342349e+17 assert=
//         most-negative-fixnum     2 fixnum/f -5.7646075230342349e+17 assert=
//     ] when
;

fixnum/f-test-1

test: lshift-test-1
    1 1 lshift 2 assert-eq
    1 2 lshift 4 assert-eq

    -1 1 lshift -2 assert-eq
    -2 1 lshift -4 assert-eq

    1 60 lshift 1152921504606846976 assert-eq
    1 61 lshift 2305843009213693952 assert-eq
    1 62 lshift dup int64? over assert-eq 4611686018427387904 assert=
    1 63 lshift dup uint64? over assert-eq 9223372036854775808 assert=

    -1 60 lshift -1152921504606846976 assert-eq
    -1 61 lshift -2305843009213693952 assert-eq
    -1 62 lshift dup fixnum? assert -4611686018427387904 assert-eq
    -1 63 lshift dup int64? over assert-eq -9223372036854775808 assert=

    most-positive-fixnum 1 lshift dup int64? over assert-eq dup 9223372036854775806 assert=
    most-positive-fixnum dup + assert=

    most-negative-int64 -9223372036854775808 assert=
    most-negative-int64 1 lshift 0 assert-eq
    most-negative-int64 1 + 1 lshift 2 assert-eq
    most-negative-int64 2 + 1 lshift 4 assert-eq
;

lshift-test-1

test: rshift-test-1
    8 3 rshift 1 assert-eq

    most-positive-fixnum 4611686018427387903 assert-eq
    most-positive-fixnum 1 rshift dup fixnum? assert 2305843009213693951 assert-eq
    most-positive-fixnum 17 rshift dup fixnum? assert 35184372088831 assert-eq
    most-positive-fixnum 23 rshift dup fixnum? assert 549755813887 assert-eq

    most-negative-fixnum -4611686018427387904 assert-eq
    most-negative-fixnum 1 rshift dup fixnum? assert -2305843009213693952 assert-eq

    most-positive-int64 9223372036854775807 assert=
    most-positive-int64 1 rshift dup fixnum? assert 4611686018427387903 assert-eq

    most-negative-int64 -9223372036854775808 assert=
    most-negative-int64 1 rshift dup fixnum? assert -4611686018427387904 assert-eq

    max-uint64 18446744073709551615 assert=
    max-uint64 1 rshift 9223372036854775807 assert= ;

rshift-test-1

test: bitxor-test-1
    -1 1 bitxor -2 assert-eq
    -42 42 bitxor -4 assert-eq
    most-positive-fixnum most-negative-fixnum bitxor -1 assert-eq

    most-negative-int64 -9223372036854775808 assert=
    most-negative-int64 1 bitxor -9223372036854775807 assert=
;

bitxor-test-1

test: bitnot-test-1
      0 bitnot   -1 assert-eq
     -1 bitnot    0 assert-eq

    123 bitnot -124 assert-eq

    63 [ 1 swap lshift dup bitnot swap negate 1 - assert= ] each-integer
;

bitnot-test-1

test: path-append-test-1
    win64? [
        "foo"   "bar" path-append "foo\\bar" assert=
        "foo\\" "bar" path-append "foo\\bar" assert=
    ] when

    linux? [
        "foo"   "bar" path-append "foo/bar" assert=
        "foo/"  "bar" path-append "foo/bar" assert=
    ] when
;

path-append-test-1

test: canonical-path-test-1
    "." canonical-path string? assert

    " " canonical-path assert-false
    "" canonical-path assert-false

    win64? [ "..." canonical-path assert-false ] unless

    "~" canonical-path user-home assert=

    "~/" canonical-path user-home "/" path-append canonical-path assert=
    "~/foo.bar" canonical-path user-home "foo.bar" path-append canonical-path assert=

    win64? [
        "~\\" canonical-path user-home "\\" path-append canonical-path assert=
        "~\\foo.bar" canonical-path user-home "foo.bar" path-append canonical-path assert=
    ] when
;

canonical-path-test-1

test: file-name-absolute?-test-1
    clear

    win64? [
        "" file-name-absolute? assert-false
        "foo" file-name-absolute? assert-false
        "\\foo" file-name-absolute? assert-true
        "foo\\bar" file-name-absolute? assert-false
        "\\foo\\bar" file-name-absolute? assert-true
        "c" file-name-absolute? assert-false
    ] when

    linux? [
        "" file-name-absolute? assert-false
        "foo" file-name-absolute? assert-false
        "/foo" file-name-absolute? assert-true
        "foo/bar" file-name-absolute? assert-false
        "/foo/bar" file-name-absolute? assert-true
    ] when

    depth zero? assert-true
;

file-name-absolute?-test-1

test: file-name-extension-test-1
    { ".feline" } [ "test.feline" file-name-extension ] unit-test

    { f } [ "test" file-name-extension ] unit-test

    { f } [ ""  file-name-extension ] unit-test
    { f } [ "." file-name-extension ] unit-test
    { f } [ "a" file-name-extension ] unit-test

    { f } [ ".foo" file-name-extension ] unit-test
    { f } [ "foo." file-name-extension ] unit-test

    { ".feline" } [ "foo.bar/test.feline" file-name-extension ] unit-test

    { f } [ "foo.bar/test" file-name-extension ] unit-test

    win64? [
        { ".feline" } [ "foo.bar\\test.feline" file-name-extension ] unit-test
        { f } [ "foo.bar\\test" file-name-extension ] unit-test
    ] when ;

file-name-extension-test-1

test: ensure-feline-extension-test-1
    clear
    "test.feline" ensure-feline-extension "test.feline" assert=
    "test" ensure-feline-extension "test.feline" assert=
;

ensure-feline-extension-test-1

test: 2tri-test-1
    clear
    10 20 [ 1 + ] [ 2 + ] [ 3 + ] 2tri
    get-datastack { 10 21 10 22 10 23 } assert=
    clear
;

2tri-test-1

test: ?bounds-test-1
    clear

    0 "test" ?bounds get-datastack { 0 "test" } assert=
    clear
    1 "test" ?bounds get-datastack { 1 "test" } assert=
    clear
    2 "test" ?bounds get-datastack { 2 "test" } assert=
    clear
    3 "test" ?bounds get-datastack { 3 "test" } assert=
    clear

    4 "test" ?bounds get-datastack { f f } assert=
    clear

    -1 "test" ?bounds get-datastack { f f } assert=
    clear
    most-negative-fixnum "test" ?bounds get-datastack { f f } assert=
    clear
    most-positive-fixnum "test" ?bounds get-datastack { f f } assert=
    clear
;

?bounds-test-1

generic %method-test-1

method: string %method-test-1
    string-length ;

method: fixnum %method-test-1
    dup + ;

test: method-test-1
    clear
    "testing" %method-test-1 get-datastack { 7 } assert=
    clear
    87 %method-test-1 get-datastack { 174 } assert=
    clear
;

method-test-1

tuple: tuple-1 ;
tuple: tuple-2 ;

generic %method-test-2

method: tuple-1 %method-test-2 drop 42 ;
method: tuple-2 %method-test-2 drop 87 ;

test: method-test-2
    clear
    tuple-1 make-instance %method-test-2 get-datastack { 42 } assert=
    clear
    tuple-2 make-instance %method-test-2 get-datastack { 87 } assert=
    clear
;

method-test-2

test: tri-test-1
    clear
    42 [ 1 + ] [ 2 + ] [ 3 + ] tri
    get-datastack { 43 44 45 } assert=
    clear
;

tri-test-1

test: file-attributes-test-1
    win64? "c:/windows" "/home" ?
    [ dup exists? assert-eq ]   // exists? returns its argument if true
    [ dup dir? assert-eq ]      // dir? returns its argument if true
    [ file? assert-false ]
    tri

    feline-home "src/test.feline" path-append
    [ dup exists? assert-eq ]
    [ dir? assert-false ]
    [ dup file? assert-eq ]     // file? returns its argument if true
    tri ;

file-attributes-test-1

test: keyword-test-1
    :foo [ keyword? assert-true ] [ symbol? assert-false ] bi
    :foo verify-keyword :foo assert-eq
    :foo :foo assert-eq
    :foo gc :foo assert-eq
    { :foo :bar } [ first :foo assert-eq ] [ second :bar assert-eq ] bi ;

keyword-test-1

test: keyword-name-test-1
    :foo keyword-name "foo" assert=
    [ ' dup keyword-name ] assert-must-fail
    [ "test" keyword-name ] assert-must-fail
    [ 93 keyword-name ] assert-must-fail
;

keyword-name-test-1

test: reduce-test-1
    { 1 2 3 4 5 } 1 [ * ] reduce 120 assert-eq
    { 1 2 3 4 5 } 0 [ + ] reduce  15 assert-eq

    { 91 47 1000 -3 15 -7.1 0 }
    [ most-positive-fixnum [ min ] reduce -7.1 assert= ]
    [ most-negative-fixnum [ max ] reduce 1000 assert= ]
    bi

    { }    42 [ + ] reduce 42 assert-eq
    { 17 } 42 [ + ] reduce 59 assert-eq
;

reduce-test-1

test: cleave-test-1
    { 38 361 } [ 19 { [ dup + ] [ dup * ] } cleave ] unit-test
    { 37 } [ 14 { [ 23 + ] } cleave ] unit-test
    { } [ 97 { } cleave ] unit-test ;

cleave-test-1

test: sbuf-append-string-test-1
    "this is a test" string>sbuf :> sb
    " and this is " sb sbuf-append-string
    "another test" sb sbuf-append-string
    sb "this is a test and this is another test" sequence= assert
;

sbuf-append-string-test-1

test: sbuf-push-test-1
    8 <sbuf> :> sb
    sb sbuf-capacity 8 assert-eq
    't' sb sbuf-push
    'e' sb sbuf-push
    's' sb sbuf-push
    't' sb sbuf-push
    'i' sb sbuf-push
    'n' sb sbuf-push
    'g' sb sbuf-push
    sb sbuf-capacity 8 assert-eq
    sb sbuf-length 7 assert-eq
    'x' sb sbuf-push
    sb sbuf-capacity 8 assert-eq
    sb sbuf-length 8 assert-eq
    'y' sb sbuf-push
    sb sbuf-capacity 9 >= assert
    sb sbuf-length 9 assert-eq
    sb "testingxy" sequence= assert
;

sbuf-push-test-1

test: thread-test-1
    // thread? returns its argument if it is a thread
    current-thread dup thread? assert-eq
    current-thread thread-state THREAD_RUNNING assert-eq
    sp0 current-thread thread-sp0 assert-eq
;

thread-test-1

global thread-test-2-result

test: thread-test-2
    f thread-test-2-result!
    [ 42 thread-test-2-result! ] make-thread
    dup thread-create thread-join
    thread-test-2-result 42 assert-eq
;

thread-test-2

test: thread-test-3
    [ 1 2 3 4 ] make-thread
    dup thread-result assert-false
    dup thread-create
    dup thread-join
    thread-result { 1 2 3 4 } assert=
;

thread-test-3

test: thread-test-4
    linux? [ current-thread thread-id current-thread-id assert= ] when

    win64? [
        // REVIEW
        // In general we don't care about the native thread id on Windows.
        // We do care about the native thread handle (which doesn't exist on Linux).
        // We do store the native thread id for the primordial thread (only).
        current-thread primordial-thread eq? [
            current-thread thread-id current-thread-id assert=
        ] when
    ] when
;

thread-test-4

var test5

test: thread-test-5
    gc
    87 test5!
    test5 87 assert-eq
    [ 42 test5! test5 ] make-thread :> th
    th thread-create
    th thread-join
    th thread-result { 42 } assert=
    test5 87 assert-eq
;

thread-test-5

test: thread-test-6
    make-mutex :> m
    m mutex-owner assert-false
    m mutex-lock assert-true
    m mutex-owner current-thread assert-eq
    m mutex-unlock assert-true
    m mutex-owner assert-false
;

thread-test-6

test: vector-all?-test-1
    vector{ } [ fixnum? ] vector-all? assert-true

    vector{ 1 2 3 4 5 } [ fixnum? ] vector-all? assert-true
    vector{ 'a' 'b' 'c' } [ fixnum? ] vector-all? assert-false
    vector{ 'a' 'b' 'c' } [ char? ] vector-all? assert-true
    vector{ 'a' 2 3 4 5 } [ fixnum? ] vector-all? assert-false
    vector{ 1 2 3 4 'z' } [ fixnum? ] vector-all? assert-false
;

vector-all?-test-1

: %named-parameters-test-1 ( a ) a ;

test: named-parameters-test-1
    clear
    1 %named-parameters-test-1 get-datastack { 1 } assert=
    clear
;

named-parameters-test-1

: %named-parameters-test-2 ( a b ) a b ;

test: named-parameters-test-2
    clear
    1 2 %named-parameters-test-2 get-datastack { 1 2 } assert=
    clear
;

named-parameters-test-2

: %named-parameters-test-3 ( a b c ) a b c ;

test: named-parameters-test-3
    clear
    1 2 3 %named-parameters-test-3 get-datastack { 1 2 3 } assert=
    clear
;

named-parameters-test-3

: %named-parameters-test-4 ( a b c d ) a b c d ;

test: named-parameters-test-4
    clear
    1 2 3 4 %named-parameters-test-4 get-datastack { 1 2 3 4 } assert=
    clear
;

named-parameters-test-4

test: printable-char?-test-1
    // printable-char? returns its argument if it is a printable char
    { 'a' } [ 'a' printable-char? ] unit-test
    { '~' } [ '~' printable-char? ] unit-test
    { '\s' } [ " " string-first-char printable-char? ] unit-test

    { f } [ 3 code-char printable-char? ] unit-test ;

printable-char?-test-1

test: printable-char?-test-2
    { f }
    [ 0 32 [ code-char printable-char? ] find-integer-in-range ] unit-test

    { f }
    [ 32 127 [ code-char printable-char? not ] find-integer-in-range ] unit-test

    { f }
    [ 127 256 [ code-char printable-char? ] find-integer-in-range ] unit-test ;

printable-char?-test-2

test: char>string-test-1
    'a' char>string "'a'" assert=
    '7' char>string "'7'" assert=
    '~' char>string "'~'" assert=

     3 code-char char>string "'\\x03'" assert=  // ctrl-c

     7 code-char char>string "'\\a'" assert=  // \a
     8 code-char char>string "'\\b'" assert=  // \b
     9 code-char char>string "'\\t'" assert=  // \t
    10 code-char char>string "'\\n'" assert=  // \n
    11 code-char char>string "'\\v'" assert=  // \v
    12 code-char char>string "'\\f'" assert=  // \f
    13 code-char char>string "'\\r'" assert=  // \r
    32 code-char char>string "'\\s'" assert=  // \s
    34 code-char char>string "'\"'"  assert=  // \"
    39 code-char char>string "'\\''" assert=  // \'
    92 code-char char>string "'\\'"  assert=  // \\
;

char>string-test-1

test: token-character-literal?-test-1

    { 'a' t } [ "'a'" token-character-literal? ] unit-test
    { 'a' t } [ "'\\x61'" token-character-literal? ] unit-test
    { '\x1b' t } [ "'\\x1b'" token-character-literal? ] unit-test
    { '\x20' t } [ "'\\x20'" token-character-literal? ] unit-test

    { '\x07' t } [ "'\a'" token-character-literal? ] unit-test
    { '\x08' t } [ "'\b'" token-character-literal? ] unit-test
    { '\x09' t } [ "'\t'" token-character-literal? ] unit-test
    { '\x0a' t } [ "'\n'" token-character-literal? ] unit-test
    { '\x0b' t } [ "'\v'" token-character-literal? ] unit-test
    { '\x0c' t } [ "'\f'" token-character-literal? ] unit-test
    { '\x0d' t } [ "'\r'" token-character-literal? ] unit-test
    { '\x1b' t } [ "'\e'" token-character-literal? ] unit-test
    { '\x22' t } [ "'\"'" token-character-literal? ] unit-test

    { "'\\xxx'" f } [ "'\\xxx'" token-character-literal? ] unit-test
;

token-character-literal?-test-1

test: iterator-test-1
    "this is a test" <iterator> :> iter
    "" string>sbuf :> sb
    [ iter iterator-next dup ] [ sb push ] while drop
    sb sbuf>string "this is a test" assert=
;

iterator-test-1

test: string-iterator-test
    local iter
    { } [
        "this is a test" make-string-iterator iter!
        iter dup string-iterator? assert-eq
        iter string-iterator-string "this is a test" assert=
        iter string-iterator-index -1 assert-eq
        iter string-iterator-length 14 assert-eq

        iter string-iterator-peek 't' assert-eq
        iter string-iterator-index -1 assert-eq

        iter string-iterator-next 't' assert-eq
        iter string-iterator-index 0 assert-eq

        iter string-iterator-peek 'h' assert-eq
        iter string-iterator-index 0 assert-eq

        iter string-iterator-next 'h' assert-eq
        iter string-iterator-next 'i' assert-eq
        iter string-iterator-next 's' assert-eq
        iter string-iterator-next '\s' assert-eq

        iter string-iterator-skip-to-end
        iter string-iterator-index 14 assert-eq
        iter string-iterator-next nil assert-eq

        // subsequent calls continue to return nil
        iter string-iterator-next nil assert-eq

        5 7 iter string-iterator-substring "is" string=? assert

        "this is another test" make-string-iterator iter!
        iter dup string-iterator? assert-eq
        iter string-iterator-string "this is another test" assert=
        iter string-iterator-index -1 assert-eq
        iter string-iterator-length 20 assert-eq

        1 iter string-iterator-skip
        iter string-iterator-index 0 assert-eq

        iter string-iterator-next 'h' assert-eq
        iter string-iterator-index 1 assert-eq

        12 iter string-iterator-skip
        iter string-iterator-index 13 assert-eq

        iter string-iterator-peek 'r' assert-eq
        iter string-iterator-index 13 assert-eq
        iter string-iterator-next 'r' assert-eq
        iter string-iterator-index 14 assert-eq

        iter string-iterator-skip-to-end
        iter string-iterator-index 20 assert-eq
        iter string-iterator-next nil assert-eq

        // subsequent calls continue to return nil
        iter string-iterator-next nil assert-eq

        "best" make-string-iterator iter!
        iter string-iterator-next 'b' assert-eq
        iter string-iterator-next 'e' assert-eq
        iter string-iterator-next 's' assert-eq
        iter string-iterator-next 't' assert-eq
        iter string-iterator-index 3 assert-eq
        iter string-iterator-next nil assert-eq
        iter string-iterator-index 4 assert-eq

        // subsequent calls continue to return nil...
        iter string-iterator-next nil assert-eq
        // ...and leave the index unchanged
        iter string-iterator-index 4 assert-eq

        0 4 iter string-iterator-substring "best" string=? assert

        // REVIEW string-iterator-reset
        -5 iter string-iterator-skip

        iter string-iterator-index -1 assert-eq
        iter string-iterator-next 'b' assert-eq
        iter string-iterator-index 0 assert-eq
        iter string-iterator-next 'e' assert-eq
        -1 iter string-iterator-skip
        iter string-iterator-next 'e' assert-eq
        iter string-iterator-next 's' assert-eq
        iter string-iterator-next 't' assert-eq

        -100 iter string-iterator-skip
        iter string-iterator-index -1 assert-eq
        iter string-iterator-next 'b' assert-eq
    ] unit-test ;

string-iterator-test

test: string-index-from-test-1
    't' 0 "this is a test" string-index-from zero? assert-true
    'h' 0 "this is a test" string-index-from 1 assert-eq
    'h' 2 "this is a test" string-index-from assert-false
    't' 1 "this is a test" string-index-from 10 assert-eq
    'e' 4 "this is a test" string-index-from 11 assert-eq

    'x' 0 "this is a test" string-index-from assert-false

    't' most-positive-fixnum "this is a test" string-index-from assert-false

    [ 't' -1 "this is a test" string-index-from ] assert-must-fail
    [ 't' most-negative-fixnum "this is a test" string-index-from ] assert-must-fail
;

string-index-from-test-1

test: string-last-index-from-test-1
    't' 0 "this is a test" string-last-index-from zero? assert-true
    'h' 0 "this is a test" string-last-index-from assert-false
    'h' 2 "this is a test" string-last-index-from 1 assert-eq
    't' 13 "this is a test" string-last-index-from 13 assert-eq
    'e' 13 "this is a test" string-last-index-from 11 assert-eq

    's' 13 "this is a test" string-last-index-from 12 assert-eq
    's' 12 "this is a test" string-last-index-from 12 assert-eq
    's' 11 "this is a test" string-last-index-from 6 assert-eq
    's' 6 "this is a test" string-last-index-from 6 assert-eq
    's' 5 "this is a test" string-last-index-from 3 assert-eq
    's' 3 "this is a test" string-last-index-from 3 assert-eq
    's' 2 "this is a test" string-last-index-from assert-false

    'x' 13 "this is a test" string-last-index-from assert-false

    't' 14 "this is a test" string-last-index-from assert-false

    't' most-positive-fixnum "this is a test" string-last-index-from assert-false

    [ 't' -1 "this is a test" string-last-index-from ] assert-must-fail
    [ 't' most-negative-fixnum "this is a test" string-last-index-from ] assert-must-fail
;

string-last-index-from-test-1

test: file-open-append-test-1
    "delete-me" :> file
    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    file file-open-append :> stream!
    stream dup file-output-stream? assert-eq
    "this is a test" stream file-output-stream-write-string
    stream file-output-stream-close

    file exists? file assert-eq
    file file-contents "this is a test" assert=

    file file-open-append stream!
    stream dup file-output-stream? assert-eq
    " and this is another test" stream file-output-stream-write-string
    stream file-output-stream-close

    file exists? file assert-eq
    file file-contents "this is a test and this is another test" assert=

    file delete-file assert-true
    file exists? assert-false ;

file-open-append-test-1

test: file-open-append-test-2
    "delete-me" :> file
    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    file file-open-append :> stream!
    stream dup file-output-stream? assert-eq
    "this is a test" stream file-output-stream-write-string
    // generic
    stream close

    file exists? file assert-eq
    file file-contents "this is a test" assert=

    file file-open-append stream!
    stream dup file-output-stream? assert-eq
    " and this is another test" stream file-output-stream-write-string
    // generic
    stream close

    file exists? file assert-eq
    file file-contents "this is a test and this is another test" assert=

    file delete-file assert-true
    file exists? assert-false ;

file-open-append-test-2

test: set-file-contents-test-1
    "delete-me" :> file
    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    "this is a test" file set-file-contents
    file exists? file assert-eq
    file file-contents "this is a test" assert=

    file delete-file assert-true
    file exists? assert-false ;

set-file-contents-test-1

test: stream-output-column-test-1
    "delete-me" :> file
    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    file file-open-append :> stream
    stream dup output-stream? assert-eq
    stream stream-output-column 0 assert-eq

    "this is a test" stream stream-write-string
    stream stream-output-column 14 assert-eq

    " and this is another test" stream stream-write-string
    stream stream-output-column 39 assert-eq

    stream stream-nl
    stream stream-output-column 0 assert-eq

    "one more" stream stream-write-string
    stream stream-output-column 8 assert-eq

    stream stream-?nl
    stream stream-output-column 0 assert-eq

    "last one" stream stream-write-string-escaped
    stream stream-output-column 0 assert-eq

    stream stream-nl
    stream stream-output-column 0 assert-eq

    'a' stream stream-write-char
    stream stream-output-column 1 assert-eq
    'b' stream stream-write-char
    stream stream-output-column 2 assert-eq
    'c' stream stream-write-char
    stream stream-output-column 3 assert-eq
    '\n' stream stream-write-char
    stream stream-output-column 0 assert-eq

    'x' stream stream-write-char-escaped
    stream stream-output-column 0 assert-eq

    stream close ;

stream-output-column-test-1

test: string-output-stream-test-1
    make-string-output-stream verify-string-output-stream :> stream
    stream string-output-stream? assert-true
    "this is a test" stream string-output-stream-write-string
    stream string-output-stream-output-column 14 assert-eq
    " of course" stream string-output-stream-write-string
    stream string-output-stream-output-column 24 assert-eq
    'r' stream string-output-stream-write-char
    stream string-output-stream-output-column 25 assert-eq
    's' stream string-output-stream-write-char
    stream string-output-stream-output-column 26 assert-eq
    stream string-output-stream-string "this is a test of coursers" assert=
    stream close
;

string-output-stream-test-1

test: string-output-stream-test-2
    make-string-output-stream :> stream
    stream string-output-stream-string "" assert=

    // verify that the stream's sbuf is still valid after gc
    gc
    stream string-output-stream-string "" assert=

    stream close
;

string-output-stream-test-2

test: string-?first-test-1
    { 'B' } [ "Be the best bunny you can be!" string-?first ] unit-test
    { 'a' } [ "a" string-?first ] unit-test
    { f } [ "" string-?first ] unit-test
;

string-?first-test-1

test: string-?last-test-1
    { '!' } [ "Be the best bunny you can be!" string-?last ] unit-test
    { 'z' } [ "z" string-?last ] unit-test
    { f } [ "" string-?last ] unit-test
;

string-?last-test-1

test: find-integer-in-range-test-1
    { 0 } [ 0 100 [ 72 < ] find-integer-in-range ] unit-test
    { 73 } [ 0 100 [ 72 > ] find-integer-in-range ] unit-test
    { 73 } [ -100 100 [ 72 > ] find-integer-in-range ] unit-test
    { -71 } [ -100 100 [ -72 > ] find-integer-in-range ] unit-test
    { 100 } [ 100 1000 [ 72 > ] find-integer-in-range ] unit-test

    { f } [ 0 100 [ 100 eq? ] find-integer-in-range ] unit-test
    { f } [ 100 1000 [ 2000 eq? ] find-integer-in-range ] unit-test

    { f } [ 100 -100 [ 72 > ] find-integer-in-range ] unit-test
;

find-integer-in-range-test-1

test: find-last-integer-in-range-test-1
    { 99 } [ 0 100 [ 72 > ] find-last-integer-in-range ] unit-test
    { 71 } [ 0 100 [ 72 < ] find-last-integer-in-range ] unit-test
    { 71 } [ -100 100 [ 72 < ] find-last-integer-in-range ] unit-test
    { -73 } [ -100 100 [ -72 < ] find-last-integer-in-range ] unit-test
    { 999 } [ 100 1000 [ 72 > ] find-last-integer-in-range ] unit-test

    { f } [ 0 100 [ 100 eq? ] find-last-integer-in-range ] unit-test
    { f } [ 100 1000 [ 2000 eq? ] find-last-integer-in-range ] unit-test

    { f } [ 100 -100 [ 72 > ] find-last-integer-in-range ] unit-test
;

find-last-integer-in-range-test-1

use: accessors

test: tuple-accessors-test-1
    foo make-instance :> x
    { t } [ x foo? ] unit-test

    { f } [ x a>> ] unit-test
    { f } [ x b>> ] unit-test
    { f } [ x c>> ] unit-test

    { } [ 42 x a<< ] unit-test
    { } [ 87 x b<< ] unit-test
    { } [ 17 x c<< ] unit-test

    { 42 } [ x a>> ] unit-test
    { 87 } [ x b>> ] unit-test
    { 17 } [ x c>> ] unit-test

    { } [ x 23 >>a 14 >>b 79 >>c drop ] unit-test

    { 23 } [ x a>> ] unit-test
    { 14 } [ x b>> ] unit-test
    { 79 } [ x c>> ] unit-test
;

tuple-accessors-test-1

test: fixnum-1+-fast-test-1
    most-negative-fixnum 1 + 1array [ most-negative-fixnum fixnum-1+-fast ] unit-test

    { 0 } [ -1 fixnum-1+-fast ] unit-test

    { 1 } [ 0 fixnum-1+-fast ] unit-test
    { 2 } [ 1 fixnum-1+-fast ] unit-test
    { 3 } [ 2 fixnum-1+-fast ] unit-test

    most-positive-fixnum 1array [ most-positive-fixnum 1 - fixnum-1+-fast ] unit-test
;

fixnum-1+-fast-test-1

test: fixnum-2*-fast-test-1
    { -4 } [ -2 fixnum-2*-fast ] unit-test
    { -2 } [ -1 fixnum-2*-fast ] unit-test

    { 0 } [ 0 fixnum-2*-fast ] unit-test

    { 2 } [ 1 fixnum-2*-fast ] unit-test
    { 4 } [ 2 fixnum-2*-fast ] unit-test
    { 6 } [ 3 fixnum-2*-fast ] unit-test ;

fixnum-2*-fast-test-1

test: fixnum-2/-fast-test-1
    // fixnum-2/-fast rounds toward negative infinity (floor)
    // /i rounds toward 0 (truncate)

    { -3 } [ -6 fixnum-2/-fast ] unit-test
    { -2 } [ -4 fixnum-2/-fast ] unit-test
    { -1 } [ -2 fixnum-2/-fast ] unit-test

    // REVIEW -3 2 /i -> -1
    { -2 } [ -3 fixnum-2/-fast ] unit-test

    // REVIEW -1 2 /i -> 0
    { -1 } [ -1 fixnum-2/-fast ] unit-test

    { 0 } [ 0 fixnum-2/-fast ] unit-test

    { 1 } [ 2 fixnum-2/-fast ] unit-test
    { 1 } [ 3 fixnum-2/-fast ] unit-test
    { 2 } [ 4 fixnum-2/-fast ] unit-test
    { 2 } [ 5 fixnum-2/-fast ] unit-test
    { 3 } [ 6 fixnum-2/-fast ] unit-test

    most-positive-fixnum fixnum-2/-fast most-positive-fixnum 2 /i assert-eq
    most-positive-fixnum 1- fixnum-2/-fast most-positive-fixnum 1- 2 /i assert-eq

    most-negative-fixnum fixnum-2/-fast most-negative-fixnum 2 /i assert-eq
    most-negative-fixnum 1+ fixnum-2/-fast 1+ most-negative-fixnum 1+ 2 /i assert-eq ;

fixnum-2/-fast-test-1

test: &&-test-1
    { f } [ { [ 1 ] [ f ] [ 3 ] } && ] unit-test
    { f } [ { [ 1 ] [ f ] [ f assert-true ] } && ] unit-test
    { 3 } [ { [ 1 ] [ 2 ] [ 3 ] } && ] unit-test

    { f } [ { } && ] unit-test

    [ { [ f assert-true 42 ] } && ] assert-must-fail ;

&&-test-1

test: ||-test-1
    { f } [ { [ f ] [ f ] [ f ] } || ] unit-test
    { "ok" } [ { [ 10 string? ] [ "ok" ] [ t assert-false 17 ] } || ] unit-test
    { "ok" } [ { [ "ok" ] [ 10 string? ] [ t assert-false 17 ] } || ] unit-test

    { f } [ { } || ] unit-test

    [ { [ f assert-true 42 ] } || ] assert-must-fail
;

||-test-1

test: as-type-test-1
    string dup type? assert-eq
    string as-type string assert-eq

    string "test" type-of assert-eq

    ' string symbol? assert
    ' string type? assert-false
    ' string as-type dup type? assert-eq
    ' string as-type string assert-eq

    { string } first {
        [ symbol? assert ]
        [ type? assert-false ]
        [ as-type dup type? assert-eq ]
        [ as-type string assert-eq ]
    } cleave

    [ 42 as-type ] assert-must-fail
    [ "string" as-type ] assert-must-fail
;

as-type-test-1

test: string->index-test-1
    { 42 } [ "42" string->index ] unit-test
    { 0 } [ "0" string->index ] unit-test

    most-positive-fixnum number>string string->index most-positive-fixnum assert-eq

    { f } [ "-1" string->index ] unit-test
    { f } [ most-negative-fixnum number>string string->index ] unit-test
    { f } [ "3.14159" string->index ] unit-test
    { f } [ "test" string->index ] unit-test
;

string->index-test-1

global zork-vocab-name "zork" zork-vocab-name!

test: symbol-vocab-name-test-1
    "zork" delete-vocab
    zork-vocab-name ensure-vocab :> v!
    f zork-vocab-name!
    "foo" v <symbol> :> sym
    sym symbol-vocab-name "zork" assert=
    v delete-vocab
    sym symbol-vocab-name "zork" assert=
    f v!
    sym symbol-vocab-name "zork" assert=
    gc
    sym symbol-vocab-name "zork" assert=
;

symbol-vocab-name-test-1

test: file-lines-test-1
    "delete-me" :> file
    { "this" "is" "a" "test" } :> seq

    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    seq file set-file-lines
    file exists? file assert-eq

    file file-contents
    win64? "this\r\nis\r\na\r\ntest\r\n" "this\nis\na\ntest\n" ?
    string=? assert-true

    file file-lines seq sequence= assert-true

    file exists? file assert-eq
    file delete-file assert-true
    file exists? assert-false
;

file-lines-test-1

test: rename-file-test-1
    "delete-me" :> file
    "delete-me~" :> backup
    "this is a test" :> contents1
    "this is another test" :> contents2

    file exists? [ file delete-file assert-true ] when
    file exists? assert-false

    backup exists? [ backup delete-file assert-true ] when
    backup exists? assert-false

    contents1 file set-file-contents
    file exists? file assert-eq
    file file? file assert-eq
    file file-contents contents1 assert=

    file exists? file assert-eq
    backup exists? assert-false

    file backup rename-file assert-true
    file exists? assert-false
    backup exists? backup assert-eq
    backup file-contents contents1 assert=

    backup delete-file assert-true
    backup exists? assert-false

    // attempt to rename a file that does not exist
    file exists? assert-false
    backup exists? assert-false
    file backup rename-file assert-false

    // new name refers to an existing file
    contents1 file set-file-contents
    contents2 backup set-file-contents
    file file? file assert-eq
    file file-contents contents1 assert=
    file file? file assert-eq
    backup file-contents contents2 assert=

    // rename should work
    file backup rename-file assert-true

    file exists? assert-false
    backup file? backup assert-eq
    backup file-contents contents1 assert=

    backup delete-file assert-true
    backup exists? assert-false ;

rename-file-test-1

test: between?-test-1
    { f } [ most-negative-fixnum 3 9 between? ] unit-test
    { f } [ -1 3 9 between? ] unit-test
    { f } [ 0 3 9 between? ] unit-test
    { f } [ 2 3 9 between? ] unit-test
    { t } [ 3 3 9 between? ] unit-test
    { t } [ 4 3 9 between? ] unit-test
    { t } [ 8 3 9 between? ] unit-test
    { t } [ 9 3 9 between? ] unit-test
    { f } [ 10 3 9 between? ] unit-test
    { f } [ most-positive-fixnum 3 9 between? ] unit-test

    { f } [ most-negative-fixnum 3.0 9.0 between? ] unit-test
    { f } [ -1.0 3.0 9.0 between? ] unit-test
    { f } [ 0.1 3.0 9.0 between? ] unit-test
    { f } [ 2.3 3.0 9.0 between? ] unit-test
    { t } [ 3.0 3.0 9.0 between? ] unit-test
    { t } [ 4.7 3.0 9.0 between? ] unit-test
    { t } [ 8.9999 3.0 9.0 between? ] unit-test
    { t } [ 9.0 3.0 9.0 between? ] unit-test
    { f } [ 9.1 3.0 9.0 between? ] unit-test
    { f } [ 10.0 3.0 9.0 between? ] unit-test
    { f } [ most-positive-fixnum 3.0 9.0 between? ] unit-test

    { f } [ 1 3 2 between? ] unit-test
    { f } [ 2 3 2 between? ] unit-test
    { f } [ 3 3 2 between? ] unit-test
;

between?-test-1

test: within?-test-1
    { f } [ most-negative-fixnum 3 9 within? ] unit-test
    { f } [ -1 3 9 within? ] unit-test
    { f } [ 0 3 9 within? ] unit-test
    { f } [ 2 3 9 within? ] unit-test
    { t } [ 3 3 9 within? ] unit-test
    { t } [ 4 3 9 within? ] unit-test
    { t } [ 8 3 9 within? ] unit-test
    { f } [ 9 3 9 within? ] unit-test
    { f } [ 10 3 9 within? ] unit-test
    { f } [ most-positive-fixnum 3 9 within? ] unit-test

    { f } [ most-negative-fixnum 3.0 9.0 within? ] unit-test
    { f } [ -1.0 3.0 9.0 within? ] unit-test
    { f } [ 0.1 3.0 9.0 within? ] unit-test
    { f } [ 2.3 3.0 9.0 within? ] unit-test
    { t } [ 3.0 3.0 9.0 within? ] unit-test
    { t } [ 4.7 3.0 9.0 within? ] unit-test
    { t } [ 8.9999 3.0 9.0 within? ] unit-test
    { f } [ 9.0 3.0 9.0 within? ] unit-test
    { f } [ 9.1 3.0 9.0 within? ] unit-test
    { f } [ 10.0 3.0 9.0 within? ] unit-test
    { f } [ most-positive-fixnum 3.0 9.0 within? ] unit-test

    { f } [ 1 3 2 within? ] unit-test
    { f } [ 2 3 2 within? ] unit-test
    { f } [ 3 3 2 within? ] unit-test
;

within?-test-1

test: +-test-1
    { 129 } [ 42 87 + ] unit-test
    { "not sure" } [ "not " "sure" + ] unit-test

    [ 42 "no good" + ] assert-must-fail
    [ "no good" 42 + ] assert-must-fail
;

+-test-1

: %?exit-test-1
    ?exit 42 ;

test: ?exit-test-1
    { }    [ t %?exit-test-1 ] unit-test
    { 42 } [ f %?exit-test-1 ] unit-test ;

?exit-test-1

: %?exit-test-2 ( x y )
    x 42 = ?exit
    y 87 = ?exit
    x y + ;

test: ?exit-test-2
    { }    [ 42 13 %?exit-test-2 ] unit-test
    { }    [ 13 87 %?exit-test-2 ] unit-test
    { 42 } [ 27 15 %?exit-test-2 ] unit-test ;

?exit-test-2

: %?exit-test-3
    ?exit
    42 :> x
    x x * ;

test: ?exit-test-3
    { 1764 } [ f %?exit-test-3 ] unit-test
    { }      [ t %?exit-test-3 ] unit-test ;

?exit-test-3

: %inner1 t ?exit ;

: %outer1 %inner1 87 ;

test: ?exit-test-4
    { 87 } [ %outer1 ] unit-test ;

?exit-test-4

test: string-append-char-test-1
    { "cats" } [ "cat" 's' string-append-char ] unit-test
;

string-append-char-test-1

test: file-name-directory-test-1

    win64? [

        { "c:\\Users\\peter\\feline\\src" }
        [ "c:\\Users\\peter\\feline\\src\\test.feline" file-name-directory ] unit-test

        { "c:\\Users\\peter\\feline" }
        [ "c:\\Users\\peter\\feline\\src" file-name-directory ] unit-test

        { "c:\\Users\\peter" }
        [ "c:\\Users\\peter\\feline" file-name-directory ] unit-test

        { "c:\\Users" }
        [ "c:\\Users\\peter" file-name-directory ] unit-test

        { "c:\\" }
        [ "c:\\Users" file-name-directory ] unit-test

        { nil } // REVIEW should this be "\\"?
        [ "c:\\" file-name-directory ] unit-test

        { nil }
        [ "c:foo" file-name-directory ] unit-test

        { nil }
        [ "foo" file-name-directory ] unit-test

    ] when

    linux? [

        { "/home/peter/feline/src" }
        [ "/home/peter/feline/src/test.feline" file-name-directory ] unit-test

        { "/home/peter/feline" }
        [ "/home/peter/feline/src" file-name-directory ] unit-test

        { "/home/peter" }
        [ "/home/peter/feline" file-name-directory ] unit-test

        { "/home" }
        [ "/home/peter" file-name-directory ] unit-test

        { "/" }
        [ "/home" file-name-directory ] unit-test

        { "/" }
        [ "/" file-name-directory ] unit-test

        { nil }
        [ "foo" file-name-directory ] unit-test

    ] when ;

file-name-directory-test-1

test: tilde-expand-filename-test-1
    linux? [
        "foo" tilde-expand-filename "foo" assert=
        "/" tilde-expand-filename "/" assert=
        "~/" tilde-expand-filename user-home "/" + assert=
        "~/foo" tilde-expand-filename user-home "foo" path-append assert=
    ] when ;

tilde-expand-filename-test-1

test: both?-test
    { 42 } [ [ true ] [ 42 ] both? ] unit-test
    { 1 2 3 4 42 } [ 1 2 3 4 [ true ] [ 42 ] both? ] unit-test

    { nil } [ [ true ] [ nil ]  both? ] unit-test
    { 1 2 3 4 nil }  [ 1 2 3 4 [ true ] [ nil ]  both? ] unit-test

    87 !> x

    { nil } [ [ x ] [ 93 x! nil ] both? ] unit-test
    x 93 assert-eq

    { nil } [ [ 71 x! nil ] [ 97 x! nil ] both? ] unit-test
    x 71 assert-eq ;

both?-test

test: either?-test
    { 42 } [ [ nil ] [ 42 ] either? ] unit-test
    { 1 2 3 4 42 } [ 1 2 3 4 [ nil ] [ 42 ] either? ] unit-test

    { true } [ [ nil ] [ true ]  either? ] unit-test
    { 1 2 3 4 true }  [ 1 2 3 4 [ nil ] [ true ]  either? ] unit-test

    87 !> x

    { 87 } [ [ x ] [ 93 x! ] either? ] unit-test
    x 87 assert-eq

    { nil } [ [ 71 x! nil ] [ 97 x! nil ] either? ] unit-test
    x 97 assert-eq ;

either?-test

test: string-trim-head-test-1
    { "" } [ "" string-trim-head ] unit-test
    { "" } [ "     " string-trim-head ] unit-test
    { "foo bar" } [ "foo bar" string-trim-head ] unit-test
    { "foo bar" } [ " foo bar" string-trim-head ] unit-test
    { "foo bar  " } [ "foo bar  " string-trim-head ] unit-test
    { "foo bar    " } [ "   foo bar    " string-trim-head ] unit-test
;

string-trim-head-test-1

test: string-trim-tail-test-1
    { "" } [ "" string-trim-tail ] unit-test
    { "" } [ "     " string-trim-tail ] unit-test
    { "foo bar" } [ "foo bar" string-trim-tail ] unit-test
    { " foo bar" } [ " foo bar" string-trim-tail ] unit-test
    { "foo bar" } [ "foo bar  " string-trim-tail ] unit-test
    { "   foo bar" } [ "   foo bar    " string-trim-tail ] unit-test
;

string-trim-tail-test-1

test: string-trim-test-1
    { "" } [ "" string-trim ] unit-test
    { "" } [ "     " string-trim ] unit-test
    { "foo bar" } [ "foo bar" string-trim ] unit-test
    { "foo bar" } [ " foo bar" string-trim ] unit-test
    { "foo bar" } [ "foo bar " string-trim ] unit-test
    { "foo bar" } [ "   foo bar    " string-trim ] unit-test
;

string-trim-test-1

test: 0>-test-1
    1 0> assert
    2 0> assert
    most-positive-fixnum 0> assert
    most-positive-fixnum 1- 0> assert

    [ most-positive-fixnum 1 + 0> ] assert-must-fail // not a fixnum

    0 0> assert-false
    -1 0> assert-false
    -2 0> assert-false
    most-negative-fixnum 0> assert-false
    most-negative-fixnum 1+ 0> assert-false

    [ most-negative-fixnum 1 - 0> ] assert-must-fail // not a fixnum
;

0>-test-1

test: 0<-test-1
    -1 0< assert
    -2 0< assert
    most-negative-fixnum 0< assert
    most-negative-fixnum 1+ 0< assert

    [ most-negative-fixnum 1 - 0< ] assert-must-fail // not a fixnum

    0 0< assert-false
    1 0< assert-false
    2 0< assert-false
    most-positive-fixnum 0< assert-false
    most-positive-fixnum 1- 0< assert-false

    [ most-positive-fixnum 1 + 0< ] assert-must-fail // not a fixnum
;

0<-test-1

test: 0?-test-1
    0 0? assert

    1 0? assert-false
    most-positive-fixnum 0? assert-false

    -1 0? assert-false
    most-negative-fixnum 0? assert-false

    // not a fixnum
    [ most-positive-fixnum 1 + 0? ] assert-must-fail
    [ most-negative-fixnum 1 - 0? ] assert-must-fail
    [ 0.0 0? ] assert-must-fail
;

0?-test-1

test: 1+-test-1
    -1 1+ 0? assert
    0 1+ 1 assert-eq
    1 1+ 2 assert-eq

    10 [ dup 1+ swap 1 + assert-eq ] each-integer

    most-positive-fixnum dup 1 - 1+ assert-eq
    most-negative-fixnum dup 1+ 1 - assert-eq

    [ most-positive-fixnum 1+ ] assert-must-fail // overflow
;

1+-test-1

test: 1--test-1
    1 1- 0? assert
    0 1- -1 assert-eq
    -1 1- -2 assert-eq

    10 [ dup 1- swap 1 - assert-eq ] each-integer

    most-positive-fixnum dup 1- 1 + assert-eq
    most-negative-fixnum dup 1 + 1- assert-eq

    [ most-negative-fixnum 1- ] assert-must-fail // overflow
;

1--test-1

test: string-upcase-test-1
    { "THIS IS A TEST" } [ "this is a test" string-upcase ] unit-test
    { "1234567890TEST" } [ "1234567890test" string-upcase ] unit-test
    { "THIS IS A TEST" } [ "THIS IS A TEST" string-upcase ] unit-test

    // argument is always copied
    "THIS IS A TEST" dup string-upcase eq? assert-false

    "THIS IS A TEST" dup string-upcase string-equal? assert
;

string-upcase-test-1

test: pad-left-test-1
    { "42" } [ '0' 0 "42" pad-left ] unit-test
    { "42" } [ '0' 1 "42" pad-left ] unit-test
    { "42" } [ '0' 2 "42" pad-left ] unit-test
    { "042" } [ '0' 3 "42" pad-left ] unit-test
    { "0042" } [ '0' 4 "42" pad-left ] unit-test
    { "  42" } [ '\s' 4 "42" pad-left ] unit-test ;

pad-left-test-1

defer message

: hello "hello!" ;

: goodbye "goodbye!" ;

test: defer-test-1
    [ message ] assert-must-fail

    ' hello ' message defer!
    message hello assert-eq
    ' goodbye ' message defer!
    message goodbye assert-eq
    ' hello ' message defer!
    message hello assert-eq

    ' hello is message
    message hello assert-eq
    ' goodbye is message
    message goodbye assert-eq
    ' hello is message
    message hello assert=

    [ ' message ' message defer! ] assert-must-fail
    [ ' message is message ] assert-must-fail ;

defer-test-1

defer message2

[ message2 ] assert-must-fail

' hello ' message2 defer!
message2 hello assert-eq
' goodbye ' message2 defer!
message2 goodbye assert-eq
' hello ' message2 defer!
message2 hello assert-eq

' hello is message2
message2 hello assert-eq
' goodbye is message2
message2 goodbye assert-eq
' hello is message2
message2 hello assert-eq

[ ' message2 ' message2 defer! ] assert-must-fail
[ ' message2 is message2 ] assert-must-fail

test: find-integer-test
    { 5 } [ 10 [ 5 eq? ] find-integer ] unit-test

    { 87 19 5 } [ 87 19 10 [ 5 eq? ] find-integer ] unit-test

    { 19 87 87 } [ 19 87 100 [ over eq? ] find-integer ] unit-test

    { nil } [ 0 [ "shouldn't happen!" error ] find-integer ] unit-test
    { nil } [ -7 [ "shouldn't happen!" error ] find-integer ] unit-test
;

find-integer-test

test: string-find-char-from-index-test
    "this is only a test" :> s
    { 0 } [ 0 't' s string-find-char-from-index ] unit-test
    { 15 } [ 1 't' s string-find-char-from-index ] unit-test
    { 18 } [ 16 't' s string-find-char-from-index ] unit-test
    { 3 } [ 3 's' s string-find-char-from-index ] unit-test

    { nil } [ s length 't' s string-find-char-from-index ] unit-test
    { nil } [ most-positive-fixnum 't' s string-find-char-from-index ] unit-test

    { 10 } [ 0 'k' "abcdefghijk" string-find-char-from-index ] unit-test

    { nil } [ 0 'x' "" string-find-char-from-index ] unit-test
    { 0 } [ 0 'x' "x" string-find-char-from-index ] unit-test

    [ -1 'x' "x" string-find-char-from-index ] assert-must-fail
    [ 0 "test" "test" string-find-char-from-index ] assert-must-fail
    [ 0 'x' { 'x' 'y' } string-find-char-from-index ] assert-must-fail ;

string-find-char-from-index-test

"ABCDEFGHIJKLMNOPQRSTUVWXYZ" constant upper-case-chars

"abcdefghijklmnopqrstuvwxyz" constant lower-case-chars

test: char-downcase-test
    26 <sbuf> :> sb
    local char

    { } [
        lower-case-chars [ dup char-downcase assert-eq ] each

        upper-case-chars [ char-downcase sb push ] each
        sb sbuf>string lower-case-chars assert=

        128 [
            code-char char!
            char char-upper-case? [ char dup char-downcase assert-eq ] unless
        ] each-integer
    ] unit-test ;

char-downcase-test

test: char-upcase-test
    26 <sbuf> :> sb
    local char

    { } [
        upper-case-chars [ dup char-upcase assert-eq ] each

        lower-case-chars [ char-upcase sb push ] each
        sb sbuf>string upper-case-chars assert=

        128 [
            code-char char!
            char char-lower-case? [ char dup char-upcase assert-eq ] unless
        ] each-integer
    ] unit-test ;

char-upcase-test

test: char-lower-case?-test
    { } [
        upper-case-chars [ char-lower-case? assert-false ] each

        // char-lower-case? returns the char itself instead of true
        lower-case-chars [ dup char-lower-case? assert-eq ] each

        // chars before 'a' are not lower case
        'a' char-code 97 assert-eq
        97 [ code-char char-lower-case? assert-false ] each-integer

        // chars after 'z' are not lower case
        'z' char-code 122 assert-eq
        5 [ 123 + code-char char-lower-case? assert-false ] each-integer
    ] unit-test ;

char-lower-case?-test

test: char-upper-case?-test
    { } [
        lower-case-chars [ char-upper-case? assert-false ] each

        // char-upper-case? returns the char itself instead of true
        upper-case-chars [ dup char-upper-case? assert-eq ] each

        // chars before 'A' are not upper case
        'A' char-code 65 assert-eq
        65 [ code-char char-upper-case? assert-false ] each-integer

        // chars after 'Z' are not upper case
        'Z' char-code 90 assert-eq
        37 [ 91 + code-char char-upper-case? assert-false ] each-integer
    ] unit-test ;

char-upper-case?-test

test: when-test
    { 14 } [ 89 [ 14 ] when ] unit-test
    { 1 2 3 14 } [ 1 2 3 89 [ 14 ] when ] unit-test
    { 1 2 3 14 } [ 1 2 3 true [ 14 ] when ] unit-test
    { 1 2 3 14 } [ 1 2 3 "test" [ 14 ] when ] unit-test
    { 1 2 3 } [ 1 2 3 nil [ 14 ] when ] unit-test
    { 1 2 14 } [ 1 2 3 odd? [ 14 ] when ] unit-test
    { 1 2 } [ 1 2 3 even? [ 14 ] when ] unit-test ;

when-test

test: when*-test
    { 90 } [ 89 [ 1+ ] when* ] unit-test
    { 1 2 3 90 } [ 1 2 3 89 [ 1+ ] when* ] unit-test
    { 89 14 } [ 89 [ 14 ] when* ] unit-test
    { 89 14 } [ 89 odd? [ 14 ] when* ] unit-test
    { } [ 89 even? [ 14 ] when* ] unit-test ;

when*-test

test: if-test
    { 42 } [ true [ 42 ] [ 17 ] if ] unit-test
    { 1 2 3 4 42 } [ 1 2 3 4 true [ 42 ] [ 17 ] if ] unit-test

    { 17 } [ nil [ 42 ] [ 17 ] if ] unit-test
    { 1 2 3 4 17 } [ 1 2 3 4 nil [ 42 ] [ 17 ] if ] unit-test

    { 42 } [ 0 [ 42 ] [ 17 ] if ] unit-test
    { 1 2 3 4 42 } [ 1 2 3 4 0 [ 42 ] [ 17 ] if ] unit-test ;

if-test

test: if*-test
    { t 42 } [ true [ 42 ] [ 17 ] if* ] unit-test
    { 1 2 3 4 t 42 } [ 1 2 3 4 true [ 42 ] [ 17 ] if* ] unit-test

    { 17 } [ nil [ 42 ] [ 17 ] if* ] unit-test
    { 1 2 3 4 17 } [ 1 2 3 4 nil [ 42 ] [ 17 ] if* ] unit-test

    { 0 42 } [ 0 [ 42 ] [ 17 ] if* ] unit-test
    { 1 2 3 4 0 42 } [ 1 2 3 4 0 [ 42 ] [ 17 ] if* ] unit-test ;

if*-test

test: dip-test
    { 261 42 } [ 87 42 [ 3 * ] dip ] unit-test ;

dip-test

test: 2dip-test
    { 43 17 89 } [ 42 17 89 [ 1+ ] 2dip ] unit-test ;

2dip-test

test: keep-test
    { 1 2 4 3 } [ 1 2 3 [ 1+ ] keep ] unit-test ;

keep-test

test: bi-test
    { 43 44 } [ 42 [ 1 + ] [ 2 + ] bi ] unit-test
    { 1 2 3 4 43 44 } [ 1 2 3 4 42 [ 1 + ] [ 2 + ] bi ] unit-test
    { 42 13 42 17 } [ 42 [ 13 ] [ 17 ] bi ] unit-test
    { 1 2 3 4 42 13 42 17 } [ 1 2 3 4 42 [ 13 ] [ 17 ] bi ] unit-test
    { } [ 42 [ drop ] [ drop ] bi ] unit-test
    { 1 2 3 4 } [ 1 2 3 4 42 [ drop ] [ drop ] bi ] unit-test ;

bi-test

test: 2bi-test-1
    clear
    1 2 3 4 [ dup ] [ + ] 2bi get-datastack { 1 2 3 4 4 7 } sequence= assert-true
    clear
    1 2 3 4 [ nip ] [ + ] 2bi get-datastack { 1 2 4 7 } sequence= assert-true
    clear
;

2bi-test-1

test: bi@-test
    { 1 2 4 5 } [ 1 2 3 4 [ 1+ ] bi@ ] unit-test
    { 1 2 3 3 4 4 } [ 1 2 3 4 [ dup ] bi@ ] unit-test
    { 1 2 } [ 1 2 3 4 [ drop ] bi@ ] unit-test
    { } [ 1 2 [ drop ] bi@ ] unit-test ;

bi@-test

test: fixnum-hashtable-test
    1000 :> count
    count make-fixnum-hashtable :> ht
    { } [
        ht fixnum-hashtable-capacity 1024 assert-eq
        ht fixnum-hashtable-occupancy 0? assert
        ht fixnum-hashtable-deletions 0? assert

        count [ dup 17 + swap ht fixnum-hashtable-set-at ] each-integer

        ht fixnum-hashtable-capacity 2048 assert-eq
        ht fixnum-hashtable-occupancy count assert-eq
        ht fixnum-hashtable-deletions 0? assert

        count [ dup ht fixnum-hashtable-at 17 - assert-eq ] each-integer

        ht fixnum-hashtable-capacity 2048 assert-eq
        ht fixnum-hashtable-occupancy count assert-eq
        ht fixnum-hashtable-deletions 0? assert

        ht grow-fixnum-hashtable

        ht fixnum-hashtable-capacity 4096 assert-eq
        ht fixnum-hashtable-occupancy count assert-eq
        ht fixnum-hashtable-deletions 0? assert

        count [ dup ht fixnum-hashtable-at 17 - assert-eq ] each-integer
    ] unit-test ;

fixnum-hashtable-test

test: fixnum-hashtable-test-2
    10 :> count
    count make-fixnum-hashtable :> ht
    { } [

        ht fixnum-hashtable-capacity 16 assert-eq
        ht fixnum-hashtable-occupancy 0? assert
        ht fixnum-hashtable-deletions 0? assert

        "foo" 42 ht fixnum-hashtable-set-at
        42 ht fixnum-hashtable-at "foo" assert=

        "bar" 42 ht fixnum-hashtable-set-at
        42 ht fixnum-hashtable-at "bar" assert=

        // negative key
        "zork" -87 ht fixnum-hashtable-set-at
        -87 ht fixnum-hashtable-at "zork" assert=

        "high" most-positive-fixnum ht fixnum-hashtable-set-at
        most-positive-fixnum ht fixnum-hashtable-at "high" assert=

        "low" most-negative-fixnum ht fixnum-hashtable-set-at
        most-negative-fixnum ht fixnum-hashtable-at "low" assert=

    ] unit-test ;

fixnum-hashtable-test-2

test: fixnum-hashtable-deletion-test
    10 :> count
    count make-fixnum-hashtable :> ht
    { } [
        ht fixnum-hashtable-capacity 16 assert-eq
        ht fixnum-hashtable-occupancy 0? assert
        ht fixnum-hashtable-deletions 0? assert

        "foo" 42 ht fixnum-hashtable-set-at

        ht fixnum-hashtable-occupancy 1 assert-eq
        ht fixnum-hashtable-deletions 0? assert
        42 ht fixnum-hashtable-at "foo" assert=

        "bar" 87 ht fixnum-hashtable-set-at

        ht fixnum-hashtable-occupancy 2 assert-eq
        ht fixnum-hashtable-deletions 0? assert
        87 ht fixnum-hashtable-at "bar" assert=

        42 ht fixnum-hashtable-delete-at

        ht fixnum-hashtable-occupancy 2 assert-eq
        ht fixnum-hashtable-deletions 1 assert-eq
        42 ht fixnum-hashtable-at nil? assert

        87 ht fixnum-hashtable-delete-at

        ht fixnum-hashtable-occupancy 2 assert-eq
        ht fixnum-hashtable-deletions 2 assert-eq
        87 ht fixnum-hashtable-at nil? assert

        6 ht fixnum-hashtable-at nil? assert // key not found
        6 ht fixnum-hashtable-delete-at // no error
        6 ht fixnum-hashtable-at nil? assert // still not found

        ht fixnum-hashtable-occupancy 2 assert-eq
        ht fixnum-hashtable-deletions 2 assert-eq

        "foo" 42 ht fixnum-hashtable-set-at

        ht fixnum-hashtable-occupancy 3 assert-eq
        ht fixnum-hashtable-deletions 2 assert-eq
        42 ht fixnum-hashtable-at "foo" assert=

        ht grow-fixnum-hashtable

        ht fixnum-hashtable-capacity 32 assert-eq
        ht fixnum-hashtable-occupancy 1 assert-eq
        ht fixnum-hashtable-deletions 0? assert

        42 ht fixnum-hashtable-at "foo" assert=
    ] unit-test ;

fixnum-hashtable-deletion-test

test: fixnum-hashtable-gc-test
    10 :> count
    count make-fixnum-hashtable :> ht
    count [ dup fixnum>string swap ht fixnum-hashtable-set-at ] each-integer
    count [ dup ht fixnum-hashtable-at swap fixnum>string assert= ] each-integer
    gc
    count [ dup ht fixnum-hashtable-at swap fixnum>string assert= ] each-integer ;

fixnum-hashtable-gc-test

test: odd?-test // odd? returns its argument if its argument is not nil
    { } [
        most-negative-fixnum odd? assert-false
        most-negative-fixnum 1+ odd? assert
        most-negative-fixnum 1+ odd? most-negative-fixnum 1+ assert-eq
        -1 odd? assert
        -1 odd? -1 assert-eq
        0 odd? assert-false
        1 odd? assert
        1 odd? 1 assert-eq
        most-positive-fixnum odd? assert
        most-positive-fixnum odd? most-positive-fixnum assert-eq
        most-positive-fixnum 1- odd? assert-false
    ] unit-test
;

odd?-test

test: even?-test // even? returns its argument if its argument is not nil
    { } [
        most-negative-fixnum even? assert
        most-negative-fixnum even? most-negative-fixnum assert-eq
        most-negative-fixnum 1+ even? assert-false
        -1 even? assert-false
        0 even? assert
        0 even? 0 assert-eq
        1 even? assert-false
        most-positive-fixnum even? assert-false
        most-positive-fixnum 1- even? assert
        most-positive-fixnum 1- even? most-positive-fixnum 1- assert-eq
    ] unit-test
;

even?-test

test: check-bounds-test
    "this is a test" :> s
    0 s check-bounds s assert-eq 0 assert-eq
    1 s check-bounds s assert-eq 1 assert-eq
    13 s check-bounds s assert-eq 13 assert-eq

    [ most-negative-fixnum s check-bounds ] assert-must-fail
    [ -1 s check-bounds ] assert-must-fail
    [ 14 s check-bounds ] assert-must-fail
    [ most-positive-fixnum s check-bounds ] assert-must-fail

    [ "test" s check-bounds ] assert-must-fail ;

check-bounds-test

test: string=?-test
    { true } [ "test" "test" string=? ] unit-test
    { nil } [ "text" "test" string=? ] unit-test
    { nil } [ "test" "text" string=? ] unit-test
    { nil } [ "test" "Test" string=? ] unit-test
    { nil } [ "Test" "test" string=? ] unit-test
    { nil } [ "tesT" "test" string=? ] unit-test
    { nil } [ "test" "tesT" string=? ] unit-test
    { nil } [ "test" "testx" string=? ] unit-test
    { nil } [ "testx" "test" string=? ] unit-test

    { true } [ "this is a longer test" "this is a longer test" string=? ] unit-test
    { nil } [ "this is a longer test" "this is a longer text" string=? ] unit-test
    { nil } [ "this is a longer text" "this is a longer test" string=? ] unit-test

    { true } [ "" "" string=? ] unit-test
    { nil } [ "test" "" string=? ] unit-test
    { nil } [ "" "test" string=? ] unit-test ;

string=?-test

test: string-ci=?-test
    { true } [ "test" "test" string-ci=? ] unit-test
    { nil } [ "text" "test" string-ci=? ] unit-test
    { nil } [ "test" "text" string-ci=? ] unit-test
    { true } [ "test" "Test" string-ci=? ] unit-test
    { true } [ "Test" "test" string-ci=? ] unit-test
    { true } [ "tesT" "test" string-ci=? ] unit-test
    { true } [ "test" "tesT" string-ci=? ] unit-test
    { nil } [ "test" "testx" string-ci=? ] unit-test
    { nil } [ "testx" "test" string-ci=? ] unit-test

    { true } [ "this is a longer test" "this is a longer test" string=? ] unit-test
    { nil } [ "this is a longer test" "this is a longer text" string=? ] unit-test
    { nil } [ "this is a longer text" "this is a longer test" string=? ] unit-test

    { true } [ "this is a LONGER test" "this is a LoNgEr test" string-ci=? ] unit-test
    { nil } [ "this is a LOXGER test" "this is a LoNgEr test" string-ci=? ] unit-test
    { nil } [ "this is a longer test" "this is a longer text" string-ci=? ] unit-test
    { nil } [ "this is a longer teSt" "this is a longer teXt" string-ci=? ] unit-test
    { nil } [ "this is a longer text" "this is a longer test" string-ci=? ] unit-test
    { nil } [ "this is a longer teXt" "this is a longer teSt" string-ci=? ] unit-test

    { true } [ "" "" string-ci=? ] unit-test
    { nil } [ "test" "" string-ci=? ] unit-test
    { nil } [ "" "test" string-ci=? ] unit-test ;

string-ci=?-test

test: tokenize-test
    { vector{ "x" } } [ "x" tokenize  ] unit-test
    { vector{ "x" } } [ " x " tokenize  ] unit-test
    { vector{ "x" } } [ " x" tokenize  ] unit-test
    { vector{ "x" } } [ "x " tokenize  ] unit-test

    { vector{ "test" } } [ "test" tokenize  ] unit-test
    { vector{ "test" } } [ " test " tokenize  ] unit-test
    { vector{ "test" } } [ " test" tokenize  ] unit-test
    { vector{ "test" } } [ "test " tokenize  ] unit-test

    { vector{ "this" "is" "a" "test" } } [ "this is a test" tokenize ] unit-test

    { nil } [ "" tokenize ] unit-test
    { nil } [ " " tokenize ] unit-test
    { nil } [ "    " tokenize ] unit-test
;

tokenize-test

test: array-set-nth-test
    10 make-array/1 :> a
    { } [
        10 [ [ number>string ] keep a array-set-nth ] each-integer
        a [ number>string assert= ] each-index

        [ -1 -1 a array-set-nth ] assert-must-fail
        [ -1 most-negative-fixnum a array-set-nth ] assert-must-fail
        [ 87 10 a array-set-nth ] assert-must-fail
        [ 87 most-positive-fixnum a array-set-nth ] assert-must-fail

        [ array-set-nth ] assert-must-fail
    ] unit-test
;

array-set-nth-test

test: string-validate-slice-test
    {  0  4 "this is a test" } [  0  4 "this is a test" string-validate-slice ] unit-test
    {  2  7 "this is a test" } [  2  7 "this is a test" string-validate-slice ] unit-test
    {  0  0 "this is a test" } [  0  0 "this is a test" string-validate-slice ] unit-test
    {  0 14 "this is a test" } [  0 14 "this is a test" string-validate-slice ] unit-test
    { 14 14 "this is a test" } [ 14 14 "this is a test" string-validate-slice ] unit-test
    { } [
        [ 0 4 14 string-validate-slice ] assert-must-fail
        [ 'a'  14 "this is a test" string-validate-slice ] assert-must-fail
        [ 14  'a' "this is a test" string-validate-slice ] assert-must-fail
        [ -1   14 "this is a test" string-validate-slice ] assert-must-fail
        [  1  -14 "this is a test" string-validate-slice ] assert-must-fail
        [  0   15 "this is a test" string-validate-slice ] assert-must-fail
        [  4    0 "this is a test" string-validate-slice ] assert-must-fail
    ] unit-test ;

string-validate-slice-test

symbol: kablooey

: %match-test-1
    match {
        0 => [ "zero" ]
        1 => [ "one" ]
        2 => [ "two" ]
        -1 => [ "minus one" ]
        :keyword => [ "KEYWORD" ]
        "tabouli" => [ "TABOULI" ]
        kablooey => [ "KABLOOEY" ]
        _ => [ "none of the above" ]
    } ;

test: match-test-1
    { "zero" } [ 0 %match-test-1 ] unit-test
    { "one" } [ 1 %match-test-1 ] unit-test
    { "two" } [ 2 %match-test-1 ] unit-test
    { "minus one" } [ -1 %match-test-1 ] unit-test
    { "KEYWORD" } [ :keyword %match-test-1 ] unit-test
    { "TABOULI" } [ "tabouli" %match-test-1 ] unit-test
    { "KABLOOEY" } [ kablooey %match-test-1 ] unit-test
    { "none of the above" } [ "I'm not there!" %match-test-1 ] unit-test ;

match-test-1

: %match-test-2
    match {
        0 => [ "zero" ]
        1 => [ "one" ]
        2 => [ "two" ]
        -1 => [ "minus one" ]
        :keyword => [ "KEYWORD" ]
        "tabouli" => [ "TABOULI" ]
        kablooey => [ "KABLOOEY" ]
        // no default
    } ;

test: match-test-2
    { "zero" } [ 0 %match-test-2 ] unit-test
    { "one" } [ 1 %match-test-2 ] unit-test
    { "two" } [ 2 %match-test-2 ] unit-test
    { "minus one" } [ -1 %match-test-2 ] unit-test
    { "KEYWORD" } [ :keyword %match-test-2 ] unit-test
    { "TABOULI" } [ "tabouli" %match-test-2 ] unit-test
    { "KABLOOEY" } [ kablooey %match-test-2 ] unit-test

    [ "I'm not there!" %match-test-2 ] assert-must-fail ;

match-test-2

test: bit-array-test
    [ -1 make-bit-array ] assert-must-fail

    37 :> len
    len make-bit-array verify-bit-array :> arr

    arr bit-array? arr assert-eq

    { } [ len [ arr nth 0? assert ] each-integer ] unit-test

    [ most-negative-fixnum arr nth ] assert-must-fail
    [ -1 arr nth ] assert-must-fail
    [ len arr nth ] assert-must-fail
    [ len 1+ arr nth ] assert-must-fail

    // nth
    { 0 } [ 0 arr nth ] unit-test
    { 0 } [ 1 arr nth ] unit-test
    { 0 } [ len 2 - arr nth ] unit-test
    { 0 } [ len 1- arr nth ] unit-test

    // nth-unsafe
    { 0 } [ 0 arr nth-unsafe ] unit-test
    { 0 } [ 1 arr nth-unsafe ] unit-test
    { 0 } [ len 2 - arr nth-unsafe ] unit-test
    { 0 } [ len 1- arr nth-unsafe ] unit-test

    { } [ len [ arr set-bit ] each-integer ] unit-test
    { } [ len [ arr nth 1 assert-eq ] each-integer ] unit-test

    { 1 } [ 0 arr nth ] unit-test
    { 1 } [ 1 arr nth ] unit-test
    { 1 } [ len 2 - arr nth ] unit-test
    { 1 } [ len 1- arr nth ] unit-test
;

bit-array-test

test: &+-test
    { 3 } [ 1 2 &+ ] unit-test
    { 3 } [ 2 1 &+ ] unit-test
    { -1 } [ 1 -2 &+ ] unit-test
    { -1 } [ -2 1 &+ ] unit-test
    { 4611686018427387903 } [ 0 most-positive-fixnum &+ ] unit-test
    { 4611686018427387903 } [ most-positive-fixnum 0 &+ ] unit-test
    { -1 } [ most-negative-fixnum most-positive-fixnum &+ ] unit-test
    { -1 } [ most-positive-fixnum most-negative-fixnum &+ ] unit-test

    [ most-positive-fixnum 1 &+ ] assert-must-fail
    [ 1 most-positive-fixnum &+ ] assert-must-fail
;

&+-test

test: &--test
    { -1 } [ 1 2 &- ] unit-test
    { 1 } [ 2 1 &- ] unit-test
    { 3 } [ 1 -2 &- ] unit-test
    { -3 } [ -2 1 &- ] unit-test
    { -4611686018427387903 } [ 0 most-positive-fixnum &- ] unit-test
    { -4611686018427387902 } [ 1 most-positive-fixnum &- ] unit-test
    { 4611686018427387903 } [ most-positive-fixnum 0 &- ] unit-test
    { 4611686018427387902 } [ most-positive-fixnum 1 &- ] unit-test
    { 1 } [ most-positive-fixnum dup 1- &- ] unit-test
    { 0 } [ most-positive-fixnum dup &- ] unit-test
    { -4611686018427387903 } [ most-negative-fixnum -1 &- ] unit-test
    { 4611686018427387903 } [ -1 most-negative-fixnum &- ] unit-test

    [ most-negative-fixnum 1 &- ] assert-must-fail
;

&--test

test: alphanumeric?-test
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" :> s

    s [ alphanumeric? assert ] each

    128 [
        code-char dup s member-eq? [
            alphanumeric? assert
        ] [
            alphanumeric? assert-false
        ] if
    ] each-integer ;

alphanumeric?-test

test: u8?-test
    { } [
        256 [ dup u8? assert-eq ] each-integer
        -1 u8? assert-false
        257 u8? assert-false
        most-positive-fixnum u8? assert-false
        most-negative-fixnum u8? assert-false
        "test" u8? assert-false
    ] unit-test ;

u8?-test

test: verify-u8-test
    { } [
        256 [ dup verify-u8 assert-eq ] each-integer
        [ -1 verify-u8 ] assert-must-fail
        [ 257 verify-u8 ] assert-must-fail
        [ most-positive-fixnum verify-u8 ] assert-must-fail
        [ most-negative-fixnum verify-u8 ] assert-must-fail
        [ "test" verify-u8 ] assert-must-fail
    ] unit-test ;

verify-u8-test

test: byte-vector-test
    { } [
        5 make-byte-vector verify-byte-vector :> v
        v dup byte-vector? assert-eq
        v byte-vector-capacity 16 assert-eq
        v length 0? assert
        [ 0 v nth ] assert-must-fail
        1 v push
        v byte-vector-capacity 16 assert-eq
        v length 1 assert-eq
        0 v nth 1 assert-eq
        0 v nth-unsafe 1 assert-eq

        [ 256 v push ] assert-must-fail
        [ -1 v push ] assert-must-fail

        255 v push
        v byte-vector-capacity 16 assert-eq
        v length 2 assert-eq
        0 v nth 1 assert-eq
        0 v nth-unsafe 1 assert-eq
        1 v nth 255 assert-eq
        1 v nth-unsafe 255 assert-eq

        v byte-vector-capacity 16 assert-eq
        v length 2 assert-eq

        100 23 v set-nth
        23 v nth 100 assert-eq

        0 v nth 1 assert-eq
        1 v nth 255 assert-eq
        21 [ 2 + v nth 0 assert-eq ] each-integer // 2..<23
        22 v nth 0 assert-eq
        23 v nth 100 assert-eq
        v byte-vector-capacity 32 assert-eq
        v length 24 assert-eq
    ] unit-test ;

byte-vector-test

?nl "Reached end of test.feline" write-string
