// Copyright (C) 2016 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

LANGUAGE: feline

USING: feline ;
IN: feline

: display-help ( content -- )
    nl 4 spaces first write
;

: help ( symbol -- )
    dup symbol-help dup                 // -- symbol content/f content/f
    [ ?nl swap symbol-name write display-help ]
    [ 2drop ]
    if
;

: :h ( -- )
    parse-token
    [ find-name [ help ] [ drop ] if ]
    when*
;

HELP: 1array
    "( x -- array )
    Create a new array with one element: { x }."
;

HELP: 2array
    "( x y -- array )
    Create a new array with two elements: { x y }."
;

HELP: 2bi
    "( x y quot1 quot2 -- )
    Apply quot1 to x and y, then apply quot2 to x and y."
;

HELP: 2dip
    "( x y quot -- x y )
    Remove x and y from the stack, call quot, and restore x and y
    to the top of the stack when quot returns."
;

HELP: 2keep
    "( x y quot -- x y )
    Call quot with x and y on the stack. Restore x and y to the
    top of the stack when quot returns."
;

HELP: 2nip
    "( x y z -- z )
    Remove x and y from the stack."
;

HELP: 3array
    "( x y z -- array )
    Create a new array with three elements: { x y z }."
;

HELP: 4array
    "( w x y z -- array )
    Create a new array with four elements: { w x y z }."
;

HELP: <array>
    "( n elt -- array )
    Create a new array with length n and all elements initially
    set to elt."
;

HELP: <range>
    "( start len -- range )
    Create a new immutable virtual sequence containing the
    integers from start to start+len-1."
;

HELP: <vector>
    "( n -- vector )
    Create a new vector with an initial capacity of n elements."
;

HELP: and
    "( obj1 obj2 -- ? )
    Boolean and: if both obj1 and obj2 are true (that is, not f),
    return obj2. Otherwise return f. (Bitwise and is bitand.)"
;

HELP: bi
    "( x quot1 quot2 -- )
    Apply quot1 to x, then apply quot2 to x."
;

HELP: dip
    "( x quot -- x )
    Remove x from the stack, call quot, and restore x to the top
    of the stack when quot returns."
;

HELP: drop
    "( x -- )
    Remove x from the stack."
;

HELP: dup
    "( x -- x x )
    Duplicate x." ;

HELP: dupd
    "( x y -- x x y)
    Duplicate the second item on the stack."
;

HELP: each
    "( seq quot -- )            quot: ( ... elt -- ... )
    Apply quot to each element of seq in order."
;

HELP: each-index
    "( seq quot -- )            quot: ( ... elt index -- ... )
    Call quot for each element of seq with both the element and its
    index on the stack."
;

HELP: each-integer
    "( n quot -- )              quot: ( ... i -- ... )
    Call quot for each integer from 0 up to n, excluding n."
;

HELP: even?
    "( n -- ? )
    Return t if n is even."
;

HELP: file-contents
    "( path -- string )
    Return the contents of the specified file as a string."
;

HELP: filter
    "( seq quot -- subseq )     quot: ( ... elt -- ... ? )
    Return a new sequence containing the elements of the original
    sequence for which the quotation returns a true value."
;

HELP: find
    "( seq quot -- index/f elt/f )      quot: ( ... elt -- ... ? )
    Apply quot to each element of seq in order. If the quotation
    returns a true value for some element, return the index of that
    element and the element itself. Otherwise return f for both the
    index and the element."
;

HELP: find-last-from
    "( n seq quot -- index/f elt/f )    quot: ( ... elt -- ... ? )
    Apply quot to each element of seq in reverse order, starting at
    index n. If the quotation returns a true value for some element,
    return the index of that element and the element itself. Otherwise
    return f for both the index and the element."
;

HELP: in-bounds?
    "( n seq -- ? )
    Return t if n is within the bounds of seq."
;

HELP: index
    "( obj seq -- n )
    Return the index of the first element of seq that is = to obj.
    Return f if there is no such element."
;

HELP: index?
    "( x -- ? )
    Return t if x is a non-negative fixnum."
;

HELP: keep
    "( x quot -- x )
    Call quot with x on the stack. Restore x to the top of the
    stack when quot returns."
;

HELP: map
    "( seq quot -- newseq )     quot: ( ... elt -- ... newelt )
    Apply quot to each element of seq in order. Collect the results
    in a new sequence of the same type as seq."
;

HELP: map-index
    "( seq quot -- newseq )     quot: ( ... elt index -- ...newelt )
    Call quot for each element of seq with both the element and its
    index on the stack. Collect the results in a new sequence of the
    the same type as seq."
;

HELP: member?
    "( obj seq -- ? )
    Return t if seq contains an element = to obj."
;

HELP: min-length
    "( seq1 seq2 -- n )
    Return the length of the shorter sequence."
;

HELP: mismatch
    "( seq1 seq2 -- index/f )
    Compare seq1 and seq2 up to the length of the shorter sequence.
    Return the first index where the elements of the two sequences
    are not equal, or f if there is no mismatch."
;

HELP: new-sequence
    "( len seq -- newseq )
    Return a new sequence of length len which can hold the elements
    of seq."
;

HELP: odd?
    "( n -- ? )
    Return t if n is odd."
;

HELP: or
    "( obj1 obj2 -- ? )
    Boolean inclusive or: if both obj1 and obj2 are f, return f.
    Otherwise return the first of obj1 and obj2 which is not f.
    (Bitwise inclusive or is bitor.)"
;

HELP: over
    "( x y -- x y x )
    Place a copy of x on top of the stack."
;

HELP: rot
    "( x y z -- z y x )
    Rotate the top three stack entries."
;

HELP: sbuf-append-string
    "( sbuf string -- sbuf )
    Modify sbuf by adding the characters of string to the end.
    Return sbuf."
;

HELP: string-index-from
    "( char start-index string -- index )
    Return the index of the first occurrence of char in string,
    starting at start-index. Return f if char is not found."
;

HELP: string-skip-to-whitespace
    "( start-index string -- index/f )
    Return the index of the first whitespace character in string,
    starting at start-index. Return f if no whitespace character
    is found."
;

HELP: string-skip-whitespace
    "( start-index string -- index/f )
    Return the index of the first non-whitespace character in string,
    starting at start-index. Return f if no non-whitespace character
    is found."
;

HELP: swap
    "( x y -- y x )
    Exchange the top two stack items."
;

HELP: swapd
    "( x y z -- y z x )
    Exchange the second and third stack items."
;

HELP: time
    "( quot -- )
    Run quot and report the total run time."
;

HELP: times
    "( n quot -- )    quot: ( ... -- ... )
    Call quot n times."
;

HELP: unless
    "( x quot -- )
    If x is f, remove it from the stack and call quot.
    Otherwise, just remove x from the stack."
;

HELP: unless*
    "( x quot -- )
    If x is f, remove it from the stack and call quot.
    Otherwise, just leave x on the stack."
;
