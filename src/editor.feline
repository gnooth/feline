-- Copyright (C) 2017 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: user

"editor" delete-vocab

in: editor

: accept-string ( x y -- string )
    >local: y
    >local: x

    10 <sbuf> >local: sb

    [ key dup { 10 13 } member? ] [
        dup write-char sb push
    ] until

    drop
    sb sbuf>string
;

global: current-buffer
global: mod-count
global: buffer-lines
global: top-line-number
global: dot
global: repaint?
global: dot-line-changed?
global: bindings
global: done?

0 >global: goal-x

"\n"   >constant: LF
"\r\n" >constant: CR+LF

tuple: buffer filename autosave-filename eol ;

: create-buffer ( filename -- buffer )
    ' buffer new
    [ buffer-filename! ] keep
;

: editor-filename ( -- filename ) current-buffer buffer-filename ;

tuple: position line-number offset ;

: dot-line-number ( -- line-number ) dot position-line-number ;

: dot-line-number! ( line-number -- ) dot position-line-number! ;

: dot-offset ( -- ) dot position-offset ;

: dot-offset! ( n -- ) dot position-offset! ;

: hide-cursor ( -- ) esc[ "?25l" write-string ;

: show-cursor ( -- ) esc[ "?25h" write-string ;

: reverse ( -- ) esc[ "7m" write-string ;

: normal ( -- ) esc[ "m" write-string ;

: modified? ( -- ) mod-count zero? not ;

: modified ( -- ) 1+!> mod-count ;

: unmodified ( -- ) 0 !> mod-count ;

: buffer-line-count ( -- n ) buffer-lines length ;

: dot-line ( -- string ) dot-line-number buffer-lines vector-nth ;

: dot-line-length ( -- n ) dot-line string-length ;

: lines-per-page ( -- n ) #rows 2 - ;

: .cursor ( -- )
    dot-offset
    dot-line-number top-line-number -
    dup 0 >= assert-true
    at-xy ;

: dot-y ( -- )
    dot-line-number top-line-number -
    dup 0 >= assert-true ;

: .line ( y -- )
    0 over at-xy
    top-line-number + buffer-lines vector-nth
    dup length #cols < [
        dup write
        length #cols swap - spaces
    ] [
        0 #cols rot substring write
    ] if
;

: redisplay-line ( y -- )
    >local: y
    top-line-number y + buffer-line-count < [
        y .line
    ] [
        0 y at-xy #cols spaces
    ] if
;

: status-y ( -- n ) #rows 2 - ;

: status ( -- )
    reverse
    0 status-y at-xy
    modified? [ '*' write-char ] [ space ] if
    editor-filename write-string
    dot-line-number 1 +
    dot-offset 1 +
    "Line %d Col %d " format
    #cols over length - >local: x
    x editor-filename length 1 + - 1 max spaces
    write-string
    normal
;

: clear-status-line ( -- ) 0 status-y at-xy clear-to-eol ;

: message-y ( -- n ) status-y 1 + ;

: message ( string -- ) 0 message-y at-xy write-string ;

: clear-message-line ( -- ) 0 message-y at-xy clear-to-eol ;

: update-display ( -- )
    hide-cursor
    repaint? [
        0 0 at-xy
        lines-per-page [ redisplay-line ] each-integer
        f !> repaint?
    ] [
        dot-line-changed? [
            dot-y redisplay-line
            f !> dot-line-changed?
        ] when
    ] if
    status
    .cursor
    show-cursor
;

: adjust-cursor-x ( -- )
    goal-x dot-offset!
    dot-offset dot-line-length > [
        dot-line-length dot-offset!
    ] when
;

: reframe? ( -- ? )
    dot-line-number
    top-line-number
    dup lines-per-page 1 - +
    between? not ;

: reframe ( -- )
    dot-line-number
    lines-per-page 2 / verify-index
    - 0 max !> top-line-number
    t !> repaint?
;

: maybe-reframe ( -- ) reframe? [ reframe ] when ;

: beginning-of-buffer ( -- )
    0 dot-line-number!
    0 dot-offset!

    0 !> top-line-number
    0 !> goal-x
    t !> repaint?
;

: end-of-buffer ( -- )
    buffer-line-count 1 - 0 max dot-line-number!
    buffer-line-count lines-per-page - 0 max !> top-line-number
    dot-line-length dot-offset!
    dot-offset !> goal-x
    t !> repaint?
;

: gotoline ( -- )
    0 message-y at-xy "Line number: " write-string
    13 message-y accept-string >local: response
    clear-message-line
    response string>number 1 - 0 max buffer-line-count 1 - min
    dot-line-number!
    0 dot-offset!
    maybe-reframe
;

: do-home ( -- )
    0 dot-offset!
    0 !> goal-x
;

: end-of-line ( -- )
    dot-line length dot-offset!
    dot-offset !> goal-x
;

: do-left ( -- )
    dot-offset 0 > [
        dot-offset 1 - dot-offset!
        dot-offset !> goal-x
    ] [
        dot-line-number 0 > [
            dot-line-number 1 - dot-line-number!
            dot-line-length dot-offset!
            dot-offset !> goal-x
            reframe? [
                dot-line-number !> top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-right ( -- )
    dot-offset dot-line length < [
        dot-offset 1 + dot-offset!
        dot-offset !> goal-x
    ] [
        dot-line-number buffer-line-count 1 - < [
            dot-line-number 1 + dot-line-number!
            0 dot-offset!
            dot-offset !> goal-x
            reframe? [
                dot-line-number lines-per-page 1 - - !> top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-down ( -- )
    dot-line-number buffer-line-count 1 - < [
        dot-line-number 1 + dot-line-number!
        reframe? [
            dot-line-number lines-per-page 1 - - !> top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-up ( -- )
    dot-line-number 0 > [
        dot-line-number 1 - dot-line-number!
        reframe? [
            dot-line-number !> top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-page-down
    dot-y >local: goal-y

    dot-line-number lines-per-page +
    buffer-line-count 1 - min
    dot-line-number!

    dot-line-number goal-y - 0 max !> top-line-number
    t !> repaint?
    adjust-cursor-x
;

: do-page-up
    dot-y >local: goal-y

    dot-line-number lines-per-page - 0 max dot-line-number!

    dot-line-number goal-y - 0 max !> top-line-number
    t !> repaint?
    adjust-cursor-x
;

: insert-line-separator ( -- )
    dot-offset dot-line-length <= [
        dot-offset dot-line-length
        dot-line substring
        dot-line-number 1 + buffer-lines vector-insert-nth!
        dot-line dot-offset string-head dot-line-number buffer-lines vector-set-nth
        dot-line-number 1 + dot-line-number!
        0 dot-offset!
        0 !> goal-x
        modified
        t !> repaint?
    ] when
;

: delete-normal-char ( -- )
    dot-line dot-offset string-head
    dot-offset 1  + dot-line-length < [
        dot-line dot-offset 1 + string-tail concat
    ] when
    dot-line-number buffer-lines vector-set-nth
    t !> dot-line-changed?
;

: delete-line-separator ( -- )
    dot-line-number buffer-line-count 1 - < [
        dot-offset dot-line-length = [
            dot-line-number 1 + buffer-lines vector-nth
            dot-line swap concat dot-line-number buffer-lines vector-set-nth
            dot-line-number 1 + buffer-lines vector-remove-nth!
            t !> repaint?
        ] when
    ] when
;

: do-delete ( -- )
    dot-offset dot-line-length < [
        delete-normal-char
    ] [
        delete-line-separator
    ] if
    modified
;

: do-bs ( -- )
    dot-offset 0 > dot-line-number 0 > or [
        do-left do-delete
    ] when
;

: do-normal-char ( char -- )
    dot-line dup dot-offset string-head >local: head
    dot-offset string-tail >local: tail
    head string>sbuf >local: sb
    sb sbuf-push
    tail sb sbuf-append-string
    sb sbuf>string dot-line-number buffer-lines set-nth
    dot-offset 1 + dot-offset!
    t !> dot-line-changed?
    modified
;

: make-backup ( -- ) editor-filename dup "~" concat copy-file ;

: do-save ( -- )
    "Saving..." message
    make-backup

    current-buffer buffer-filename file-create-write >local: fd
    current-buffer buffer-eol >local: eol
    buffer-lines [ fd file-write-string eol fd file-write-string ] each
    fd file-close

    unmodified
    "Saving...done" message
;

: do-quit ( -- )
    t !> done?

    modified? [
        0 message-y at-xy "Save file? (y or n) " write-string
        key 'y' eq? [ do-save ] when
    ] when

    local: response

    modified? [
        0 message-y at-xy "Abandon changes? (yes or no) " write-string
        19 message-y accept-string !> response
        response "yes" = [ f !> done? ] unless
    ] when

    clear-message-line
;

: bind-key ( key action -- ) 2array bindings push ;

: lookup-key ( key -- symbol/f )
    bindings length [ bindings nth array-first over = ] find-integer    -- n/f
    nip dup [ bindings nth array-second ] [ drop f ] if ;

: initialize-bindings ( -- )
    10 <vector> !> bindings
    127                    ' do-bs                      bind-key        -- Linux
    8                      ' do-bs                      bind-key        -- Windows
    k-delete               ' do-delete                  bind-key
    k-home                 ' do-home                    bind-key
    k-end                  ' end-of-line                bind-key
    k-left                 ' do-left                    bind-key
    k-right                ' do-right                   bind-key
    k-up                   ' do-up                      bind-key
    k-down                 ' do-down                    bind-key
    k-prior                ' do-page-up                 bind-key
    k-next                 ' do-page-down               bind-key
    k-ctrl-home            ' beginning-of-buffer        bind-key
    k-ctrl-end             ' end-of-buffer              bind-key
    7 ( control g )        ' gotoline                   bind-key
    $11 ( control q )      ' do-quit                    bind-key
    $13 ( control s )      ' do-save                    bind-key
    k-enter                ' insert-line-separator      bind-key
    $1b ( escape )         ' quit                       bind-key
;

: do-command ( -- )
    lookup-key [ call-symbol ] when* ;

: dispatch ( key -- )
    dup 32 126 between? [ do-normal-char ] [ do-command ] if ;

: edit-loop ( -- )
    f !> done?
    [ done? ] [
        update-display
        ekey
        clear-message-line
        dispatch
    ] until
;

: initialize-editor ( -- )
    bindings [ initialize-bindings ] unless
;

: initialize-buffer ( filename line-number -- )
    verify-index  >local: line-number
    verify-string >local: filename

    filename create-buffer !> current-buffer

    current-buffer buffer-filename file-contents

    -- detect eol
    13 over string-index CR+LF LF ? current-buffer buffer-eol!

    string-lines verify-vector !> buffer-lines

    ' position new !> dot

    0 dot-offset!
    line-number 1 - 0 max buffer-line-count 1 - min dot-line-number!

    0 !> top-line-number
    unmodified
;

: edit1 ( -- )
    page
    normal
    maybe-reframe
    t !> repaint?

    edit-loop

    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor
;

: edit-file ( path -- )
    initialize-editor
    0 initialize-buffer
    edit1
;

: edit-definition ( symbol -- )
    initialize-editor
    symbol-location 2dup and
    [ initialize-buffer edit1 ] [ 2drop ] if
;

: edit ( -- )
    parse-token find-name [ edit-definition ] [ edit-file ] if
;

: ed ( -- )
    page
    normal
    t !> repaint?
    edit-loop
    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor
;
