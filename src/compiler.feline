-- Copyright (C) 2017-2018 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline accessors ;
in: user

"compiler" delete-vocab

in: compiler

empty

private

-- These definitions shadow the ones in compile-word.asm. Turning on
-- verbosity in this vocabulary only affects the optimizing compiler.
global compile-verbose?
: +v t compile-verbose?! ;
: -v f compile-verbose?! ;

tuple: compiler-context
    pc
    origin
    pending
    declared-type ;

: make-compiler-context                 -- void -> compiler-context
    compile-verbose? [ ?nl "make-compiler-context" print ] when

    compiler-context make-instance
    10 <vector> >>pending ;

special: current-context

: origin                                -- void -> fixnum
    current-context get origin>> ;

: origin!                               -- address -> void
    current-context get origin<< ;

: pc                                    -- void -> fixnum
    current-context get pc>> ;

: pc!                                   -- address -> void
    current-context get pc<< ;

: pending                               -- void -> vector
    current-context get pending>> ;

: declared-type                         -- void -> type
    current-context get declared-type>> ;

: declared-type!                        -- type -> void
    current-context get declared-type<< ;

: emit-byte                             -- byte -> void
    pc c!
    pc 1+ pc! ;

: emit-dword                            -- dword -> void
    pc l!
    pc 4 + pc! ;

: emit-qword                            -- qword -> void
    pc !
    pc 8 + pc! ;

: emit-bytes                            -- sequence -> void
    ' emit-byte each ;

tuple: instruction op param ;

: make-instruction                      -- op param -> instruction
    instruction make-instance           -- -> op param instruction
    swap >>param
    swap >>op ;

: literal?                              -- instruction -> ?
    op>> f eq? ;

: inst.                                 -- instruction -> void
    ?nl
    "op: " write-string
    dup op>> object->string write-string
    space
    "param: " write-string
    param>> object->string write-string ;

defer compile-quotation

: precompile-object ( x )               -- x -> instruction
    x symbol? [
        x f make-instruction
    ] [
        x quotation? [
            x quotation-code-address zero? [
                x compile-quotation drop
                x quotation-code-address zero? assert-false
            ] when
        ] when
        f x make-instruction
    ] if
;

: precompile-quotation                  -- quotation -> array
    dup quotation-array [ precompile-object ] map-array -- -> array

    compile-verbose? [
        ?nl dup [ inst. ] each
    ] when
;

: emit-pushrbx
    { 0x48 0x89 0x5d 0xf8 0x48 0x8d 0x6d 0xf8 } emit-bytes ;

: emit-poprbx
    { 0x48 0x8b 0x5d 0x00 0x48 0x8d 0x6d 0x08 } emit-bytes ;

: compile-literal                       -- x -> void
    dup wrapper? [ wrapped ] when

    emit-pushrbx
    object>uint64
    dup 32 rshift 0 = [
        0xbb emit-byte emit-dword
    ] [
        0x48 emit-byte 0xbb emit-byte emit-qword
    ] if ;

: flush-pending
    pending empty? [
        pending [ compile-literal ] each
        pending vector-delete-all
    ] unless ;

: inline-primitive
    dup symbol-code-address
    swap symbol-code-size               -- -> address size
    1-                                  -- adjust size to exclude ret instruction
    pc swap [ copy-bytes ] keep         -- -> size
    pc + pc! ;

: compile-call-address                  -- tagged-address -> void
    dup pc 5 + -                        -- -> tagged-address tagged-displacement
    int32? [
        0xe8 emit-byte                  -- -> tagged-address
        pc 4 + - emit-dword
    ] [
        "unsupported" error
    ] if ;

: compile-call-symbol                   -- symbol -> void
    symbol-code-address
    compile-call-address
;

: compile-primitive                     -- symbol -> void
    dup debug? [
        symbol-always-inline? [ inline-primitive ] [ compile-call-symbol ] if
    ] [
        symbol-inline? [ inline-primitive ] [ compile-call-symbol ] if
    ] if ;

: compile-when
    compile-verbose? [ ?nl "compile-when" print ] when

    pending empty? [ ' when compile-call-symbol ] return-if

    pending vector-last dup wrapper? [ wrapped ] when :> last

    last callable-code-address :> address

    address [
        { 0x48 0x83 0xfb 0x06 } emit-bytes -- cmp rbx, 6
        emit-poprbx
        0x74 emit-byte                  -- jz
        0x05 emit-byte                  -- $+5
        address compile-call-address
        pending vector-pop*
    ] [
        flush-pending
        ' when compile-call-symbol
    ] if
;

: compile-declare
    compile-verbose? [ ?nl "compile-declare" print ] when

    pending vector-?last array-?last symbol-value verify-type declared-type!
    compile-verbose? [ ?nl "compile-declare declared type = " write-string declared-type type-name print ] when
    pending vector-pop*
;

: inline-or-compile-call                -- symbol -> void
    dup symbol-primitive? [ compile-primitive ] [ compile-call-symbol ] if ;

: compile-generic ( op )                -- symbol -> void
    compile-verbose? [ ?nl "compile-generic declared-type = " write declared-type . ] when

    {
        [ declared-type type? ]
        [ declared-type op find-method ]
    } && :> method

    flush-pending

    method null? [ op compile-call-symbol ] return-if

    method method-callable :> callable

    callable symbol? [ callable inline-or-compile-call ] return-if

    callable callable-code-address compile-call-address
;

: compile-operator ( op )               -- symbol -> void

    op ' when eq? [
        compile-when
    ] return-if

    op ' declare eq? [
        compile-declare
    ] return-if

    op generic? [
        op compile-generic
    ] return-if

    flush-pending

    op inline-or-compile-call
;

: compile-instruction                   -- instruction -> void
    dup op>> [
        op>> compile-operator
    ] [
        param>> pending vector-push
    ] if ;

: compile-quotation-internal            -- quotation -> void
    precompile-quotation                -- -> array

    dup length 32 * initialize-code-block dup pc! origin!

    ' compile-instruction each

    flush-pending

    0xc3 emit-byte

    origin pc over -                    -- -> quotation code-address code-size
    pick quotation-set-code-size
    swap quotation-set-code-address ;

: %compile-quotation ( quotation )       -- quotation -> quotation
    compile-verbose? [ ?nl "%compile-quotation " write quotation . ] when

    { [ quotation length 1 eq? ] [ quotation first symbol? ] } && [
        quotation first [ symbol-code-address ] [ symbol-code-size ] bi
        quotation quotation-set-code-size
        quotation quotation-set-code-address
        quotation
    ] return-if

    [
        make-compiler-context current-context set
        quotation [ compile-quotation-internal ] keep
    ] with-dynamic-scope

     compile-verbose? [ ?nl "leaving %compile-quotation" print ] when
;

' %compile-quotation ' compile-quotation defer!

: compile-word                          -- symbol -> void
    dup symbol-def compile-quotation    -- -> symbol quotation
    dup quotation-code-address pick symbol-set-code-address
    quotation-code-size swap symbol-set-code-size ;

public

: opt
    postpone: '
    +v
    compile-word ;
