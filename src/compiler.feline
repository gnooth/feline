// Copyright (C) 2017-2020 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline accessors ;
in: user

"compiler" delete-vocab

in: compiler

empty

private

// These definitions shadow the ones in compile-word.asm. Turning on
// verbosity in this vocabulary only affects the optimizing compiler.
global compile-verbose?
: +v true compile-verbose?! ;
: -v nil compile-verbose?! ;

tuple: compiler-context
    pc
    origin
    pending ;

: make-compiler-context                 // void -> compiler-context
    compile-verbose? [ ?nl "make-compiler-context" print ] when

    compiler-context make-instance
    10 <vector> >>pending ;

special: current-context

: origin                                // void -> fixnum
    current-context get origin>> ;

: origin!                               // address -> void
    current-context get origin<< ;

: pc                                    // void -> fixnum
    current-context get pc>> ;

: pc!                                   // address -> void
    current-context get pc<< ;

: emit-byte                             // byte -> void
    pc c!
    pc 1+ pc! ;

: emit-dword                            // dword -> void
    pc l!
    pc 4 + pc! ;

: emit-qword                            // qword -> void
    pc !
    pc 8 + pc! ;

: emit-bytes                            // sequence -> void
    ' emit-byte each ;

tuple: node
    literal-value
    op
    type                                // result type
    pred                                // predecessor node or nil
;

: make-literal-node                     // literal -> node
    dup type-of                         // -> literal type
    node make-instance
    swap >>type
    swap >>literal-value ;

: make-operator-node                    // symbol -> node
    [ symbol-declared-type ] keep
    node make-instance
    swap >>op
    swap >>type ;

: dump-node ( node )                    // node -> void
    node op>> [
        "operator: " write-string
        node op>> object->string write-string
        " type: " write-string
        node type>> object->string print
    ] [
        "literal: " write-string
        node literal-value>> object->string write-string
        " type: " write-string
        node type>> [ object->string print ] [ . ] if*
    ] if ;

: pending                               // void -> vector
    current-context get pending>> ;

: pending-last                          // void -> node
    pending vector-last ;

: pending-last-value                    // void -> x
    pending vector-last literal-value>> ;

: pending-remove-last
    pending vector-pop* ;

defer compile-quotation

: precompile-object ( x )               // x -> node
    x symbol? [
        x make-operator-node
    ] [
        x quotation? [
            x quotation-code-address 0? [
                x compile-quotation drop
                x quotation-code-address 0? assert-false
            ] when
        ] when
        x make-literal-node
    ] if ;

: precompile-quotation                  // quotation -> array

    64 <vector> :> vec

    quotation-array [
        precompile-object               // -> node
        vec vector-?last >>pred
        vec push
    ] each

    compile-verbose? [
        ?nl vec [ dec. space dump-node ] each-index
    ] when

    vec ;

: emit-pushrbx
    { 0x48 0x89 0x5d 0xf8 0x48 0x8d 0x6d 0xf8 } emit-bytes ;

: emit-drop
    { 0x48 0x8b 0x5d 0x00 0x48 0x8d 0x6d 0x08 } emit-bytes ;

: compile-literal                       // node -> void
    literal-value>>

    dup wrapper? [ wrapped ] when

    emit-pushrbx
    object>uint64
    dup 32 rshift 0 = [
        0xbb emit-byte emit-dword
    ] [
        0x48 emit-byte 0xbb emit-byte emit-qword
    ] if ;

: flush-pending
    pending empty? [
        pending [ compile-literal ] each
        pending vector-delete-all
    ] unless ;

: inline-primitive
    dup symbol-code-address
    swap symbol-code-size               // -> address size
    1-                                  // adjust size to exclude ret instruction
    pc swap [ unsafe-copy-bytes ] keep  // -> size
    pc + pc! ;

: compile-call-address                  // tagged-address -> void
    dup pc 5 + -                        // -> tagged-address tagged-displacement
    int32? [
        0xe8 emit-byte                  // -> tagged-address
        pc 4 + - emit-dword
    ] [
        "unsupported" error
    ] if ;

: compile-call-symbol                   // symbol -> void
    symbol-code-address
    compile-call-address ;

: compile-primitive                     // symbol -> void
    dup debug? [
        symbol-always-inline? [ inline-primitive ] [ compile-call-symbol ] if
    ] [
        symbol-inline? [ inline-primitive ] [ compile-call-symbol ] if
    ] if ;

: compile-when ( node )                 // node -> void

    compile-verbose? [ ?nl "compile-when" print ] when

    pending empty? [ ' when compile-call-symbol ] ?return

    pending-last-value dup wrapper? [ wrapped ] when :> last-value

    last-value callable-code-address :> address

    address [
        pending-remove-last
        flush-pending
        { 0x48 0x83 0xfb 0x06 } emit-bytes // cmp rbx, 6
        emit-drop
        0x74 emit-byte                  // jz
        0x05 emit-byte                  // $+5
        address compile-call-address
    ] [
        flush-pending
        ' when compile-call-symbol
    ] if ;

: compile-both? ( node )
    pending length 2 < [ ' both? compile-call-symbol ] ?return

    pending last literal-value>> :> quot2

    pending dup length 2 - swap nth literal-value>> :> quot1
    [ quot1 quotation? ] [ quot2 quotation? ] both? nil?
    [ ' both? compile-call-symbol ] ?return

    // quot1 and quot2 are both literal quotations
    quot2 callable-code-address :> addr2
    pending-remove-last
    quot1 callable-code-address :> addr1
    pending-remove-last

    flush-pending

    addr1 compile-call-address          // call addr1
    { 0x48 0x83 0xfb 0x06 } emit-bytes  // cmp rbx, 6
    0x74 emit-byte                      // jz
    0x0d emit-byte                      // $+13
    emit-drop                           // drop
    addr2 compile-call-address          // call addr2
;

: compile-either? ( node )
    ?nl "either?" print
    pending length 2 < [ ' either? compile-call-symbol ] ?return

    pending last literal-value>> :> quot2

    pending dup length 2 - swap nth literal-value>> :> quot1
    [ quot1 quotation? ] [ quot2 quotation? ] both? nil?
    [ ' either? compile-call-symbol ] ?return

    // quot1 and quot2 are both literal quotations
    quot2 callable-code-address :> addr2
    pending-remove-last
    quot1 callable-code-address :> addr1
    pending-remove-last

    flush-pending

    addr1 compile-call-address          // call addr1
    { 0x48 0x83 0xfb 0x06 } emit-bytes  // cmp rbx, 6
    0x75 emit-byte                      // jne
    0x0d emit-byte                      // $+13
    emit-drop                           // drop
    addr2 compile-call-address          // call addr2
;

: compile-while ( node )
    ?nl "while" print
    pending length 2 < [ ' while compile-call-symbol ] ?return

    pending last literal-value>> :> quot2

    pending dup length 2 - swap nth literal-value>> :> quot1
    [ quot1 quotation? ] [ quot2 quotation? ] both? nil?
    [ ' while compile-call-symbol ] ?return

    // quot1 and quot2 are both literal quotations
    quot2 callable-code-address :> addr2
    pending-remove-last
    quot1 callable-code-address :> addr1
    pending-remove-last

    flush-pending

    addr1 compile-call-address          // call addr1
    { 0x48 0x83 0xfb 0x06 } emit-bytes  // cmp rbx, 6
    emit-drop                           // drop
    0x74 emit-byte                      // je
    0x07 emit-byte                      // $+7
    addr2 compile-call-address          // call addr2
    0xeb emit-byte                      // jmp
    0xe6 emit-byte                      // $-26
;

: compile-call-quotation ( node )
    pending empty? [ ' call compile-call-symbol ] ?return
    pending-last-value dup wrapper? [ wrapped ] when :> last-value
    last-value callable-code-address :> address
    address [
        pending-remove-last
        flush-pending
        address compile-call-address
    ] [
        flush-pending
        ' call compile-call-symbol
    ] if ;

: compile-declare ( node )              // node -> void

    compile-verbose? [ ?nl "compile-declare" print ] when

    node pred>> :> pred

    pred pending-last assert-eq

    pending vector-pop*

    pred literal-value>> array-?last symbol-value verify-type :> declared-type

    declared-type node type<<

    compile-verbose? [
        ?nl "compile-declare declared type = " write-string declared-type type-name print
    ] when ;

: inline-or-compile-call                // symbol -> void
    dup symbol-primitive? [ compile-primitive ] [ compile-call-symbol ] if ;

: compile-generic ( node )              // node -> void

    node op>> :> op

    node pred>> [ type>> ] [ f ] if* :> derived-type

    compile-verbose? [ ?nl "compile-generic derived-type = " write derived-type . ] when

    {
        [ derived-type type? ]
        [ derived-type op find-method ]
    } && :> method

    flush-pending

    method null? [ op compile-call-symbol ] ?return

    method method-callable :> callable

    callable symbol? [ callable inline-or-compile-call ] ?return

    callable callable-code-address compile-call-address ;

: compile-operator-node ( node )        // node -> void

    node op>> :> op

    op ' while eq? [
        node compile-while
    ] ?return

    op ' either? eq? [
        node compile-either?
    ] ?return

    op ' both? eq? [
        node compile-both?
    ] ?return

    op ' call eq? [
        node compile-call-quotation
    ] ?return

    op ' when eq? [
        node compile-when
    ] ?return

    op ' declare eq? [
        node compile-declare
    ] ?return

    op generic? [
        node compile-generic
    ] ?return

    flush-pending

    op inline-or-compile-call ;

: compile-node                          // node -> void
    dup op>> [
        compile-operator-node
    ] [
        pending vector-push
    ] if ;

: compile-quotation-internal            // quotation -> void
    dup precompile-quotation            // -> quotation array
    dup length 32 * 16 max initialize-code-block dup pc! origin!
    ' compile-node each
    flush-pending
    0xc3 emit-byte
    origin pc over -                    // -> quotation code-address code-size
    pick quotation-set-code-size
    swap quotation-set-code-address ;

: %compile-quotation ( quotation )       // quotation -> quotation

    [ quotation length 1 eq? ] [ quotation first symbol? ] both?
    [
        quotation first [ symbol-code-address ] [ symbol-code-size ] bi
        quotation quotation-set-code-size
        quotation quotation-set-code-address
        quotation
    ] ?return

    [
        make-compiler-context current-context set
        quotation [ compile-quotation-internal ] keep
    ] with-dynamic-scope ;

' %compile-quotation ' compile-quotation defer!

: compile-word                          // symbol -> void
    dup symbol-def compile-quotation    // -> symbol quotation
    dup quotation-code-address pick symbol-set-code-address
    quotation-code-size swap symbol-set-code-size ;

public

: opt
    postpone: '
    +v
    compile-word ;

: +opt
    -v
    ' compiler:compile-word ' feline:compile-word defer! ;

: -opt
    ' feline:primitive-compile-word ' feline:compile-word defer! ;
