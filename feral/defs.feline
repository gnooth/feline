-- Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline accessors ;
in: editor

tuple: line
    prev
    next
    number                              -- 0-based line number
    text ;

: make-line/1                           -- string -> line
    line make-instance
    tuck
    text<< ;

: make-line/2                           -- string line-number -> line
    line make-instance
    swap >>number
    swap >>text ;

method: line length                     -- line -> length
    text>> string-length ;

method: line substring                  -- from to line -> substring
    text>> string-substring ;

tuple: position
    line
    offset ;

: make-position                         -- line offset -> position
    position make-instance :> pos
    pos offset<<
    pos line<<
    pos
;

: copy-position ( pos )                 -- position -> copy
    pos line>> pos offset>> make-position ;

: position-before? ( pos1 pos2 )        -- pos1 pos2 -> ?
    pos1 line>> :> line1
    pos2 line>> :> line2

    line1 number>> line2 number>> < [ t ] return-if

    line1 line2 eq? [ pos1 offset>> pos2 offset>> < ] [ f ] if
;

generic before?

method: position before? position-before? ;

: move-next ( pos )                     -- position -> ?
    pos offset>> :> offset
    pos line>> :> line

    {
        { [ offset line length < ] [ offset 1+ pos offset<< t ] }
        { [ line next>> ] [
            line next>> pos line<<
            0 pos offset<< t
        ] }
        [ f ]
    } cond
;

: move-prev ( pos )                     -- position -> ?
    pos offset>> :> offset
    pos line>> :> line

    {
        { [ offset 0 > ] [ offset 1- pos offset<< t ] }
        { [ line prev>> ] [
            line prev>> pos line<<
            pos line>> length pos offset<< t
        ] }
        [ f ]
    } cond
;

tuple: region
    begin
    end ;

: make-region/2 ( pos1 pos2 )
    region make-instance :> region
    pos1 pos2 before? [ pos1 pos2 ] [ pos2 pos1 ] if
    [ copy-position ] bi@
    region [ end<< ] [ begin<< ] bi
    region
;

generic begin

method: region begin                    -- region -> position
    begin>> ;

generic begin-line

method: region begin-line               -- region -> line
    begin>> line>> ;

generic begin-offset

method: region begin-offset             -- region -> offset
    begin>> offset>> ;

generic end

method: region end                      -- region -> position
    end>> ;

generic end-line

method: region end-line                 -- region -> line
    end>> line>> ;

generic end-offset

method: region end-offset               -- region -> offset
    end>> offset>> ;

: region-as-string ( region )
    region [ begin-line ] [ end-line ] bi eq? [
        region [ begin-offset ] [ end-offset ] [ begin-line ] tri substring
    ] return-if

    1024 <sbuf> :> sb

    region [ begin-offset ] [ begin-line length ] [ begin-line ] tri substring
    sb sbuf-append-string
    '\n' sb sbuf-push

    region begin-line next>> :> line!
    region end-line :> region-end-line

    [ line region-end-line neq? ] [
        line text>> sb sbuf-append-string
        '\n' sb sbuf-push
        line next>> line!
    ] while

    region end-offset 0 > [
        0 region end-offset region-end-line text>> substring
        sb sbuf-append-string
    ] when

    sb sbuf>string
;

tuple: buffer
    mode
    dot
    mark
    anchor
    goal-column
    filename
    autosave-filename
    mod-count
    mod-count-last-save
    eol
    undo-stack
    redo-stack
    first-line
    last-line
    top-line
;

"\n"   constant LF
"\r\n" constant CR+LF

: make-buffer                           -- -> buffer
    buffer make-instance :> buf

    0 buf goal-column<<
    0 buf mod-count<<
    0 buf mod-count-last-save<<
    LF buf eol<<

    100 <vector> buf undo-stack<<
    16 <vector> buf redo-stack<<

    buf
;
