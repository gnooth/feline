// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors segments modes feral-config ;
in: editor

: format-line ( s )                     // string -> segments
    current-buffer mode>> :> mode
    mode [
        s mode formatter>> call-symbol
    ] [
        s 0 color-text make-segment/3
        1array
    ] if
;

: mode-line-text                        // void -> string
    256 <sbuf> :> sb
    modified? '*' '\s' ? sb sbuf-push
    current-buffer name>> "untitled" or sb sbuf-append-string
    dot-line-number 1+
    dot-column 1+
    line-count
    " %d:%d (%d)" format sb sbuf-append-string
    sb sbuf>string ;

winui? #if

: update-caret-pos
    dot-column winui-char-width *
    dot-line-number top-line-number - winui-char-height *
    winui-set-caret-pos
;

: update-mode-line
    mode-line-text winui-modeline-set-text
;

192 192 192 make-colorref constant fg-default
  0   0   0 make-colorref constant bg-default
 64  64  64 make-colorref constant bg-selected

: repaint-segment                       // segment y -> void
    2 ?enough
    :> y :> segment

    segment format>> dup fixnum? assert winui-textview-set-fg-color

    segment start>> winui-char-width *
    y winui-char-height *
    segment text>> winui-textview-text-out
;

: xrepaint-segment ( segment region y )

    region begin-offset :> region-begin
    region end-offset :> region-end

    top-line-number y + nth-line dot-line assert-eq
    dot-line mark-line assert-eq

    region-begin segment start>> <
    segment start>> segment text>> length + region-end <= and [
        // segment is entirely within selection
        bg-selected winui-textview-set-bg-color
        segment y repaint-segment
        bg-default winui-textview-set-bg-color
    ] return-if

    f :> seg1!
    f :> seg2!

    region-begin segment in-segment? region-end segment in-segment? and [
        segment region-begin segment start>> - split-segment seg2! seg1!
        bg-default winui-textview-set-bg-color
        seg1 y repaint-segment

        // now split seg2 at region-end
        seg2 region-end seg2 start>> - split-segment
        swap
        bg-selected winui-textview-set-bg-color
        y repaint-segment
        bg-default winui-textview-set-bg-color
        y repaint-segment
    ] return-if

    region-begin segment in-segment? [
        segment region-begin segment start>> - split-segment seg2! seg1!
        bg-default winui-textview-set-bg-color
        seg1 y repaint-segment
        bg-selected winui-textview-set-bg-color
        seg2 y repaint-segment
        bg-default winui-textview-set-bg-color
    ] return-if

    region-end segment in-segment? [
        segment region-end segment start>> - split-segment seg2! seg1!
        bg-selected winui-textview-set-bg-color
        seg1 y repaint-segment
        bg-default winui-textview-set-bg-color
        seg2 y repaint-segment
    ] return-if

    segment y repaint-segment
;

: repaint-segments ( segments y )       // segments y -> void
    segments [ y repaint-segment ] each
;

: repaint-selected-line ( line y )      // line y -> void

    line line-selected? assert

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    bg-selected winui-textview-set-bg-color

    segments string? [
        color-text winui-textview-set-fg-color
        0 y winui-char-height * segments winui-textview-text-out
    ] [
        segments y repaint-segments
    ] if

    detabbed-text length y winui-textview-clear-eol

    bg-default winui-textview-set-bg-color
;

: repaint-line-containing-selection ( x y line ) // x y line -> void

    line line-contains-selection? assert

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    mark dot make-region/2 :> region

    segments string? [
        // FIXME
        color-text winui-textview-set-fg-color
        0 y winui-char-height * segments winui-textview-text-out
    ] [
        segments [ region y xrepaint-segment ] each
    ] if

    detabbed-text length y winui-textview-clear-eol
;

: repaint-line ( line y )               // line y -> void

    line line-selected? [ line y repaint-selected-line ] return-if

    line line-contains-selection? [
        0 y line repaint-line-containing-selection
    ] return-if

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    segments string? [
        color-text winui-textview-set-fg-color
        0 y winui-char-height * segments winui-textview-text-out
    ] [
        segments y repaint-segments
    ] if

    detabbed-text length y winui-textview-clear-eol
;

: repaint

    top-line :> line!
    0 :> y!

    winui-hide-caret

    [ line y textview-rows < and ] [
        line y repaint-line
        y 1+ y! line next>> line!
    ] while

    [ y textview-rows < ] [
        0 y winui-textview-clear-eol
        y 1+ y!
    ] while

    update-mode-line

    winui-show-caret

    f repaint?!
;

: update-display
    winui-hide-caret
    repaint? [
        repaint
    ] [
        dot-line-changed? [
            dot-line dot-row repaint-line
            f dot-line-changed?!
        ] when
    ] if
    update-mode-line
    update-caret-pos
    winui-show-caret
;

#else

: update-caret-pos
    dot-column
    dot-line-number top-line-number -
    at-xy ;

use: ansi-color

192 192 192 rgb-foreground-prefix constant fg-default
  0   0   0 rgb-background-prefix constant bg-default
 64  64  64 rgb-background-prefix constant bg-selected

: normal esc[ "m" write-string-escaped ;

  0   0   0 rgb-foreground-prefix constant fg-mode-line
192 192 192 rgb-background-prefix constant bg-mode-line

: update-mode-line
    0 status-y at-xy

    fg-mode-line write-string-escaped
    bg-mode-line write-string-escaped

    mode-line-text write-string
    clear-to-eol

    fg-default write-string-escaped
    bg-default write-string-escaped
;

: clear-status-line 0 status-y at-xy clear-to-eol ;

: repaint-segment                       // segment -> void
    dup
    format>> write-string-escaped
    text>> write-string
;

: xrepaint-segment ( segment region )

    region begin-offset :> region-begin
    region end-offset :> region-end

    dot-line mark-line assert-eq

    region-begin segment start>> <
    segment start>> segment text>> length + region-end <= and [
        // segment is entirely within region
        bg-selected write-string-escaped
        segment repaint-segment
        bg-default write-string-escaped
    ] return-if

    f :> seg1!
    f :> seg2!

    region-begin segment in-segment? region-end segment in-segment? and [
        segment region-begin segment start>> - split-segment seg2! seg1!
        bg-default write-string-escaped
        seg1 repaint-segment

        // now split seg2 at region-end
        seg2 region-end seg2 start>> - split-segment
        swap
        bg-selected write-string-escaped
        repaint-segment
        bg-default write-string-escaped
        repaint-segment
    ] return-if

    region-begin segment in-segment? [
        segment region-begin segment start>> - split-segment seg2! seg1!
        bg-default write-string-escaped
        seg1 repaint-segment
        bg-selected write-string-escaped
        seg2 repaint-segment
        bg-default write-string-escaped
    ] return-if

    region-end segment in-segment? [
        segment region-end segment start>> - split-segment seg2! seg1!
        bg-selected write-string-escaped
        seg1 repaint-segment
        bg-default write-string-escaped
        seg2 repaint-segment
    ] return-if

    segment repaint-segment
;

: repaint-segments                      // segments -> void
    [ repaint-segment ] each ;

: repaint-selected-line ( line )        // line -> void

    line line-selected? assert

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    bg-selected write-string-escaped

    segments string? [
        fg-default write-string-escaped
        segments write-string
    ] [
        segments repaint-segments
    ] if

    terminal-columns detabbed-text string-length - spaces

    bg-default write-string-escaped
;

: repaint-line-containing-selection ( line ) // line -> void

    line line-contains-selection? assert

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    mark dot make-region/2 :> region

    segments string? [
        // FIXME
        detabbed-text length terminal-columns < [
            segments write
            terminal-columns detabbed-text string-length - spaces
        ] [
            0 terminal-columns detabbed-text substring write
        ] if
    ] [
        segments [ region xrepaint-segment ] each
    ] if

    detabbed-text string-length terminal-columns < [
        terminal-columns detabbed-text string-length - spaces
    ] when
;

: repaint-line ( line )                 // line -> void

    line line-selected? [ line repaint-selected-line ] return-if

    line line-contains-selection? [
        line repaint-line-containing-selection
    ] return-if

    line text>> detab :> detabbed-text

    detabbed-text format-line :> segments

    segments string? [
        detabbed-text length terminal-columns < [
            segments write
            terminal-columns detabbed-text string-length - spaces
        ] [
            0 terminal-columns detabbed-text substring write
        ] if
    ] [
        segments repaint-segments
        terminal-columns detabbed-text string-length - spaces
    ] if
;

: repaint
    top-line :> line!
    0 :> y!

    [ line y textview-rows < and ] [
        0 y at-xy
        line repaint-line
        y 1+ y! line next>> line!
    ] while

    [ y textview-rows < ] [
        0 y at-xy terminal-columns spaces
        y 1+ y!
    ] while

    f repaint?!
;

: update-display
    hide-cursor
    repaint? [
        repaint
    ] [
        dot-line-changed? [
            0 dot-row at-xy
            dot-line repaint-line
            f dot-line-changed?!
        ] when
    ] if
    update-mode-line
    update-caret-pos
    show-cursor
;

#endif
