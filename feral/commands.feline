// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline accessors feral-core history mini ;
in: editor

: gotoline
    "Line number: " minibuffer-accept-string :> s
    s empty? [
        s string>number [ gotoline-internal ] when*
    ] unless ;

: find-file-to-edit ( arg )             // arg -> path/f
    arg find-file [
        arg ensure-feline-extension find-file
    ] unless* ;

: create-buffer-for-new-file ( filename )
    make-buffer :> buf

    "" 0 make-line/2
    [ buf buffer-append-line ]
    [ 0 make-position buf dot<< ]
    bi

    buf dot>> line>> buf top-line<<

    filename buf filename<<
    filename file-name-nondirectory buf name<<
    filename file-name-extension [ modes:modes at buf mode<< ] when*

    buf dup mode>> initialize-buffer

    buf buffer-list vector-push
    buf current-buffer!

    t repaint!
;

: open-file
    current-buffer buffer-directory file-name-as-directory :> default-directory

    "open-file" set-history
    "File: " default-directory minibuffer-accept-string/2 !> arg

    arg empty? ?exit

    arg tilde-expand-filename arg!

    arg directory? [ arg directory-mode:open-directory ] return-if

    arg find-file-to-edit :> filename

    f !> buf
    {
        {
            [ filename null? ]
            [ arg canonical-path [ create-buffer-for-new-file ] when* ]
        }
        {
            [ filename find-buffer-from-file-name dup buf! ]
            [ buf set-current-buffer ]
        }
        {
            [ filename file-exists? ]
            [ filename 1 create-buffer/2 ]
        }
        {
            [ filename feline-extension + file-exists? ]
            [ filename feline-extension + 1 create-buffer/2 ]
        }
        // otherwise...
        [ arg canonical-path [ create-buffer-for-new-file ] when* ]
    } cond
;

: execute-command
    "command" set-history
    "Command: " minibuffer-accept-string :> command

    command empty? [
        command find-name [
            call-symbol
        ] [
            "%S is not a valid command name." format message
        ] if
    ] unless ;

: escape
    mark [ unmark t repaint! ] when ;
