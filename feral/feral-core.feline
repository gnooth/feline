// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline accessors feral-config ;
in: feral-core

: add-hook ( callable hook )            // callable symbol -> void
    hook symbol-value [
        1 <vector> hook symbol-set-value
    ] unless
    hook symbol-value verify-vector :> hooks
    callable hooks vector-adjoin ;

: run-hook ( hook )                     // hook -> void
    hook symbol-value :> val
    val vector? [
        val [ call ] each
    ] when ;

global exit-feral-hook

tuple: line
    prev
    next
    number                              // 0-based line number
    text ;

: make-line/1                           // string -> line
    verify-string
    line make-instance
    tuck
    text<< ;

: make-line/2                           // string line-number -> line
    line make-instance
    swap verify-fixnum >>number
    swap verify-string >>text ;

method: line length                     // line -> length
    text>> string-length ;

method: line substring                  // from to line -> substring
    text>> string-substring ;

: line-before? ( line1 line2 )          // line1 line2 -> ?
    line1 number>> line2 number>> <
;

tuple: position
    line
    offset ;

: make-position                         // line offset -> position
    position make-instance :> pos
    pos offset<<
    pos line<<
    pos
;

: copy-position ( pos )                 // position -> copy
    pos line>> pos offset>> make-position ;

: position-before? ( pos1 pos2 )        // pos1 pos2 -> ?
    pos1 line>> :> line1
    pos2 line>> :> line2
    {
        { [ line1 number>> line2 number>> < ] [ t ] }
        { [ line1 line2 eq? ] [ pos1 offset>> pos2 offset>> < ] }
        // default
        [ f ]
    } cond ;

generic before?

method: line before? line-before? ;

method: position before? position-before? ;

: move-next ( pos )                     // position -> ?
    pos offset>> :> offset
    pos line>> :> line

    {
        { [ offset line length < ] [ offset 1+ pos offset<< t ] }
        { [ line next>> ] [
            line next>> pos line<<
            0 pos offset<< t
        ] }
        [ f ]
    } cond
;

: move-prev ( pos )                     // position -> ?
    pos offset>> :> offset
    pos line>> :> line

    {
        { [ offset 0 > ] [ offset 1- pos offset<< t ] }
        { [ line prev>> ] [
            line prev>> pos line<<
            pos line>> length pos offset<< t
        ] }
        [ f ]
    } cond
;

tuple: region
    begin
    end ;

: make-region/2 ( pos1 pos2 )           // pos1 pos2 -> region
    region make-instance :> region
    pos1 pos2 before? [ pos1 pos2 ] [ pos2 pos1 ] if
    [ copy-position ] bi@
    region [ end<< ] [ begin<< ] bi
    region
;

: in-region? ( pos region )             // pos region -> ?
    pos region begin>> before? [
        f
    ] [
        pos region end>> before?
    ] if ;

generic begin

method: region begin                    // region -> position
    begin>> ;

generic begin-line

method: region begin-line               // region -> line
    begin>> line>> ;

generic begin-offset

method: region begin-offset             // region -> offset
    begin>> offset>> ;

generic end

method: region end                      // region -> position
    end>> ;

generic end-line

method: region end-line                 // region -> line
    end>> line>> ;

generic end-offset

method: region end-offset               // region -> offset
    end>> offset>> ;

tuple: region-iterator
    current
    end ;

: make-region-iterator                  // region -> iterator
    region-iterator make-instance
    swap [ begin-line ] [ end-line ] bi
    [ >>current ] dip
    >>end                               // -> iterator
;

: region-iterator-next                  // iterator -> line/f

    dup current>> null? [ drop f ] return-if

    [ current>> ] keep                  // -> current iterator

    dup
    [ current>> ] [ end>> ] bi eq?      // -> current iterator ?

    [ f ] [
        dup current>> [ next>> ] when*
    ] if

    swap current<<
;

: region-each-line                      // region callable ->
    swap

    dup end>> offset>> zero? [
        // region ends at offset 0 of its last line
        // don't include this line
        [ begin>> ] [ end>> ] bi        // -> callable begin end
        line>> prev>> 0 make-position   // -> callable begin end'
        make-region/2                   // -> callable region'
    ] when

    make-region-iterator                // -> callable iterator
    [
        dup region-iterator-next dup
    ] [
        // -> callable iterator line/f
        pick call
    ] while
    2drop
;

: region-as-string ( region )
    region [ begin-line ] [ end-line ] bi eq? [
        region [ begin-offset ] [ end-offset ] [ begin-line ] tri substring
    ] return-if

    1024 <sbuf> :> sb

    region [ begin-offset ] [ begin-line length ] [ begin-line ] tri substring
    sb sbuf-append-string
    '\n' sb sbuf-push

    region begin-line next>> :> line!
    region end-line :> region-end-line

    [ line region-end-line neq? ] [
        line text>> sb sbuf-append-string
        '\n' sb sbuf-push
        line next>> line!
    ] while

    region end-offset 0 > [
        0 region end-offset region-end-line text>> substring
        sb sbuf-append-string
    ] when

    sb sbuf>string
;

tuple: buffer
    name
    mode
    parent
    local-map
    read-only
    dot
    mark
    anchor
    goal-column
    filename
    autosave-filename
    mod-count
    mod-count-last-save
    eol
    undo-stack
    redo-stack
    first-line
    last-line
    top-line
    indent-size
    tab-width
;

"\n"   constant LF
"\r\n" constant CR+LF

: make-buffer                           // -> buffer
    buffer make-instance :> buf

    0 buf goal-column<<
    0 buf mod-count<<
    0 buf mod-count-last-save<<
    LF buf eol<<

    100 <vector> buf undo-stack<<
    16 <vector> buf redo-stack<<

    buf
;

var repaint?
var dot-line-changed?

var current-command
var last-command

var in-redo?

var done?

global buffer-list

global current-buffer

: buffer-modified?                      // buffer -> ?
    dup mod-count>> swap mod-count-last-save>> neq? ;

: dot                                   // -> position
    current-buffer dot>> ;

: dot!                                  // position -> void
    current-buffer dot<< ;

: dot-line                              // -> line
    dot line>> ;

: dot-line-number                       // -> line-number
    dot line>> number>> ;

: dot-line!                            // line -> void
    dot line<< ;

: dot-offset                            // -> n
    dot offset>> ;

: dot-offset!                           // n -> void
    dot offset<< ;

: mark                                  // -> position/f
    current-buffer mark>> ;

: mark!                                 // position -> void
    current-buffer mark<< ;

: mark-line                             // -> line/f
    mark [ mark line>> ] [ f ] if ;

: mark-line-number                      // -> line-number/f
    mark [ mark line>> number>> ] [ f ] if ;

: mark-offset                           // -> n
    mark offset>> ;

: unmark
    mark [ f mark! t repaint! ] when ;

: copy-dot                              // -> position
    dot copy-position ;

: copy-mark                             // -> position
    mark [ copy-position ] [ f ] if* ;

: anchor                                // -> position/f
    current-buffer anchor>> ;

: anchor!                               // position -> void
    current-buffer anchor<< ;

: top-line                              // -> line
    current-buffer top-line>> ;

: top-line!                             // line -> void
    current-buffer top-line<< ;

: top-line-number                       // void -> n
    current-buffer top-line>> number>> ;

: dot-line-text                         // -> string
    dot-line text>> ;

: dot-line-text!                        // string ->
    dot-line text<< ;

: dot-char                              // -> char/?
    dot-offset dot-line-text ?nth ;

: dot-line-length                       // -> n
    dot-line-text string-length ;

: dot-line-head                         // -> string
    dot-offset dot-line text>> string-head ;

: dot-line-tail                         // -> string
    dot-offset dot-line text>> string-tail ;

: dot-line-next                         // -> line
    dot line>> next>> ;

: dot-line-prev                         // -> line
    dot line>> prev>> ;

: bol?                                  // void -> ?
    dot-offset zero? ;

: eol?                                  // void -> ?
    dot-offset dot-line-length eq? ;

: bob?                                  // void -> ?
    bol? dot-line-prev null? and ;

: eob?                                  // void -> ?
    eol? dot-line-next null? and ;

: first-line                            // void -> line
    current-buffer first-line>> ;

: first-line!                           // line -> void
    current-buffer first-line<< ;

: last-line                             // -> line
    current-buffer last-line>> ;

: last-line!                            // line -> void
    current-buffer last-line<< ;

: last-line-number                      // -> n
    last-line number>> ;

: line-count                            // -> n
    last-line-number 1+ ;

: goal-column                           // -> n
    current-buffer goal-column>> ;

: goal-column!                          // n ->
    current-buffer goal-column<< ;

: mod-count                             // -> n
    current-buffer mod-count>> ;

: mod-count!                            // n ->
    current-buffer mod-count<< ;

: mod-count-last-save                   // -> n
    current-buffer mod-count-last-save>> ;

: mod-count-last-save!               // n ->
    current-buffer mod-count-last-save<< ;

: modified?                             // -> ?
    mod-count mod-count-last-save neq? ;

: modified mod-count 1+ mod-count! ;

: undo-stack                            // -> vector
    current-buffer undo-stack>> ;

: redo-stack                            // -> vector
    current-buffer redo-stack>> ;

: tab-width                             // void -> n
    current-buffer tab-width>> [ 8 ] unless* ;

: indent-size                           // void -> n
    current-buffer indent-size>> [ 4 ] unless* ;

: renumber
    first-line :> line!
    0 :> n!
    [ line next>> ] [
        n line number<<
        n 1+ n!
        line next>> line!
    ] while
    n line number<<
    line last-line! ;

: nth-line ( line-number )              // line-number -> line/f

    line-number 0 < [ f ] return-if

    first-line :> line!
    0 :> n!

    [ line n line-number < and ] [
        n 1+ n!
        line next>> line!
    ] while

    line
;

: insert-after ( line prev )            // line prev -> void
    // insert line after prev

    prev [ prev next>> ] [ first-line ] if :> next

    prev [
        line prev next<<
    ] [
        line dup first-line! top-line!
    ] if
    prev line prev<<

    next line next<<
    next [ line next prev<< ] [ line last-line! ] if
;

: insert-before ( line next )           // line next -> void
    // insert line before next

    next [ next prev>> ] [ f ] if :> prev

    prev [ line prev insert-after ] return-if

    // prev is null
    line first-line prev<<
    first-line line next<<
    line first-line!
;

: unlink ( line )                       // line -> void
    line next>> :> next
    line prev>> :> prev

    prev [ next prev next<< ] when
    next [ prev next prev<< ] when

    f line next<<
    f line prev<<

    renumber
;

winui? #if
: textview-rows                         // -> n
    winui-textview-rows ;
#else
: textview-rows                         // -> n
    terminal-rows 2 - ;
#endif

: bottom-line                           // -> line
    top-line :> line!
    0 :> i!

    [ i textview-rows 1- < ] [
        line next>> [ line! ] when*
        i 1+ i!
    ] while

    line
;

: bottom-line-number                    // -> n
    bottom-line number>> ;

: detab ( s )                           // string -> string'
    '\t' s string-index null? [ s ] return-if

    256 <sbuf> :> sb

    s [
        dup '\t' eq? [
            drop
            '\s' sb sbuf-push
            [ sb sbuf-length tab-width mod 0 eq? ] [ '\s' sb sbuf-push ] until
        ] [
            sb sbuf-push
        ] if
    ] each

    sb sbuf>string
;

: position-column ( pos )               // position -> column
    pos line>> :> line
    pos offset>> line text>> length min :> limit
    0 :> column!
    limit [
        line text>> string-nth '\t' eq? [
            column tab-width column tab-width mod - + column!
        ] [
            column 1+ column!
        ] if
    ] each-integer
    column ;

: dot-column                            // -> column
    dot position-column ;

: dot-row                               // -> n
    dot-line-number top-line-number - ;

: mark-column                           // -> column
    mark [ mark position-column ] [ f ] if ;

: line-selected? ( line )               // line -> ?
    mark null? [ f ] return-if
    dot mark make-region/2 :> region
    {
        {
            [ region begin-line line before? ]
            [ line region end-line before? ]
        }
        {
            [ region begin-line line eq? ]
            [ region begin-offset 0 eq? line region end-line before? and ]
        }
        // default
        [ f ]
    } cond ;

: line-starts-in-selection? ( line )    // line -> ?
    mark null? [ f ] return-if

    mark dot make-region/2 :> region
    line 0 make-position :> pos

    pos region in-region? ;

: line-is-partly-selected? ( line )     // line -> ?
    mark [
        line dot-line eq? line mark-line eq? or
    ] [ f ] if ;

: line-contains-selection? ( line )     // line -> ?
    mark [
        line dot-line eq? line mark-line eq? and
    ] [ f ] if ;

: insert-string-internal ( s )
    dot-line-head s + dot-line-tail + dot-line-text!
    dot-offset s length + dot-offset!
    t dot-line-changed!
;

: insert-line-separator-internal
    // insert line separator at dot
    // move dot past the inserted separator
    // no undo

    dot-line-tail make-line/1 :> new-line
    dot-line-head dot-line-text!
    new-line dot-line insert-after
    new-line dot-line!
    0 dot-offset!
;

: insert-multiline-string-internal ( s )        // string -> void
    s string-lines :> lines
    lines length :> len
    lines last :> last-line

    f :> line!
    lines [
        line!

        line insert-string-internal
        line last-line neq? [
            insert-line-separator-internal
        ] when
    ] each

    s last '\n' eq? [ insert-line-separator-internal ] when

    renumber
;

: insert-string ( s )                   // string -> void
    // insert string at dot
    // moves dot past inserted string
    // no undo

    '\n' s index [
        s insert-multiline-string-internal
    ] [
        s insert-string-internal
    ] if
;

: reframe?                              // -> ?
    dot-line-number
    top-line-number
    dup textview-rows 1- +
    between? not ;

: reframe
    textview-rows 2 /i verify-index :> i!
    dot-line :> line!

    [ i 0 > line prev>> and ] [
        line prev>> line!
        i 1- i!
    ] while

    line top-line!

    t repaint?!
;

: maybe-reframe reframe? [ reframe ] when ;

: current-mode                          // -> mode
    current-buffer mode>> ;

generic formatter                       // mode -> formatter

use: segments

: default-formatter
    [ make-segment 1array ] ;

unuse: segments

' default-formatter ' formatter set-default-method

generic identifier-char?                // char mode -> ?

: in-whitespace?                        // void -> ?
    dot-char whitespace? ;

: in-word?                              // void -> ?
    dot-char [ current-mode identifier-char? ] [ f ] if* ;

: not-in-word?                          // void -> ?
    dot-char [ current-mode identifier-char? not ] [ t ] if* ;

generic identifier-at-dot               // mode -> start/f string/f

generic initialize-buffer               // buffer mode -> void

: default-initialize-buffer             // buffer mode -> void
    2 ?enough
    2drop
;

' default-initialize-buffer ' initialize-buffer set-default-method
