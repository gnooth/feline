// Copyright (C) 2018-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors segments modes feral-colors feral-config ;
in: feline-mode

private

tuple: feline-mode
    formatter ;

method: feline-mode formatter           // mode -> formatter
    formatter>> ;

: feline-mode-identifier-char?          // char -> ?
    '\s' neq?
;

method: feline-mode identifier-char?    // char mode -> ?
    drop
    feline-mode-identifier-char? ;

: feline-mode-identifier-at-dot         // void -> start/f string/f

    { [ mark ] [ mark-line dot-line eq? ] } && [
        mark dot make-region/2 begin-offset
    ] [
        dot-offset dot-line-length 1- min 0 max
    ] if :> offset

    offset dot-line-text [ feline-mode-identifier-char? not ] find-last-from drop :> start!

    // get to first non-blank char
    start [ start 1+ start! ] [ 0 start! ] if

    start dot-line-text string-skip-to-whitespace // -> index/f
    dot-line-length or
    [
        start swap dot-line-text string-substring // -> string
        start swap                                // -> start string
    ] [
        f f
    ] if* ;

method: feline-mode identifier-at-dot   // mode -> start/f string/f
    drop
    feline-mode-identifier-at-dot ;

"// " constant feline-mode-comment-start

method: feline-mode comment-start // mode -> string
    drop
    feline-mode-comment-start ;

feline-mode-comment-start length constant comment-start-length

: feline-mode-toggle-line-comment
    dot-line-text :> text
    text indentation-string :> indentation-string
    indentation-string length :> indentation-length
    indentation-length text tail :> content

    editor:add-undo-line-edit

    feline-mode-comment-start content head? [
        // uncomment
        indentation-string
        comment-start-length content tail +
        dot-line-text!
        {
            {
                [ dot-offset indentation-length comment-start-length + >= ]
                [ dot-offset comment-start-length - dot-offset! ]
            }
            {
                [ dot-offset indentation-length >= ]
                [ indentation-length dot-offset! ]
            }
            // dot-offset < indent-length
            [ ]
        } cond
    ] [
        // comment
        indentation-string
        feline-mode-comment-start +
        content +
        dot-line-text!
        dot-offset indentation-length >= [
            dot-offset comment-start-length + dot-offset!
        ] when
    ] if

    modified
    t dot-line-changed!
;

: feline-mode-expand-if
    mark ?exit
    "if" dot-line-head tail? not ?exit

    editor:add-undo-line-edit

    "if" length dot-line-head head*
    "[  ] [  ] if" +
    dot-line-tail +
    dot-line-text!

    t dot-line-changed! ;

: feline-mode-expand-when
    mark ?exit
    "when" dot-line-head tail? not ?exit

    editor:add-undo-line-edit

    "when" length dot-line-head head*
    "[  ] when" +
    dot-line-tail +
    dot-line-text!

    dot-offset 2 - dot-offset!
    t dot-line-changed! ;

: feline-mode-expand
    mark ?exit
    dot-offset zero? ?exit

    dot-offset :> old-dot-offset

    dot-offset 1- dot-offset!

    [ in-word? dot-offset zero? not and ] [
        dot-offset 1- dot-offset!
    ] while

    not-in-word? [ dot-offset 1+ dot-offset! ] when

    dot-offset old-dot-offset dot-line-text string-substring

    old-dot-offset dot-offset!

    {
        { "when" [ feline-mode-expand-when ] }
        { "if"   [ feline-mode-expand-if ]   }
        // default
        [ "No expansion for %S" format mini:message ]
    } case ;

global feline-mode-local-map

winui? #if

use: feral-key

: initialize-local-map
    128 <hashtable> :> m
    ' feline-mode-toggle-line-comment   ctrl-/      m set-at
    ' feline-mode-expand                ctrl-space  m set-at
    m feline-mode-local-map!
;

initialize-local-map

unuse: feral-key

#endif

method: feline-mode initialize-buffer   // buffer mode -> void
    2 ?enough
    drop :> buf
    feline-mode-local-map buf local-map<<
    4 buf indent-size<<
;

{
    "!>"
    "'"
    "("
    ")"
    ":"
    ":>"
    ";"
    "["
    "]"
    "constant"
    "defer"
    "f"
    "generic"
    "global"
    "in:"
    "method:"
    "private"
    "private:"
    "public"
    "public:"
    "special:"
    "symbol:"
    "syntax:"
    "t"
    "test:"
    "tuple:"
    "unuse:"
    "use:"
    "using:"
    "var"
    "vector{"
    "{"
    "}"
} constant syntax-words

{
    ":"
    "constant"
    "defer"
    "generic"
    "global"
    "method:"
    "private:"
    "public:"
    "syntax:"
    "test:"
    "tuple:"
    "var"
} constant defining-words

{
    "&&"
    "?exit"
    "bi"
    "bi@"
    "case"
    "cleave"
    "cond"
    "each"
    "each-index"
    "each-integer"
    "filter"
    "find"
    "find-from"
    "find-last-from"
    "if"
    "if*"
    "keep"
    "loop"
    "return-if"
    "time"
    "times"
    "tri"
    "unless"
    "unless*"
    "until"
    "when"
    "when*"
    "while"
    "||"
} constant combinators

32 code-char constant space-char
34 code-char constant quote-char

: non-blank?                            // string -> ?
    1 ?enough
    verify-string
    [ space-char neq? ] find drop ;

: skip-quoted-string                    // start-index string -> index/f
    2dup string-length >= [ 2drop f ] return-if

    :> s
    :> start

    start 1+ s string-tail <string-iterator> :> iter

    f :> this-char!
    this-char :> last-char!
    f :> done?!

    [
        this-char last-char!
        iter string-iterator-next this-char!
        this-char [ t done?! ] unless
        done?
    ] [
        this-char '\x22' eq? [
            last-char '\' neq? [
                t done?!
            ] when
        ] when
    ] until

    start 1+ iter string-iterator-index +
;

: string->segments ( s )                // string -> segments
    s string-length :> len
    0 :> start!
    0 :> end!
    16 <vector> :> v
    f :> c!

    [ end len fixnum-fixnum< ] [
        start s string-nth c!
        {
            { [ c space-char eq? ] [ start s string-skip-whitespace len or end! ] }
            { [ c quote-char eq? ] [ start s skip-quoted-string len or end! ] }
            [ start s string-skip-to-whitespace len or end! ]
        } cond
        start end s string-substring start make-segment v vector-push
        end start!
    ] while

    v
;

winui? #if

  0 255 255 make-colorref constant color-syntax
255 165   0 make-colorref constant color-name
  0 170   0 make-colorref constant color-string
  0 153 153 make-colorref constant color-combinator
255   0   0 make-colorref constant color-preprocessor

#else

use: ansi-color

192 192 192 rgb-foreground-prefix constant text-prefix
128 128   0 rgb-foreground-prefix constant comment-prefix
  0 255 255 rgb-foreground-prefix constant syntax-prefix
255 165   0 rgb-foreground-prefix constant name-prefix
  0 170   0 rgb-foreground-prefix constant string-prefix
  0 153 153 rgb-foreground-prefix constant combinator-prefix
255   0   0 rgb-foreground-prefix constant preprocessor-prefix

unuse: ansi-color

#endif

var in-comment?

var last-segment-text

winui? #if

: winui-format-segment ( segment )
    in-comment? [
        segment text>> { "--" "//" "///" } member? in-comment?!
    ] unless

    in-comment? [
        color-comment segment format<<
    ] return-if

    // not a comment
    last-segment-text defining-words member? [
        color-name segment format<<
    ] return-if

    segment text>> syntax-words member? [
        color-syntax segment format<<
    ] return-if

    segment text>> string-first-char quote-char eq? [
        color-string segment format<<
    ] return-if

    segment text>> combinators member? [
        color-combinator segment format<<
    ] return-if

    segment text>> { "#if" "#else" "#endif" "#ifdef" "#ifndef" } member? [
        color-preprocessor segment format<<
    ] return-if

    // default
    color-text segment format<<
;

: winui-format-segments ( segments )
    f in-comment?!
    "" last-segment-text!
    segments [
        dup winui-format-segment
        text>> dup non-blank? [ last-segment-text! ] [ drop ] if
    ] each

    segments
;

: winui-feline-format-line              // string -> segments
    string->segments
    winui-format-segments
;

public

: initialize-feline-mode
    feline-mode make-instance :> m
    ' winui-feline-format-line m formatter<<
    m feline-extension modes set-at
;

#else

: format-segment ( segment )            // segment -> void
    in-comment? [
        segment text>> { "--" "//" "///" } member? in-comment?!
    ] unless

    in-comment? [
        comment-prefix segment format<<
    ] return-if

    // not a comment
    last-segment-text defining-words member? [
        name-prefix segment format<<
    ] return-if

    segment text>> syntax-words member? [
        syntax-prefix segment format<<
    ] return-if

    segment text>> string-first-char quote-char eq? [
        string-prefix segment format<<
    ] return-if

    segment text>> combinators member? [
        combinator-prefix segment format<<
    ] return-if

    segment text>> { "#if" "#else" "#endif" "#ifdef" "#ifndef" } member? [
        preprocessor-prefix segment format<<
    ] return-if

    // default
    text-prefix segment format<<
;

: format-segments ( segments )          // segments -> segments
    f in-comment?!
    "" last-segment-text!
    segments [
        dup format-segment
        text>> dup non-blank? [ last-segment-text! ] [ drop ] if
    ] each
;

: feline-format-line                    // string -> segments
    string->segments                    // -> vector
    dup format-segments
;

public

: initialize-feline-mode
    feline-mode make-instance :> m
    ' feline-format-line m formatter<<
    m feline-extension modes set-at
;

#endif

initialize-feline-mode
