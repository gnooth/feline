-- Copyright (C) 2017 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: editor

empty

feline-home "feral" path-append add-source-directory

using: feline accept-string ;

global: current-buffer
global: repaint?
global: dot-line-changed?
global: bindings

global: current-command
global: last-command

global: done?

"\n"   >constant: LF
"\r\n" >constant: CR+LF

tuple: position
    line-number
    offset ;

tuple: buffer
    lines
    dot
    mark
    top-line-number
    goal-column
    filename
    autosave-filename
    mod-count
    mod-count-last-save
    eol
    undo-stack ;

global: buffer-list

: make-buffer ( -- buffer )
    buffer make-instance >local: buf

    0 buf buffer-top-line-number!
    0 buf buffer-goal-column!
    0 buf buffer-mod-count!
    0 buf buffer-mod-count-last-save!
    LF buf buffer-eol!
    100 <vector> buf buffer-undo-stack!

    buf
;

: current-buffer-lines ( -- vector ) current-buffer buffer-lines ;

: set-current-buffer-lines ( vector -- ) current-buffer buffer-lines! ;

: dot ( -- position ) current-buffer buffer-dot ;

: set-dot ( position -- ) current-buffer buffer-dot! ;

: mark ( -- position ) current-buffer buffer-mark ;

: set-mark ( position -- ) current-buffer buffer-mark! ;

: unmark ( -- ) mark [ f set-mark t !> repaint? ] when ;

: top-line-number ( -- n ) current-buffer buffer-top-line-number ;

: set-top-line-number ( n -- ) current-buffer buffer-top-line-number! ;

: goal-column ( -- n ) current-buffer buffer-goal-column ;

: set-goal-column ( n -- ) current-buffer buffer-goal-column! ;

: mod-count ( -- n ) current-buffer buffer-mod-count ;

: set-mod-count ( n -- ) current-buffer buffer-mod-count! ;

: mod-count-last-save ( -- n ) current-buffer buffer-mod-count-last-save ;

: set-mod-count-last-save ( n -- ) current-buffer buffer-mod-count-last-save! ;

: undo-stack ( -- vector ) current-buffer buffer-undo-stack ;

: create-buffer ( filename -- buffer )
    buffer make-instance
    [ buffer-filename! ] keep
;

: editor-filename ( -- filename ) current-buffer buffer-filename ;

: dot-line-number ( -- line-number ) dot position-line-number ;

: dot-line-number! ( line-number -- ) dot position-line-number! ;

: mark-line-number ( -- line-number ) mark [ mark position-line-number ] [ f ] if ;

: mark-line-number! ( line-number -- ) mark [ position-line-number! ] when* ;

: next-line-number ( -- line-number ) dot-line-number 1 + ;

: dot-offset ( -- ) dot position-offset ;

: dot-offset! ( n -- ) dot position-offset! ;

: mark-offset ( -- ) mark position-offset ;

: mark-offset! ( n -- ) mark position-offset! ;

: hide-cursor ( -- ) esc[ "?25l" write-string-escaped ;

: show-cursor ( -- ) esc[ "?25h" write-string-escaped ;

: reverse ( -- ) esc[ "7m" write-string-escaped ;

: normal ( -- ) esc[ "m" write-string-escaped ;

: buffer-modified? ( buffer -- )
    dup buffer-mod-count swap buffer-mod-count-last-save neq? ;

: modified? ( -- ) mod-count mod-count-last-save neq? ;

: modified ( -- ) mod-count 1 + set-mod-count ;

: buffer-line-count ( -- n ) current-buffer-lines length ;

: buffer-nth-line ( n -- string ) current-buffer-lines vector-nth ;

: buffer-nth-line! ( string n -- ) current-buffer-lines vector-set-nth ;

: buffer-insert-nth-line ( string n -- ) current-buffer-lines vector-insert-nth ;

: buffer-last-line ( -- string ) current-buffer-lines vector-last ;

: dot-line ( -- string ) dot-line-number buffer-nth-line ;

: dot-line! ( string -- ) dot-line-number buffer-nth-line! ;

: dot-line-length ( -- n ) dot-line string-length ;

: dot-line-head ( -- string ) dot-line dot-offset string-head ;

: dot-line-tail ( -- string ) dot-line dot-offset string-tail ;

: lines-per-page ( -- n ) terminal-height 2 - ;

: bottom-line-number ( -- n ) top-line-number lines-per-page 1 - + buffer-line-count min ;

: tab-width ( -- n ) 8 ;

: position-column ( position -- column )
    >local: pos
    pos position-line-number buffer-nth-line >local: line
    pos position-offset line length min >local: limit
    0 >local: column
    limit [
        line string-nth 9 code-char eq? [
            column
            tab-width column tab-width mod -
            + !> column
        ] [
            column 1 + !> column
        ] if
    ] each-integer
    column ;

: dot-column ( -- column ) dot position-column ;

: mark-column ( -- column ) mark [ mark position-column ] [ f ] if ;

: .cursor ( -- )
    dot-column
    dot-line-number top-line-number -
    dup 0 >= assert-true
    at-xy ;

: dot-y ( -- )
    dot-line-number top-line-number -
    dup 0 >= assert-true ;

: detab ( string -- string' )
    >local: s
    9 code-char s string-index >local: i
    i f eq? [ s ] return-if

    256 <sbuf> >local: sb

    s [
        dup 9 code-char eq? [
            drop
            32 code-char sb sbuf-push
            [ sb sbuf-length 8 mod 0 eq? ] [ 32 code-char sb sbuf-push ] until
        ] [
            sb sbuf-push
        ] if
    ] each

    sb sbuf>string
;

: paint-line ( y -- )
    >local: y

    0 y at-xy
    top-line-number y + >local: line-number

    line-number buffer-nth-line detab >local: detabbed-text

    output-style

    line-number mark-line-number eq? [
        0 dot-column detabbed-text string-substring write
        reverse
        dot-column mark-column detabbed-text string-substring write
        normal
        detabbed-text mark-column string-tail write
        terminal-width detabbed-text string-length - spaces
    ] [
        detabbed-text length terminal-width < [
            detabbed-text write
            terminal-width detabbed-text string-length - spaces
        ] [
            0 terminal-width detabbed-text substring write
        ] if
    ] if
;

: redisplay-line ( y -- )
    >local: y
    top-line-number y + buffer-line-count < [
        y paint-line
    ] [
        0 y at-xy terminal-width spaces
    ] if
;

: status-y ( -- n ) terminal-height 2 - ;

: status ( -- )
    reverse
    0 status-y at-xy
    modified? [ '*' write-char ] [ space ] if
    editor-filename write-string
    dot-line-number 1 +
    dot-column 1 +
    "Line %d Col %d " format
    terminal-width over length - >local: x
    x editor-filename length 1 + - 1 max spaces
    write-string
    normal
;

: clear-status-line ( -- ) 0 status-y at-xy clear-to-eol ;

: message-y ( -- n ) status-y 1 + ;

: message ( string -- ) 0 message-y at-xy write-string ;

: clear-message-line ( -- ) 0 message-y at-xy clear-to-eol ;

: update-display ( -- )
    hide-cursor
    repaint? [
        0 0 at-xy
        lines-per-page [ redisplay-line ] each-integer
        f !> repaint?
    ] [
        dot-line-changed? [
            dot-y redisplay-line
            f !> dot-line-changed?
        ] when
    ] if
    status
    .cursor
    mark [ show-cursor ] unless
;

: adjust-cursor-x ( -- )
    goal-column dot-offset!
    dot-offset dot-line-length > [
        dot-line-length dot-offset!
    ] when
;

: reframe? ( -- ? )
    dot-line-number
    top-line-number
    dup lines-per-page 1 - +
    between? not ;

: reframe ( -- )
    dot-line-number
    lines-per-page 2 /i verify-index
    - 0 max set-top-line-number
    t !> repaint?
;

: maybe-reframe ( -- ) reframe? [ reframe ] when ;

tuple: undo-record
    mod-count
    action
    dot
    mark
    data ;

symbol: +move+
symbol: +line-edit+
symbol: +delete-line-separator+
symbol: +insert-line-separator+

tuple: compound-undo
    records ( vector ) ;

: new-compound-undo ( -- compound-undo )
    compound-undo make-instance
    4 <vector> over compound-undo-records!
;

: add-undo ( undo-record compound-undo -- )
    compound-undo-records vector-push
;

special: +compound-undo+

: push-undo ( undo-record -- )
    +compound-undo+ get [ add-undo ] [ undo-stack vector-push ] if* ;

: with-compound-undo ( quotation -- )
    [
        new-compound-undo +compound-undo+ set
        call
        +compound-undo+ get
    ] with-dynamic-scope
    push-undo
;

: pop-undo ( -- undo-record ) undo-stack vector-pop ;

: reset-undo ( -- ) 0 undo-stack vector-set-length ;

: copy-position ( position -- copy )
    [ position-line-number ] [ position-offset ] bi
    position make-instance
    [ position-offset! ] keep
    [ position-line-number! ] keep ;

: copy-dot ( -- position ) dot copy-position ;

: copy-mark ( -- position ) mark [ copy-position ] [ f ] if* ;

: new-undo-record ( -- undo-record )
    undo-record make-instance
    mod-count over undo-record-mod-count!
    copy-dot over undo-record-dot!
    copy-mark over undo-record-mark!
;

: add-undo-move ( -- )
    new-undo-record
    +move+ over undo-record-action!
    push-undo
;

: undo-move ( undo-record -- )
    mark [ t !> repaint? ] when

    [ undo-record-mod-count set-mod-count ]
    [ undo-record-dot set-dot ]
    [ undo-record-mark set-mark ]
    tri

    mark [ t !> repaint? ] when
;

: add-undo-line-edit ( -- )
    new-undo-record
    +line-edit+ over undo-record-action!
    dot-line over undo-record-data!
    push-undo
;

: undo-line-edit ( undo-record -- )
    [ undo-record-mod-count set-mod-count ]
    [ undo-record-dot set-dot ]
    [ undo-record-data dot-line! ]
    tri

    t !> dot-line-changed?
;

: add-undo-delete-line-separator ( -- )
    new-undo-record
    +delete-line-separator+ over undo-record-action!
    dot-line
    dot-line-number 1 + buffer-nth-line
    2array
    over undo-record-data!
    push-undo
;

: undo-delete-line-separator ( undo-record -- )
    dup
    [ undo-record-mod-count set-mod-count ]
    [ undo-record-dot set-dot ]
    bi
    undo-record-data ( 2array )
    dup array-first dot-line!
    array-second dot-line-number 1 + buffer-insert-nth-line
    t !> repaint?
;

: add-undo-insert-line-separator ( -- )
    new-undo-record
    +insert-line-separator+ over undo-record-action!
    dot-line over undo-record-data!
    push-undo
;

: undo-insert-line-separator ( undo-record -- )
    [ undo-record-mod-count set-mod-count ]
    [ undo-record-dot set-dot ]
    [ undo-record-data dot-line! ]
    tri
    dot-line-number 1 + current-buffer-lines vector-remove-nth!
    t !> repaint?
;

: undo1 ( undo-record -- )
    dup undo-record-action
    {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ undo-delete-line-separator ] }
        { +insert-line-separator+ [ undo-insert-line-separator ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: undo ( -- )
    undo-stack empty? [
        "Nothing to undo" message
    ] [
        pop-undo dup compound-undo? [
            compound-undo-records vector-reverse! ' undo1 each
        ] [
            undo1
        ] if
    ] if
;

: beginning-of-buffer ( -- )
    add-undo-move

    unmark

    0 dot-line-number!
    0 dot-offset!

    0 set-top-line-number
    0 set-goal-column
    t !> repaint?
;

: end-of-buffer ( -- )
    add-undo-move

    unmark

    buffer-line-count 1 - 0 max dot-line-number!
    buffer-line-count lines-per-page - 0 max set-top-line-number
    dot-line-length dot-offset!
    dot-offset set-goal-column
    t !> repaint?
;

: gotoline ( -- )
    0 message-y at-xy
    "Line number: " accept-string >local: response
    clear-message-line
    response string>number [
        1- 0 max buffer-line-count 1- min
        dup dot-line-number <> [
            add-undo-move
            unmark
            dot-line-number!
            0 dot-offset!
            maybe-reframe
        ] [
            drop
        ] if
    ] when*
;

: do-home ( -- )
    add-undo-move

    unmark

    0 dot-offset!
    0 set-goal-column
;

: end-of-line ( -- )
    add-undo-move

    unmark

    dot-line length dot-offset!
    dot-offset set-goal-column
;

: beginning-of-block
    mark [ mark-offset dot-offset min dot-offset! ] when
;

: end-of-block
    mark [ mark-offset dot-offset max dot-offset! ] when
;

: do-left ( -- )
    last-command ' do-left eq? [ add-undo-move ] unless

    mark [
        beginning-of-block
        unmark
    ] return-if

    dot-offset 0 > [
        dot-offset 1 - dot-offset!
        dot-offset set-goal-column
    ] [
        dot-line-number 0 > [
            dot-line-number 1 - dot-line-number!
            dot-line-length dot-offset!
            dot-offset set-goal-column
            reframe? [
                dot-line-number set-top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-right ( -- )
    last-command ' do-right eq? [ add-undo-move ] unless

    mark [
        end-of-block
        unmark
    ] return-if

    dot-offset dot-line length < [
        dot-offset 1+ dot-offset!
        dot-offset set-goal-column
    ] [
        dot-line-number buffer-line-count 1 - < [
            dot-line-number 1 + dot-line-number!
            0 dot-offset!
            dot-offset set-goal-column
            reframe? [
                dot-line-number lines-per-page 1 - - set-top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-down ( -- )
    last-command ' do-down eq? [ add-undo-move ] unless

    dot-line-number buffer-line-count 1- < [
        dot-line-number 1+ dot-line-number!
        unmark
        reframe? [
            dot-line-number lines-per-page 1- - set-top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-up ( -- )
    last-command ' do-up eq? [ add-undo-move ] unless

    dot-line-number 0 > [
        dot-line-number 1 - dot-line-number!
        unmark
        reframe? [
            dot-line-number set-top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-window-up
    top-line-number 0 > [
        top-line-number 1 - set-top-line-number
        dot-line-number bottom-line-number > [
            add-undo-move
            bottom-line-number dot-line-number!
            0 dot-offset!
        ] when
        t !> repaint?
    ] when
;

: do-window-down
    top-line-number buffer-line-count 1 - < [
        top-line-number 1 + set-top-line-number
        dot-line-number top-line-number < [
            add-undo-move
            top-line-number dot-line-number!
            0 dot-offset!
        ] when
        t !> repaint?
    ] when
;

: do-page-down
    add-undo-move

    dot-y >local: goal-y

    dot-line-number lines-per-page +
    buffer-line-count 1 - min
    dot-line-number!

    dot-line-number goal-y - 0 max set-top-line-number
    t !> repaint?
    adjust-cursor-x
;

: do-page-up
    add-undo-move

    dot-y >local: goal-y

    dot-line-number lines-per-page - 0 max dot-line-number!

    dot-line-number goal-y - 0 max set-top-line-number
    t !> repaint?
    adjust-cursor-x
;

: insert-line-separator ( -- )
    dot-offset dot-line-length <= [
        add-undo-insert-line-separator
        dot-line-tail dot-line-number 1 + buffer-insert-nth-line
        dot-line-head dot-line!
        dot-line-number 1 + dot-line-number!
        0 dot-offset!
        0 set-goal-column
        modified
        t !> repaint?
    ] when
;

: insert-spaces ( n -- )
    -- no undo

    >local: n
    dot-line-head string>sbuf >local: sb
    n [ 32 code-char sb sbuf-push ] times
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line!
    dot-offset n + dot-offset!
    t !> dot-line-changed?
    modified
;

: do-tab ( -- )
    add-undo-line-edit
    4 dot-offset 4 mod - insert-spaces
;

: get-indentation-column ( line -- column )
    dup empty? [ drop 0 ] return-if

    detab
    [ char-code 32 > ] find             -- index/f element/f
    [ drop 0 ] unless
;

: delete-indentation ( line -- line' )
    dup empty? [ ] return-if

    >local: line

    line [ char-code 32 > ] find        -- index/f element/f
    [ line swap string-tail ] [ drop "" ] if
;

: newline-and-indent ( -- )
    dot-line get-indentation-column >local: indent-col

    [
        insert-line-separator
        add-undo-line-edit
        dot-line delete-indentation dot-line!
        indent-col 0 > [
            indent-col insert-spaces
        ] when
    ] with-compound-undo
;

: string-remove-nth ( n string -- string' )
    check-bounds

    >local: s
    >local: n

    s n string-head
    n 1 + s string-length < [
        s n 1 + string-tail string-append
    ] when
;

: delete-normal-char ( -- )
    add-undo-line-edit

    dot-offset dot-line string-remove-nth dot-line!
    t !> dot-line-changed?
;

: delete-line-separator ( -- )
    dot-line-number buffer-line-count 1 - < [
        dot-offset dot-line-length = [
            add-undo-delete-line-separator
            dot-line-number 1 + buffer-nth-line
            dot-line swap string-append dot-line!
            dot-line-number 1 + current-buffer-lines vector-remove-nth!
            t !> repaint?
        ] when
    ] when
;

: do-delete ( -- )
    dot-offset dot-line-length < [
        delete-normal-char
    ] [
        delete-line-separator
    ] if
    modified
;

: do-bs ( -- )
    {
        {
            [ dot-offset 0 > ]
            [
                add-undo-line-edit
                dot-offset 1 -
                [ dot-line string-remove-nth dot-line! ] [ dot-offset! ] bi
                t !> dot-line-changed?
                modified
            ]
        }
        {
            [ dot-line-number 0 > ]
            [
                [
                    new-compound-undo +compound-undo+ set
                    do-left
                    delete-line-separator
                    modified
                    +compound-undo+ get
                ] with-dynamic-scope
                push-undo
            ]
        }
        -- do nothing if dot is at beginning of buffer
        [ ]
    } cond
;

: do-normal-char ( char -- )
    current-command assert-false
    ' do-normal-char !> current-command
    last-command ' do-normal-char eq? [ add-undo-line-edit ] unless

    dot-line-head string>sbuf >local: sb
    sb sbuf-push
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line!
    dot-offset 1 + dot-offset!
    t !> dot-line-changed?
    modified
    dot-offset set-goal-column
;

: kill-line ( -- )
    dot-line-tail length zero? [
        delete-line-separator
    ] [
        add-undo-line-edit
        dot-line-head dot-line!
        t !> dot-line-changed?
        modified
    ] if
;

: make-backup ( -- )
    editor-filename dup file-exists?
    [ dup "~" string-append copy-file ] [ drop ] if
;

: do-save ( -- )
    output-style
    "Saving..." message

    make-backup

    current-buffer buffer-filename file-create-write >local: fd
    current-buffer buffer-eol >local: eol

    -- write out all lines but the last followed by eol
    buffer-line-count 1 - [
        buffer-nth-line fd file-write-string
        eol fd file-write-string
    ] each-integer

    -- write out last line, no eol
    buffer-last-line fd file-write-string

    fd file-close

    mod-count set-mod-count-last-save

    "Saving...done" message
;

: do-quit ( -- )
    buffer-list ' buffer-modified? count >local: n

    n zero? [
        t !> done?
    ] [
        n dup 1 > "s" "" ?
        "Really exit with %s modified buffer%s? (yes or no) " format
        accept-string "yes" string= !> done?
        clear-message-line
    ] if
;

: confirm-kill-current-buffer ( -- ? )
    f >local: confirmed?

    modified? [
        0 message-y at-xy prompt-style "Save file? (y or n) " write-string
        input-style key 'y' eq? [ do-save ] when
        clear-message-line
    ] when

    modified? [
        0 message-y at-xy
        "Abandon changes? (yes or no) " accept-string
        "yes" = [ t !> confirmed? ] when
        clear-message-line
    ] when

    confirmed?
;

: kill-current-buffer
    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq
    >local: n

    n buffer-list vector-remove-nth!

    n buffer-list length < [ n 1 - !> n ] unless

    n buffer-list vector-nth !> current-buffer
    t !> repaint?
;

: kill-buffer ( -- )
    f >local: confirmed?

    modified? [ confirm-kill-current-buffer !> confirmed? ] when

    modified? not confirmed? or [
        buffer-list length 1 = [
            0 buffer-list vector-set-length
            t !> done?
        ] [
            kill-current-buffer
        ] if
    ] when
;

: initialize-empty-buffer ( -- )
    "untitled" create-buffer !> current-buffer
    LF current-buffer buffer-eol!
    64 <vector> set-current-buffer-lines
    "" current-buffer-lines vector-push
    position make-instance set-dot
    0 dot-offset!
    0 dot-line-number!
    0 set-top-line-number

    0 set-mod-count 0 set-mod-count-last-save
    0 set-goal-column
;

: initialize-buffer ( filename line-number -- buf )
    verify-index  >local: line-number
    verify-string >local: filename

    make-buffer >local: buf

    filename buf buffer-filename!

    filename file-contents

    -- detect eol
    13 code-char over string-index CR+LF LF ? buf buffer-eol!

    dup string-lines verify-vector >local: lines

    string-last-char 10 code-char eq? [ "" lines vector-push ] when

    lines buf buffer-lines!

    position make-instance >local: pos

    0 pos position-offset!
    line-number 1 - 0 max lines length 1 - min pos position-line-number!

    pos buf buffer-dot!

    buf buffer-list vector-push

    buf
;

: find-file-to-edit ( arg -- path/f )
    >local: arg

    arg find-file [
        arg ensure-feline-extension find-file
    ] unless*
;

: find-buffer ( filename -- buffer/f )
    >local: filename

    buffer-list [ buffer-filename filename = ] find     -- index/f element/f
    nip
;

: open-file ( -- )
    0 message-y at-xy "File: " accept-string >local: arg
    clear-message-line

    arg find-file-to-edit >local: filename

    filename [
        filename find-buffer [
            !> current-buffer
            t !> repaint?
        ] [
            filename 1 initialize-buffer !> current-buffer
            t !> repaint?
        ] if*
    ] when
;

: next-buffer ( -- )
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1 + dup buffer-list length < [ drop 0 ] unless

    buffer-list vector-nth !> current-buffer
    t !> repaint?
;

: previous-buffer ( -- )
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1 - dup 0 >= [ drop buffer-list length 1 - ] unless

    buffer-list vector-nth !> current-buffer
    t !> repaint?
;

use: search

: bind-key ( key symbol -- ) swap bindings set-at ;

: lookup-key ( key -- symbol/f ) bindings at ;

: initialize-bindings ( -- )
    32 <hashtable> !> bindings

    key:del             ' do-bs                         bind-key        -- Linux
    key:backspace       ' do-bs                         bind-key        -- Windows
    key:delete          ' do-delete                     bind-key
    key:home            ' do-home                       bind-key
    key:end             ' end-of-line                   bind-key
    key:left            ' do-left                       bind-key
    key:right           ' do-right                      bind-key
    key:up              ' do-up                         bind-key
    key:down            ' do-down                       bind-key
    key:ctrl-up         ' do-window-up                  bind-key
    key:ctrl-down       ' do-window-down                bind-key
    key:pageup          ' do-page-up                    bind-key
    key:pagedown        ' do-page-down                  bind-key
    key:ctrl-home       ' beginning-of-buffer           bind-key
    key:ctrl-end        ' end-of-buffer                 bind-key
    key:ctrl-g          ' gotoline                      bind-key
    key:ctrl-q          ' do-quit                       bind-key
    key:ctrl-s          ' do-save                       bind-key
    key:ctrl-w          ' kill-buffer                   bind-key
    key:enter           ' newline-and-indent            bind-key
    key:ctrl-f          ' do-find                       bind-key
    key:f3              ' do-find-again                 bind-key
    key:tab             ' do-tab                        bind-key
    key:ctrl-k          ' kill-line                     bind-key
    key:ctrl-z          ' undo                          bind-key
    key:ctrl-u          ' undo                          bind-key
    key:escape          ' quit                          bind-key
    key:ctrl-o          ' open-file                     bind-key
    key:alt-right       ' next-buffer                   bind-key
    key:alt-left        ' previous-buffer               bind-key
;

: do-command ( -- ) lookup-key [ dup !> current-command call-symbol ] when* ;

: dispatch ( key -- )
    current-command !> last-command
    f !> current-command
    dup printable-char? [ do-normal-char ] [ do-command ] if ;

: edit-loop ( -- )
    f !> done?
    [ done? ] [
        update-display
        ekey
        clear-message-line
        dispatch
    ] until
;

: initialize-editor ( -- )
    16 <vector> !> buffer-list
    bindings [ initialize-bindings ] unless
;

: edit1 ( -- )
    use-alternate-screen-buffer

    page
    normal
    maybe-reframe
    t !> repaint?

    edit-loop

    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor

    use-default-screen-buffer
;

: edit-file ( arg -- )
    >local: arg

    arg find-file-to-edit [
        initialize-editor
        0 initialize-buffer !> current-buffer
        edit1
    ] [
        arg error-file-not-found
    ] if*
;

: edit-definition ( symbol -- )
    initialize-editor
    symbol-location 2dup and
    [ initialize-buffer !> current-buffer edit1 ] [ 2drop ] if
;

: edit-new ( -- )
    initialize-editor
    initialize-empty-buffer
    edit1
;

: edit ( -- )
    parse-token dup [
        find-name [ edit-definition ] [ edit-file ] if
    ] [
        drop edit-new
    ] if
;

: ed ( -- )
    page
    normal
    t !> repaint?
    edit-loop
    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor
;
