using: feline ;
in: editor

empty

feline-home "feral" path-append add-source-directory

using: feline accept-string ;

global: current-buffer
global: mod-count
global: mod-count-last-save
global: buffer-lines
global: top-line-number
global: dot
global: repaint?
global: dot-line-changed?
global: bindings
global: done?

0 >global: goal-x

"\n"   >constant: LF
"\r\n" >constant: CR+LF

tuple: buffer filename autosave-filename eol ;

: new-buffer ( -- ) buffer make-instance ;

: create-buffer ( filename -- buffer )
    buffer make-instance
    [ buffer-filename! ] keep
;

: editor-filename ( -- filename ) current-buffer buffer-filename ;

tuple: position line-number offset ;

: dot-line-number ( -- line-number ) dot position-line-number ;

: dot-line-number! ( line-number -- ) dot position-line-number! ;

: next-line-number ( -- line-number ) dot-line-number 1 + ;

: dot-offset ( -- ) dot position-offset ;

: dot-offset! ( n -- ) dot position-offset! ;

: hide-cursor ( -- ) esc[ "?25l" write-string ;

: show-cursor ( -- ) esc[ "?25h" write-string ;

: reverse ( -- ) esc[ "7m" write-string ;

: normal ( -- ) esc[ "m" write-string ;

: modified? ( -- ) mod-count mod-count-last-save neq? ;

: modified ( -- ) mod-count 1 + !> mod-count ;

: buffer-line-count ( -- n ) buffer-lines length ;

: buffer-nth-line ( n -- string ) buffer-lines vector-nth ;

: buffer-nth-line! ( string n -- ) buffer-lines vector-set-nth ;

: buffer-insert-nth-line ( string n -- ) buffer-lines vector-insert-nth ;

: buffer-last-line ( -- string ) buffer-lines vector-last ;

: dot-line ( -- string ) dot-line-number buffer-nth-line ;

: dot-line! ( string -- ) dot-line-number buffer-nth-line! ;

: dot-line-length ( -- n ) dot-line string-length ;

: dot-line-head ( -- string ) dot-line dot-offset string-head ;

: dot-line-tail ( -- string ) dot-line dot-offset string-tail ;

: lines-per-page ( -- n ) #rows 2 - ;

: .cursor ( -- )
    dot-offset
    dot-line-number top-line-number -
    dup 0 >= assert-true
    at-xy ;

: dot-y ( -- )
    dot-line-number top-line-number -
    dup 0 >= assert-true ;

: detab ( string -- string' )
    >local: s
    9 s string-index >local: i
    i f eq? [ s ] return-if

    256 <sbuf> >local: sb

    s [
        dup 9 eq? [
            drop
            32 sb sbuf-push
            [ sb sbuf-length 8 mod 0 eq? ] [ 32 sb sbuf-push ] until
        ] [
            sb sbuf-push
        ] if
    ] each

    sb sbuf>string
;

: .line ( y -- )
    0 over at-xy
    top-line-number + buffer-nth-line

    detab

    dup length #cols < [
        dup write
        length #cols swap - spaces
    ] [
        0 #cols rot substring write
    ] if
;

: redisplay-line ( y -- )
    >local: y
    top-line-number y + buffer-line-count < [
        y .line
    ] [
        0 y at-xy #cols spaces
    ] if
;

: status-y ( -- n ) #rows 2 - ;

: status ( -- )
    reverse
    0 status-y at-xy
    modified? [ '*' write-char ] [ space ] if
    editor-filename write-string
    dot-line-number 1 +
    dot-offset 1 +
    "Line %d Col %d " format
    #cols over length - >local: x
    x editor-filename length 1 + - 1 max spaces
    write-string
    normal
;

: clear-status-line ( -- ) 0 status-y at-xy clear-to-eol ;

: message-y ( -- n ) status-y 1 + ;

: message ( string -- ) 0 message-y at-xy write-string ;

: clear-message-line ( -- ) 0 message-y at-xy clear-to-eol ;

: update-display ( -- )
    hide-cursor
    repaint? [
        0 0 at-xy
        lines-per-page [ redisplay-line ] each-integer
        f !> repaint?
    ] [
        dot-line-changed? [
            dot-y redisplay-line
            f !> dot-line-changed?
        ] when
    ] if
    status
    .cursor
    show-cursor
;

: adjust-cursor-x ( -- )
    goal-x dot-offset!
    dot-offset dot-line-length > [
        dot-line-length dot-offset!
    ] when
;

: reframe? ( -- ? )
    dot-line-number
    top-line-number
    dup lines-per-page 1 - +
    between? not ;

: reframe ( -- )
    dot-line-number
    lines-per-page 2 /i verify-index
    - 0 max !> top-line-number
    t !> repaint?
;

: maybe-reframe ( -- ) reframe? [ reframe ] when ;

tuple: undo-record mod-count action dot data ;

symbol: +move+
symbol: +line-edit+
symbol: +delete-line-separator+
symbol: +insert-line-separator+

tuple: compound-undo records ( vector ) ;

: new-compound-undo ( -- compound-undo )
    compound-undo make-instance
    4 <vector> over compound-undo-records!
;

: add-undo ( undo-record compound-undo -- )
    compound-undo-records vector-push
;

global: undo-stack

-- special
symbol: +compound-undo+

: push-undo ( undo-record -- )
    +compound-undo+ get [ add-undo ] [ undo-stack vector-push ] if* ;

: pop-undo ( -- undo-record ) undo-stack vector-pop ;

: reset-undo ( -- ) 0 undo-stack vector-set-length ;

: copy-dot ( -- position )
    dot [ position-line-number ] [ position-offset ] bi
    position make-instance
    [ position-offset! ] keep
    [ position-line-number! ] keep
;

: new-undo-record ( -- undo-record )
    undo-record make-instance
    mod-count over undo-record-mod-count!
    copy-dot over undo-record-dot!
;

: add-undo-move ( -- )
    new-undo-record
    +move+ over undo-record-action!
    push-undo
;

: undo-move ( undo-record -- )
    [ undo-record-mod-count !> mod-count ]
    [ undo-record-dot !> dot ]
    bi
;

: add-undo-line-edit ( -- )
    new-undo-record
    +line-edit+ over undo-record-action!
    dot-line over undo-record-data!
    push-undo
;

: undo-line-edit ( undo-record -- )
    [ undo-record-mod-count !> mod-count ]
    [ undo-record-dot !> dot ]
    [ undo-record-data dot-line! ]
    tri

    t !> dot-line-changed?
;

: add-undo-delete-line-separator ( -- )
    new-undo-record
    +delete-line-separator+ over undo-record-action!
    dot-line
    dot-line-number 1 + buffer-nth-line
    2array
    over undo-record-data!
    push-undo
;

: undo-delete-line-separator ( undo-record -- )
    dup
    [ undo-record-mod-count !> mod-count ]
    [ undo-record-dot !> dot ]
    bi
    undo-record-data ( 2array )
    dup array-first dot-line!
    array-second dot-line-number 1 + buffer-insert-nth-line
    t !> repaint?
;

: add-undo-insert-line-separator ( -- )
    new-undo-record
    +insert-line-separator+ over undo-record-action!
    dot-line over undo-record-data!
    push-undo
;

: undo-insert-line-separator ( undo-record -- )
    [ undo-record-mod-count !> mod-count ]
    [ undo-record-dot !> dot ]
    [ undo-record-data dot-line! ]
    tri
    dot-line-number 1 + buffer-lines vector-remove-nth!
    t t !> repaint?
;

: undo1 ( undo-record -- )
    dup undo-record-action
    {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ undo-delete-line-separator ] }
        { +insert-line-separator+ [ undo-insert-line-separator ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: undo ( -- )
    undo-stack empty? [
        "Nothing to undo" message
    ] [
        pop-undo dup compound-undo? [
            compound-undo-records vector-reverse! ' undo1 each
        ] [
            undo1
        ] if
    ] if
;

: beginning-of-buffer ( -- )
    add-undo-move

    0 dot-line-number!
    0 dot-offset!

    0 !> top-line-number
    0 !> goal-x
    t !> repaint?
;

: end-of-buffer ( -- )
    add-undo-move

    buffer-line-count 1 - 0 max dot-line-number!
    buffer-line-count lines-per-page - 0 max !> top-line-number
    dot-line-length dot-offset!
    dot-offset !> goal-x
    t !> repaint?
;

: gotoline ( -- )
    0 message-y at-xy
    "Line number: " accept-string >local: response
    clear-message-line
    response string>number [
        1 - 0 max buffer-line-count 1 - min
        dup dot-line-number <> [
            add-undo-move
            dot-line-number!
            0 dot-offset!
            maybe-reframe
        ] [
            drop
        ] if
    ] when*
;

: do-home ( -- )
    add-undo-move

    0 dot-offset!
    0 !> goal-x
;

: end-of-line ( -- )
    add-undo-move

    dot-line length dot-offset!
    dot-offset !> goal-x
;

: do-left ( -- )
    add-undo-move

    dot-offset 0 > [
        dot-offset 1 - dot-offset!
        dot-offset !> goal-x
    ] [
        dot-line-number 0 > [
            dot-line-number 1 - dot-line-number!
            dot-line-length dot-offset!
            dot-offset !> goal-x
            reframe? [
                dot-line-number !> top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-right ( -- )
    add-undo-move

    dot-offset dot-line length < [
        dot-offset 1 + dot-offset!
        dot-offset !> goal-x
    ] [
        dot-line-number buffer-line-count 1 - < [
            dot-line-number 1 + dot-line-number!
            0 dot-offset!
            dot-offset !> goal-x
            reframe? [
                dot-line-number lines-per-page 1 - - !> top-line-number
                t !> repaint?
            ] when
        ] when
    ] if
;

: do-down ( -- )
    add-undo-move

    dot-line-number buffer-line-count 1 - < [
        dot-line-number 1 + dot-line-number!
        reframe? [
            dot-line-number lines-per-page 1 - - !> top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-up ( -- )
    add-undo-move

    dot-line-number 0 > [
        dot-line-number 1 - dot-line-number!
        reframe? [
            dot-line-number !> top-line-number
            t !> repaint?
        ] when
        adjust-cursor-x
    ] when
;

: do-page-down
    add-undo-move

    dot-y >local: goal-y

    dot-line-number lines-per-page +
    buffer-line-count 1 - min
    dot-line-number!

    dot-line-number goal-y - 0 max !> top-line-number
    t !> repaint?
    adjust-cursor-x
;

: do-page-up
    add-undo-move

    dot-y >local: goal-y

    dot-line-number lines-per-page - 0 max dot-line-number!

    dot-line-number goal-y - 0 max !> top-line-number
    t !> repaint?
    adjust-cursor-x
;

: insert-line-separator ( -- )
    dot-offset dot-line-length <= [
        add-undo-insert-line-separator
        dot-line-tail dot-line-number 1 + buffer-insert-nth-line
        dot-line-head dot-line!
        dot-line-number 1 + dot-line-number!
        0 dot-offset!
        0 !> goal-x
        modified
        t !> repaint?
    ] when
;

: string-remove-nth ( n string -- string' )
    check-bounds

    >local: s
    >local: n

    s n string-head
    n 1 + s string-length < [
        s n 1 + string-tail string-append
    ] when
;

: delete-normal-char ( -- )
    add-undo-line-edit

    dot-offset dot-line string-remove-nth dot-line!
    t !> dot-line-changed?
;

: delete-line-separator ( -- )
    dot-line-number buffer-line-count 1 - < [
        dot-offset dot-line-length = [
            add-undo-delete-line-separator
            dot-line-number 1 + buffer-nth-line
            dot-line swap string-append dot-line!
            dot-line-number 1 + buffer-lines vector-remove-nth!
            t !> repaint?
        ] when
    ] when
;

: do-delete ( -- )
    dot-offset dot-line-length < [
        delete-normal-char
    ] [
        delete-line-separator
    ] if
    modified
;

: do-bs ( -- )
    {
        {
            [ dot-offset 0 > ]
            [
                add-undo-line-edit
                dot-offset 1 -
                [ dot-line string-remove-nth dot-line! ] [ dot-offset! ] bi
                t !> dot-line-changed?
                modified
            ]
        }
        {
            [ dot-line-number 0 > ]
            [
                [
                    new-compound-undo +compound-undo+ set
                    do-left
                    delete-line-separator
                    modified
                    +compound-undo+ get
                ] with-dynamic-scope
                push-undo
            ]
        }
        -- do nothing if dot is at beginning of buffer
        [ ]
    } cond
;

: do-normal-char ( char -- )
    add-undo-line-edit

    dot-line-head string>sbuf >local: sb
    sb sbuf-push
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line!
    dot-offset 1 + dot-offset!
    t !> dot-line-changed?
    modified
    dot-offset !> goal-x
;

: insert-spaces ( n -- )
    -- no undo

    >local: n
    dot-line-head string>sbuf >local: sb
    n [ 32 sb sbuf-push ] times
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line!
    dot-offset n + dot-offset!
    t !> dot-line-changed?
    modified
;

: do-tab ( -- )
    add-undo-line-edit
    4 dot-offset 4 mod - insert-spaces
;

: kill-line ( -- )
    dot-line-tail length zero? [
        delete-line-separator
    ] [
        add-undo-line-edit
        dot-line-head dot-line!
        t !> dot-line-changed?
        modified
    ] if
;

: make-backup ( -- )
    editor-filename dup file-exists?
    [ dup "~" string-append copy-file ] [ drop ] if
;

: do-save ( -- )
    "Saving..." message

    make-backup

    current-buffer buffer-filename file-create-write >local: fd
    current-buffer buffer-eol >local: eol

    -- write out all lines but the last followed by eol
    buffer-line-count 1 - [
        buffer-nth-line fd file-write-string
        eol fd file-write-string
    ] each-integer

    -- write out last line, no eol
    buffer-last-line fd file-write-string

    fd file-close

    mod-count !> mod-count-last-save

    "Saving...done" message
;

: do-quit ( -- )
    t !> done?

    modified? [
        0 message-y at-xy prompt-style "Save file? (y or n) " write-string
        key 'y' eq? [ do-save ] when
    ] when

    local: response

    modified? [
        0 message-y at-xy
        "Abandon changes? (yes or no) " accept-string !> response
        response "yes" = [ f !> done? ] unless
    ] when

    clear-message-line
;

-- find, find-again

using: feline accept-string editor ;
in: search

empty

private

global: pattern

global: found-line-number
global: found-offset

: not-found ( -- )
   0 message-y at-xy error-style "Not found" write-string output-style ;

: find-pattern-in-current-line ( start -- index/f )
    pattern dot-line pick string-tail substring-start ( index/f )
    [ + ] [ drop f ] if*
;

public

: do-find ( -- )
    0 message-y at-xy "Find: " accept-string !> pattern
    clear-message-line

    f >local: found?

    f !> found-line-number
    f !> found-offset

    dot-offset find-pattern-in-current-line !> found-offset

    found-offset [
        dot-line-number !> found-line-number
        t !> found?
    ] when

    found? [
        next-line-number buffer-lines [
            pattern swap substring-start
            dup !> found-offset
        ] find-from ( line-number/f line/f )
        [ !> found-line-number t !> found? ] [ drop ] if
    ] unless

    found? [
        add-undo-move
        found-line-number dot-line-number!
        found-offset dot-offset!
        dot-offset !> goal-x
        maybe-reframe
    ] [
        not-found
    ] if
;

: do-find-again ( -- )
    f >local: found?

    f !> found-line-number
    f !> found-offset

    dot-offset dot-line-length 1 - < [
        dot-offset 1 + find-pattern-in-current-line !> found-offset
    ] when

    found-offset [
        dot-line-number !> found-line-number
        t !> found?
    ] when

    found? [
        next-line-number buffer-lines [
            pattern swap substring-start
            dup !> found-offset
        ] find-from ( line-number/f line/f )
        [ !> found-line-number t !> found? ] [ drop ] if
    ] unless

    found? [
        add-undo-move
        found-line-number dot-line-number!
        found-offset dot-offset!
        dot-offset !> goal-x
        maybe-reframe
    ] [
        not-found
    ] if
;

--

using: feline search ;
in: editor

: bind-key ( key symbol -- ) swap bindings set-at ;

: lookup-key ( key -- symbol/f ) bindings at ;

: initialize-bindings ( -- )
    32 <hashtable> !> bindings
    127                 ' do-bs                         bind-key        -- Linux
    8                   ' do-bs                         bind-key        -- Windows
    k-delete            ' do-delete                     bind-key
    k-home              ' do-home                       bind-key
    k-end               ' end-of-line                   bind-key
    k-left              ' do-left                       bind-key
    k-right             ' do-right                      bind-key
    k-up                ' do-up                         bind-key
    k-down              ' do-down                       bind-key
    k-prior             ' do-page-up                    bind-key
    k-next              ' do-page-down                  bind-key
    k-ctrl-home         ' beginning-of-buffer           bind-key
    k-ctrl-end          ' end-of-buffer                 bind-key
    7 ( control g )     ' gotoline                      bind-key
    0x11 ( control q )  ' do-quit                       bind-key
    0x13 ( control s )  ' do-save                       bind-key
    k-enter             ' insert-line-separator         bind-key
    0x06 ( control f )  ' do-find                       bind-key
    0x803d ( F3 )       ' do-find-again                 bind-key        -- Windows
    0x1b4f52 ( F3 )     ' do-find-again                 bind-key        -- Linux
    0x09 ( tab )        ' do-tab                        bind-key
    0x0b ( control k )  ' kill-line                     bind-key
    0x1a ( control z )  ' undo                          bind-key
    0x15 ( control u )  ' undo                          bind-key
    0x1b ( escape )     ' quit                          bind-key
;

: do-command ( -- ) lookup-key [ call-symbol ] when* ;

: dispatch ( key -- )
    dup 32 126 between? [ do-normal-char ] [ do-command ] if ;

: edit-loop ( -- )
    f !> done?
    [ done? ] [
        update-display
        ekey
        clear-message-line
        dispatch
    ] until
;

: initialize-editor ( -- )
    bindings [ initialize-bindings ] unless
    100 <vector> !> undo-stack
;

: initialize-empty-buffer ( -- )
    "untitled" create-buffer !> current-buffer
    LF current-buffer buffer-eol!
    64 <vector> !> buffer-lines
    "" buffer-lines vector-push
    position make-instance !> dot
    0 dot-offset!
    0 dot-line-number!
    0 !> top-line-number

    0 !> mod-count 0 !> mod-count-last-save
    0 !> goal-x
;

: initialize-buffer ( filename line-number -- )
    verify-index  >local: line-number
    verify-string >local: filename

    filename create-buffer !> current-buffer

    current-buffer buffer-filename file-contents

    -- detect eol
    13 over string-index CR+LF LF ? current-buffer buffer-eol!

    dup string-lines verify-vector !> buffer-lines

    string-last-char 10 eq? [ "" buffer-lines vector-push ] when

    position make-instance !> dot

    0 dot-offset!
    line-number 1 - 0 max buffer-line-count 1 - min dot-line-number!

    0 !> top-line-number

    0 !> mod-count 0 !> mod-count-last-save
    0 !> goal-x
;

: edit1 ( -- )
    use-alternate-screen-buffer

    page
    normal
    maybe-reframe
    t !> repaint?

    edit-loop

    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor

    use-default-screen-buffer
;

: edit-file ( path -- )
    canonical-path
    initialize-editor
    0 initialize-buffer
    edit1
;

: edit-definition ( symbol -- )
    initialize-editor
    symbol-location 2dup and
    [ initialize-buffer edit1 ] [ 2drop ] if
;

: edit-new ( -- )
    initialize-editor
    initialize-empty-buffer
    edit1
;

: edit ( -- )
    parse-token dup [
        find-name [ edit-definition ] [ edit-file ] if
    ] [
        drop edit-new
    ] if
;

: ed ( -- )
    page
    normal
    t !> repaint?
    edit-loop
    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor
;
