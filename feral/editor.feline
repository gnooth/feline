-- Copyright (C) 2017-2018 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: user

{
    "accept-string"
    "search"
    "modes"
    "ansi-color"
    "feline-mode"
} [ delete-vocab ] each

in: editor

empty

feline-home "feral" path-append add-source-directory

using: feline modes accept-string ;

tuple: line
    prev
    next
    %number
    text ;

: make-line/1                           -- string -> line
    line make-instance
    tuck
    line-text! ;

: make-line/2                           -- string index -> line
    line make-instance
    tuck
    line-%number!
    tuck
    line-text! ;

tuple: position
    %line
    offset ;

: make-position                         -- line offset -> position
    position make-instance :> pos
    pos position-offset!
    pos position-%line!
    pos
;

tuple: buffer
    mode
    dot
    mark
    goal-column
    filename
    autosave-filename
    mod-count
    mod-count-last-save
    eol
    undo-stack
    redo-stack
    %first-line
    %last-line
    %top-line
;

"\n"   constant LF
"\r\n" constant CR+LF

: make-buffer                           -- -> buffer
    buffer make-instance :> buf

    0 buf buffer-goal-column!
    0 buf buffer-mod-count!
    0 buf buffer-mod-count-last-save!
    LF buf buffer-eol!

    100 <vector> buf buffer-undo-stack!
    16 <vector> buf buffer-redo-stack!

    buf
;

var repaint?
var dot-line-changed?
var bindings

var current-command
var last-command

var in-redo?

var done?

var buffer-list

var current-buffer

: buffer-modified?                      -- buffer -> ?
    dup buffer-mod-count swap buffer-mod-count-last-save neq? ;

: dot                                   -- -> position
    current-buffer buffer-dot ;

: dot!                                  -- position -> void
    current-buffer buffer-dot! ;

: dot-line                              -- -> line
    dot position-%line ;

: dot-line-number                       -- -> line-number
    dot position-%line line-%number ;

: dot-line!                            -- line -> void
    dot position-%line! ;

: dot-offset                            -- -> n
    dot position-offset ;

: dot-offset!                           -- n -> void
    dot position-offset! ;

: mark                                  -- -> position/f
    current-buffer buffer-mark ;

: mark!                                 -- position -> void
    current-buffer buffer-mark! ;

: mark-line                             -- -> line/f
    mark [ mark position-%line ] [ f ] if ;

: mark-line-number                      -- -> line-number/f
    mark [ mark position-%line line-%number ] [ f ] if ;

: mark-offset                           -- -> n
    mark position-offset ;

: unmark
    mark [ f mark! t repaint?! ] when ;

: top-line                              -- -> line
    current-buffer buffer-%top-line ;

: top-line!                             -- line ->
    current-buffer buffer-%top-line! ;

: top-line-number                       -- -> n
    current-buffer buffer-%top-line line-%number ;

: dot-line-text                         -- -> string
    dot-line line-text ;

: dot-line-text!                        -- string ->
    dot-line line-text! ;

: dot-line-length                       -- -> n
    dot-line-text string-length ;

: dot-line-head                         -- -> string
    dot-line line-text dot-offset string-head ;

: dot-line-tail                         -- -> string
    dot-line line-text dot-offset string-tail ;

: dot-line-next                         -- -> line'
    dot position-%line line-next ;

: dot-line-prev                         -- -> line'
    dot position-%line line-prev ;

: first-line                            -- -> line
    current-buffer buffer-%first-line ;

: last-line                             -- -> line
    current-buffer buffer-%last-line ;

: last-line-number                      -- --> n
    last-line line-%number ;

: line-count                            -- -> n
    last-line-number 1+ ;

: goal-column                           -- -> n
    current-buffer buffer-goal-column ;

: goal-column!                          -- n ->
    current-buffer buffer-goal-column! ;

: mod-count                             -- -> n
    current-buffer buffer-mod-count ;

: mod-count!                            -- n ->
    current-buffer buffer-mod-count! ;

: mod-count-last-save                   -- -> n
    current-buffer buffer-mod-count-last-save ;

: mod-count-last-save!               -- n ->
    current-buffer buffer-mod-count-last-save! ;

: modified?                             -- -> ?
    mod-count mod-count-last-save neq? ;

: modified mod-count 1+ mod-count! ;

: undo-stack                            -- -> vector
    current-buffer buffer-undo-stack ;

: redo-stack                            -- -> vector
    current-buffer buffer-redo-stack ;

: renumber
    first-line :> line!
    0 :> n!
    [ line ] [
        n line line-%number!
        n 1+ n!
        line line-next line!
    ] while
;

: nth-line ( line-number )       -- line-number -> line
    first-line :> line!
    0 :> n!
    [ n line-number < ] [
        n 1+ n!
        line line-next line!
    ] while
    line line-%number line-number assert-eq
    line
;

: insert-after ( line prev )            -- line prev -> void
    -- insert line after prev
    prev line-next :> next

    line prev line-next!
    prev line line-prev!

    next line line-next!
    next [ line next line-prev! ] when

    renumber
;

: unlink ( line )                       -- line -> void
    line line-next :> next
    line line-prev :> prev

    prev [ next prev line-next! ] when
    next [ prev next line-prev! ] when

    f line line-next!
    f line line-prev!

    renumber
;

: lines-per-page                        -- -> n
    terminal-height 2 - ;

: bottom-line                           -- -> line
    top-line :> line!
    0 :> i!

    [ i lines-per-page 1- < ] [
        line line-next [ line! ] when*
        i 1+ i!
    ] while

    line
;

: bottom-line-number                    -- -> n
    bottom-line line-%number ;

: tab-width                             -- -> n
    8 ;

: position-column ( pos )               -- position -> column
    pos position-%line :> line
    pos position-offset line line-text length min :> limit
    0 :> column!
    limit [
        line line-text string-nth '\t' eq? [
            column tab-width column tab-width mod - + column!
        ] [
            column 1+ column!
        ] if
    ] each-integer
    column ;

: dot-column                            -- -> column
    dot position-column ;

: mark-column                           -- -> column
    mark [ mark position-column ] [ f ] if ;

: .cursor
    dot-column
    dot-line-number top-line-number -
    dup 0 >= assert-true
    at-xy ;

: dot-y                                 -- -> n
    dot-line-number top-line-number -
    dup 0 >= assert-true ;

: detab ( s )                           -- string1 -> string2
    '\t' s string-index :> i
    i f eq? [ s ] return-if

    256 <sbuf> :> sb

    s [
        dup '\t' eq? [
            drop
            '\s' sb sbuf-push
            [ sb sbuf-length 8 mod 0 eq? ] [ '\s' sb sbuf-push ] until
        ] [
            sb sbuf-push
        ] if
    ] each

    sb sbuf>string
;

: format-line ( s )
    current-buffer buffer-mode :> mode
    mode [
        s mode mode-formatter call-symbol
    ] [
        s
    ] if
;

: status-y                              -- -> n
    terminal-height 2 - ;

: reverse esc[ "7m" write-string-escaped ;

: normal esc[ "m" write-string-escaped ;

: status
    reverse
    0 status-y at-xy
    modified? [ '*' write-char ] [ space ] if
    current-buffer buffer-filename write-string

    dot-line-number 1+
    line-count
    dot-column 1+
    "Line %d of %d Col %d " format
    terminal-width over length - :> x
    x current-buffer buffer-filename length 1+ - 1 max spaces
    write-string
    normal
;

: clear-status-line 0 status-y at-xy clear-to-eol ;

: message-y                             -- -> n
    status-y 1+ ;

: message                               -- string ->
    0 message-y at-xy write-string ;

: clear-message-line hide-cursor 0 message-y at-xy clear-to-eol ;

: repaint-line ( line )                -- line -> void
    line line-text detab :> detabbed-text
    detabbed-text format-line :> formatted-text
    output-style
    line mark-line eq? [
        0 dot-column detabbed-text string-substring write
        reverse
        dot-column mark-column detabbed-text string-substring write
        normal
        detabbed-text mark-column string-tail write
        terminal-width detabbed-text string-length - spaces
    ] [
        detabbed-text length terminal-width < [
            formatted-text write
            terminal-width detabbed-text string-length - spaces
        ] [
            0 terminal-width detabbed-text substring write
        ] if
    ] if
;

: repaint
    top-line :> line!
    0 :> y!

    [ line y lines-per-page < and ] [
        0 y at-xy
        line repaint-line
        y 1+ y! line line-next line!
    ] while

    [ y lines-per-page < ] [
        0 y at-xy terminal-width spaces
        y 1+ y!
    ] while

    f repaint?!
;

: update-display
    hide-cursor
    repaint? [
        repaint
    ] [
        dot-line-changed? [
            0 dot-y at-xy
            dot-line repaint-line
            f dot-line-changed?!
        ] when
    ] if
    status
    .cursor
    mark [ show-cursor ] unless
;

: adjust-cursor-x
    goal-column dot-offset!
    dot-offset dot-line-length > [
        dot-line-length dot-offset!
    ] when
;

: reframe?                              -- -> ?
    dot-line-number
    top-line-number
    dup lines-per-page 1- +
    between? not ;

: reframe
    lines-per-page 2 /i verify-index :> i!
    dot-line :> line!

    [ i 0 > line line-prev and ] [
        line line-prev line!
        i 1- i!
    ] while

    line top-line!

    t repaint?!
;

: maybe-reframe reframe? [ reframe ] when ;

tuple: undo-record
    mod-count
    action
    dot
    %dot-line-number
    %dot-offset
    mark
    %mark-line-number
    %mark-offset
    data ;

symbol: +move+
symbol: +line-edit+
symbol: +delete-line-separator+
symbol: +insert-line-separator+

tuple: compound-undo
    records                             -- vector
;

: new-compound-undo                     -- -> compound-undo
    compound-undo make-instance
    4 <vector> over compound-undo-records!
;

: add-undo                              -- undo-record compound-undo ->
    compound-undo-records vector-push
;

special: +compound-undo+

: push-undo                             -- undo-record ->
    +compound-undo+ get [ add-undo ] [ undo-stack vector-push ] if* ;

: with-compound-undo                    -- quotation ->
    [
        new-compound-undo +compound-undo+ set
        call
        +compound-undo+ get
    ] with-dynamic-scope
    push-undo
;

: pop-undo                              -- -> undo-record
    undo-stack vector-pop ;

: push-redo                             -- undo-record ->
    redo-stack vector-push ;

: pop-redo                              -- -> undo-record
    redo-stack vector-pop ;

: reset-undo undo-stack vector-delete-all ;

: reset-redo redo-stack vector-delete-all ;

: copy-position ( pos )                 -- position -> copy
    pos position-%line pos position-offset make-position ;

: copy-dot                              -- -> position
    dot copy-position ;

: copy-mark                             -- -> position
    mark [ copy-position ] [ f ] if* ;

: new-undo-record                       -- -> undo-record
    undo-record make-instance :> undo-rec

    mod-count undo-rec undo-record-mod-count!
    copy-dot undo-rec undo-record-dot!
    copy-mark undo-rec undo-record-mark!
    dot-line-number undo-rec undo-record-%dot-line-number!
    dot-offset undo-rec undo-record-%dot-offset!

    undo-rec
;

: add-undo-move
    new-undo-record
    +move+ over undo-record-action!
    push-undo
;

: add-redo-move
    new-undo-record
    +move+ over undo-record-action!
    push-redo
;

: undo-move ( undo-rec )                -- undo-record ->
    in-redo? [ add-undo-move ] [ add-redo-move ] if

    mark [ t repaint?! ] when

    undo-rec undo-record-mod-count mod-count!

    undo-rec undo-record-%dot-line-number nth-line
    undo-rec undo-record-%dot-offset
    make-position dot!

    undo-rec undo-record-mark mark!

    top-line line? assert

    mark [ t repaint?! ] when
;

: new-undo-line-edit                    -- -> undo-record
    new-undo-record
    +line-edit+ over undo-record-action!
    dot-line-text over undo-record-data!
;

: add-undo-line-edit new-undo-line-edit push-undo ;

: add-redo-line-edit new-undo-line-edit push-redo ;

: undo-line-edit                        -- undo-record ->
    in-redo? [ add-undo-line-edit ] [ add-redo-line-edit ] if

    [ undo-record-mod-count mod-count! ]
    [ undo-record-dot dot! ]
    [ undo-record-data dot-line-text! ]
    tri

    t dot-line-changed?!
;

: add-undo-delete-line-separator
    new-undo-record
    +delete-line-separator+ over undo-record-action!
    dot-line-text dot-line-next line-text 2array over undo-record-data!
    push-undo
;

: add-redo-delete-line-separator
    new-undo-record
    +delete-line-separator+ over undo-record-action!
    push-redo
;

: undo-delete-line-separator  ( undo-rec )      -- undo-record -> void
    undo-rec undo-record-mod-count mod-count!
    undo-rec undo-record-%dot-line-number nth-line
    undo-rec undo-record-%dot-offset
    make-position dot!
    undo-rec undo-record-data           -- -> 2array
    dup array-first dot-line-text!
    array-second make-line/1 dot-line insert-after

    t repaint?!

    add-redo-delete-line-separator
;

: add-undo-insert-line-separator
    new-undo-record
    +insert-line-separator+ over undo-record-action!
    dot-line-text over undo-record-data!
    push-undo
;

: add-redo-insert-line-separator
    new-undo-record
    +insert-line-separator+ over undo-record-action!
    push-redo
;

: undo-insert-line-separator            -- undo-record ->
    [ undo-record-mod-count mod-count! ]
    [ undo-record-dot dot! ]
    [ undo-record-data dot-line-text! ]
    tri

    dot-line line-next unlink

    t repaint?!

    add-redo-insert-line-separator
;

: undo1                                 -- undo-record ->
    dup undo-record-action
    {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ undo-delete-line-separator ] }
        { +insert-line-separator+ [ undo-insert-line-separator ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: undo
    undo-stack empty? [
        "Nothing to undo" message
    ] [
        pop-undo dup compound-undo? [
            compound-undo-records vector-reverse! ' undo1 each
        ] [
            undo1
        ] if
        "Undo!" message
    ] if
;

: beginning-of-buffer
    add-undo-move
    unmark
    first-line top-line!
    first-line 0 make-position dot!
    0 goal-column!
    t repaint?!
;

: end-of-buffer
    add-undo-move
    unmark
    last-line dot-line!
    dot-line-length dot-offset!
    dot-offset goal-column!

    -- reframe
    last-line :> line!
    lines-per-page 1- :> i!
    [ line line-prev i 0 > and ] [
        line line-prev line!
        i 1- i!
    ] while
    line top-line!

    t repaint?!
;

: gotoline-internal                     -- line-number
    1- 0 max line-count 1- min
    dup dot-line-number <> [
        add-undo-move
        unmark
        nth-line dot-line!
        0 dot-offset!
        maybe-reframe
    ] [
        drop
    ] if
;

: gotoline
    0 message-y at-xy
    "Line number: " accept-string :> response
    clear-message-line
    response string>number [ gotoline-internal ] when*
;

: do-home
    add-undo-move

    unmark

    0 dot-offset!
    0 goal-column!
;

: end-of-line
    add-undo-move

    unmark

    dot-line-length dot-offset!
    dot-offset goal-column!
;

: beginning-of-block
    mark [ mark-offset dot-offset min dot-offset! ] when
;

: end-of-block
    mark [ mark-offset dot-offset max dot-offset! ] when
;

: do-left
    last-command ' do-left eq? [ add-undo-move ] unless

    mark [
        beginning-of-block
        unmark
    ] return-if

    dot-offset 0 > [
        dot-offset 1- dot-offset!
        dot-offset goal-column!
    ] [
        dot-line-prev [
            dot-line-prev dot-line!
            dot-line-length dot-offset!
            dot-offset goal-column!
            reframe? [
                dot-line top-line!
                t repaint?!
            ] when
        ] when
    ] if
;

: do-right
    last-command ' do-right eq? [ add-undo-move ] unless

    mark [
        end-of-block
        unmark
    ] return-if

    dot-offset dot-line-length < [
        dot-offset 1+ dot-offset!
        dot-offset goal-column!
    ] [
        dot-line-next [
            dot-line-next dot-line!
            0 dot-offset!
            dot-offset goal-column!
            reframe? [
                dot-line-number lines-per-page 1- - nth-line top-line!
                t repaint?!
            ] when
        ] when
    ] if
;

: do-down
    reset-redo

    last-command ' do-down eq? [ add-undo-move ] unless

    dot-line line-next [
        dot-line line-next dot position-%line!

        unmark
        reframe? [ reframe ] when
        adjust-cursor-x
    ] when
;

: do-up
    reset-redo

    last-command ' do-up eq? [ add-undo-move ] unless

    dot-line line-prev [
        dot-line line-prev dot position-%line!

        unmark
        reframe? [
            dot-line current-buffer buffer-%top-line!
            t repaint?!
        ] when
        adjust-cursor-x
    ] when
;

: do-window-up
    top-line line-prev [
        top-line line-prev top-line!
        top-line line? assert
        dot-line-number bottom-line-number > [
            add-undo-move
            bottom-line dot-line!
            0 dot-offset!
        ] when
        t repaint?!
    ] when
;

: do-window-down
    top-line line-next [
        top-line line-next top-line!
        top-line line? assert
        dot-line-number top-line-number < [
            add-undo-move
            top-line dot-line!
            0 dot-offset!
        ] when
        t repaint?!
    ] when
;

: do-page-down
    add-undo-move

    dot-y :> goal-y

    top-line-number lines-per-page + last-line-number > [
        last-line dot-line!
        adjust-cursor-x
    ] return-if

    top-line :> line!
    0 :> i!

    [ line line-next i lines-per-page < and ] [
        i 1+ i! line line-next line!
    ] while

    line top-line!

    goal-y i!

    [ line line-next i 0 > and ] [
        i 1- i! line line-next line!
    ] while

    line dot-line!

    t repaint?!
    adjust-cursor-x
;

: do-page-up
    add-undo-move

    dot-y :> goal-y

    dot-line :> line!
    0 :> i!

    [ line line-prev i lines-per-page < and ] [
        i 1+ i! line line-prev line!
    ] while

    line dot-line!

    goal-y i!

    [ line line-prev i 0 > and ] [
        i 1- i! line line-prev line!
    ] while

    line top-line!

    t repaint?!
    adjust-cursor-x
;

: insert-line-separator
    add-undo-insert-line-separator
    dot-line-tail make-line/1 :> new-line
    dot-line-head dot-line-text!
    new-line dot-line insert-after
    new-line dot-line!
    0 dot-offset!
    0 goal-column!
    modified
    t repaint?!
    renumber
;

: insert-spaces ( n )                   -- n ->
    -- no undo
    dot-line-head string>sbuf :> sb
    n [ '\s' sb sbuf-push ] times
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line-text!
    dot-offset n + dot-offset!
    t dot-line-changed?!
    modified
;

: do-tab
    add-undo-line-edit
    4 dot-offset 4 mod - insert-spaces
;

: get-indentation-column                -- line -> column
    dup empty? [ drop 0 ] return-if

    detab
    [ char-code 32 > ] find             -- index/f element/f
    [ drop 0 ] unless
;

: delete-indentation                    -- string -> string'
    dup empty? [ ] return-if

    :> text

    text [ char-code 32 > ] find        -- index/f element/f
    [ text swap string-tail ] [ drop "" ] if
;

: newline-and-indent
    dot-line-text get-indentation-column :> indent-col

    [
        insert-line-separator
        add-undo-line-edit
        dot-line-text delete-indentation dot-line-text!
        indent-col 0 > [
            indent-col insert-spaces
        ] when
    ] with-compound-undo
;

: string-remove-nth                     -- n string1 -> string2
    check-bounds

    :> s
    :> n

    s n string-head
    n 1+ s string-length < [
        s n 1+ string-tail string-append
    ] when
;

: delete-normal-char
    add-undo-line-edit
    dot-offset dot-line-text string-remove-nth dot-line-text!
    t dot-line-changed?!
;

: delete-line-separator
    dot-line-next [
        dot-offset dot-line-length eq? [
            add-undo-delete-line-separator
            dot-line-text dot-line-next line-text string-append dot-line-text!
            dot-line-next unlink
            t repaint?!
        ] when
    ] when
;

: do-delete
    dot-offset dot-line-length < [
        delete-normal-char
    ] [
        delete-line-separator
    ] if
    modified
;

: do-bs
    {
        {
            [ dot-offset 0 > ]
            [
                add-undo-line-edit
                dot-offset 1-
                [ dot-line line-text string-remove-nth dot-line line-text! ] [ dot-offset! ] bi
                t dot-line-changed?!
                modified
            ]
        }
        {
            [ dot-line-prev ]
            [
                [
                    new-compound-undo +compound-undo+ set
                    do-left
                    delete-line-separator
                    modified
                    +compound-undo+ get
                ] with-dynamic-scope
                push-undo
            ]
        }
        -- do nothing if dot is at beginning of buffer
        [ ]
    } cond
;

: do-normal-char                        -- char ->
    reset-redo

    current-command assert-false
    ' do-normal-char current-command!
    last-command ' do-normal-char eq? [ add-undo-line-edit ] unless

    dot-line-head string>sbuf :> sb
    sb sbuf-push
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line line-text!
    dot-offset 1+ dot-offset!
    t dot-line-changed?!
    modified
    dot-offset goal-column!
;

: kill-line
    dot-line-tail length zero? [
        delete-line-separator
    ] [
        add-undo-line-edit
        dot-line-head dot-line-text!
        t dot-line-changed?!
    ] if
    modified
;

: redo1                                 -- undo-record ->
    dup undo-record-action
    {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ drop delete-line-separator ] }
        { +insert-line-separator+ [ drop insert-line-separator ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: redo
    redo-stack empty? [
        "Nothing to redo" message
    ] [
        t in-redo?!
        pop-redo
        redo1
        f in-redo?!
        "Redo!" message
    ] if
;

: make-backup
    current-buffer buffer-filename dup file-exists?
    [ dup "~" string-append copy-file ] [ drop ] if
;

: do-save
    -- save the current buffer to disk
    output-style
    "Saving..." message

    make-backup

    current-buffer buffer-eol :> eol
    line-count 80 * <sbuf> :> sb
    nano-count :> start-ns

    -- all lines but the last are followed by eol
    first-line :> line!
    [ line last-line neq? ] [
        line line-text sb sbuf-append-string
        eol sb sbuf-append-string
        line line-next line!
    ] while

    -- last line, no eol
    last-line line-text sb sbuf-append-string

    sb sbuf>string current-buffer buffer-filename set-file-contents

    nano-count start-ns - :> elapsed-ns

    mod-count mod-count-last-save!

    elapsed-ns 1000000 /i "Saving...done (%s ms)" format message
;

: do-quit
    buffer-list [ buffer-modified? ] count :> n

    n zero? [
        t done?!
    ] [
        n dup 1 > "s" "" ?
        "Really exit with %s modified buffer%s? (yes or no) " format
        accept-string "yes" string= done?!
        clear-message-line
    ] if
;

: confirm-kill-current-buffer           -- -> ?
    f :> confirmed?!

    modified? [
        0 message-y at-xy prompt-style "Save file? (y or n) " write-string
        input-style key 'y' eq? [ do-save ] when
        clear-message-line
    ] when

    modified? [
        0 message-y at-xy
        "Abandon changes? (yes or no) " accept-string
        "yes" = [ t confirmed?! ] when
        clear-message-line
    ] when

    confirmed?
;

: kill-current-buffer
    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    :> n!                                       --

    n buffer-list vector-remove-nth!

    n buffer-list length < [ n 1- n! ] unless

    n buffer-list vector-nth current-buffer!
    t repaint?!
;

: kill-buffer
    f :> confirmed?!

    modified? [ confirm-kill-current-buffer confirmed?! ] when

    modified? not confirmed? or [
        buffer-list length 1 = [
            0 buffer-list vector-set-length
            t done?!
        ] [
            kill-current-buffer
        ] if
    ] when
;

: buffer-append-line ( line buf )       -- line buffer -> void
    buf buffer-%last-line line line-prev!
    buf buffer-%last-line [ line swap line-next! ] when*
    line buf buffer-%last-line!
    buf buffer-%first-line [
        line buf buffer-%first-line!
    ] unless
;

: initialize-empty-buffer
    make-buffer :> buf
    "untitled" buf buffer-filename!
    "" 0 make-line/2
    [ buf buffer-append-line ]
    [ 0 make-position buf buffer-dot! ]
    bi
    buf current-buffer!
    dot-line top-line!
;

: initialize-buffer                     -- filename line-number -> buf
    verify-index  :> line-number
    verify-string :> filename

    make-buffer :> buf

    filename buf buffer-filename!

    filename path-extension [ modes at buf buffer-mode! ] when*

    filename file-contents :> contents

    contents string-lines verify-vector :> lines

    contents empty? [
        "" lines vector-push
    ] [
        -- detect eol
        '\r' contents string-index CR+LF LF ? buf buffer-eol!
        contents string-last-char '\n' eq? [
            "" lines vector-push
        ] when
    ] if

    lines [
        make-line/2 buf buffer-append-line
    ] each-index

    buf buffer-%first-line line? assert

    buf buffer-%first-line 0 make-position buf buffer-dot!

    buf buffer-%first-line buf buffer-%top-line!

    buf buffer-list vector-push

    buf
;

: find-file-to-edit ( arg )             -- arg -> path/f
    arg find-file [
        arg ensure-feline-extension find-file
    ] unless*
;

: find-buffer ( filename )              -- filename -> buffer/f
    buffer-list [ buffer-filename filename = ] find     -- index/f element/f
    nip
;

: open-file
    0 message-y at-xy "File: " accept-string :> arg
    clear-message-line

    arg find-file-to-edit :> filename

    filename [
        filename find-buffer [
            current-buffer!
            t repaint?!
        ] [
            filename 1 initialize-buffer current-buffer!
            t repaint?!
        ] if*
    ] when
;

: next-buffer
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1+ dup buffer-list length < [ drop 0 ] unless

    buffer-list vector-nth current-buffer!
    t repaint?!
;

: previous-buffer
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1 - dup 0 >= [ drop buffer-list length 1 - ] unless

    buffer-list vector-nth current-buffer!
    t repaint?!
;

: identifier-at-dot                     -- -> string/f
    dot-offset dot-line-length 1- min 0 max :> offset!

    offset dot-line-text [ '\s' eq? ] find-last-from drop :> start!

    -- get to first non-blank char
    start [ start 1+ start! ] [ 0 start! ] if

    start dot-line-text string-skip-to-whitespace       -- -> index/f
    dot-line-length or [
        start swap dot-line-text string-substring
    ] [
        f
    ] if* ;

: goto-definition                       -- symbol -> void
    symbol-location :> line-number :> filename
    filename [
        filename find-buffer [
            current-buffer!
            line-number gotoline-internal
        ] [
            filename line-number initialize-buffer current-buffer!
            line-number gotoline-internal
        ] if*
        maybe-reframe
        t repaint?!
    ] when
;

: find-definition
    identifier-at-dot
    find-qualified-name [
        goto-definition
    ] [
        all-words [ symbol-name over = ] filter nip
        dup length {
            { 0 [ drop ] }
            { 1 [ first goto-definition ] }
            [
                -- more than 1 match
                drop
                0 message-y at-xy
                [ symbol-qualified-name write-string space ] each
            ]
        } case
    ] if ;

use: search

: bind-key                              -- key symbol ->
    swap bindings set-at ;

: lookup-key                            -- key -> symbol/f
    bindings at ;

: initialize-bindings
    128 <hashtable> bindings!

    key:del             ' do-bs                         bind-key        -- Linux
    key:backspace       ' do-bs                         bind-key        -- Windows
    key:delete          ' do-delete                     bind-key
    key:home            ' do-home                       bind-key
    key:end             ' end-of-line                   bind-key
    key:left            ' do-left                       bind-key
    key:right           ' do-right                      bind-key
    key:up              ' do-up                         bind-key
    key:down            ' do-down                       bind-key
    key:ctrl-up         ' do-window-up                  bind-key
    key:ctrl-down       ' do-window-down                bind-key
    key:pageup          ' do-page-up                    bind-key
    key:pagedown        ' do-page-down                  bind-key
    key:ctrl-home       ' beginning-of-buffer           bind-key
    key:ctrl-end        ' end-of-buffer                 bind-key
    key:ctrl-g          ' gotoline                      bind-key
    key:ctrl-q          ' do-quit                       bind-key
    key:ctrl-s          ' do-save                       bind-key
    key:ctrl-w          ' kill-buffer                   bind-key
    key:enter           ' newline-and-indent            bind-key
    key:ctrl-f          ' do-find                       bind-key
    key:f3              ' do-find-again                 bind-key
    key:tab             ' do-tab                        bind-key
    key:ctrl-k          ' kill-line                     bind-key
    key:ctrl-z          ' undo                          bind-key
    key:ctrl-u          ' undo                          bind-key
    key:ctrl-y          ' redo                          bind-key
    key:escape          ' quit                          bind-key
    key:ctrl-o          ' open-file                     bind-key
    key:alt-right       ' next-buffer                   bind-key
    key:alt-left        ' previous-buffer               bind-key
    key:ctrl-t          ' find-definition               bind-key
;

-- var feral-log-fd

-- "feral-log" file-create-write feral-log-fd!

-- : log                                   -- string -> void
--     feral-log-fd file-write-line
--     feral-log-fd file-flush ;

-- "startup" log
: log drop ;

: do-mouse                              -- key -> void
--     verify-fixnum :> keycode
--     f :> button! f :> x! f :> y!
--     keycode fixnum>hex log
--     keycode 24 rshift 0x1b5b4d = [
--         -- "\e[M"
--         keycode 0xff bitand 32 - y!
--         keycode 0xff00 bitand 8 rshift 32 - x!
--         keycode 0xff0000 bitand 16 rshift 3 bitand zero? [
--             -- left button pressed
--             x y "left button pressed x = %d y = %d" format log
--             top-line-number y + gotoline-internal
--             x 1- 0 max dot-offset!
--         ] when
--     ] when
;

: do-command                            -- key ->
    dup lookup-key [
        nip dup current-command! call-symbol
    ] [
--         do-mouse
        drop
    ] if* ;

: dispatch                              -- key ->
    current-command last-command!
    f current-command!
    dup printable-char? [ do-normal-char ] [ do-command ] if ;

: edit-loop
    f done?!
    [ done? ] [
        top-line line? assert
        update-display
        ekey
        clear-message-line
        dispatch
    ] until
;

: initialize-editor
    16 <vector> buffer-list!
    bindings [ initialize-bindings ] unless
;

: edit1
    use-alternate-screen-buffer

    page
    normal
    maybe-reframe
    t repaint?!

    linux? [
        -- enable mouse tracking
        "\e[?1000h" write-string-escaped
    ] when

    edit-loop

    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor

    use-default-screen-buffer
;

: edit-file ( arg )                     -- arg ->
    arg find-file-to-edit [
        initialize-editor
        0 initialize-buffer current-buffer!
        first-line top-line!
        edit1
    ] [
        arg error-file-not-found
    ] if*
;

: edit-definition                       -- symbol ->
    initialize-editor
    symbol-location 2dup and
    [ initialize-buffer current-buffer! edit1 ] [ 2drop ] if
;

: edit-new
    initialize-editor
    initialize-empty-buffer
    edit1
;

: edit
    parse-token dup [
        find-name [ edit-definition ] [ edit-file ] if
    ] [
        drop edit-new
    ] if
;

: ed
    page
    normal
    t repaint?!
    edit-loop
    clear-status-line
    clear-message-line
    0 lines-per-page at-xy
    show-cursor
;
