// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: user

{
    "feral-config"
    "feral-core"
    "directories"
    "search"
    "modes"
    "feline-mode"
    "asm-mode"
    "list-buffers"
    "kill-ring"
    "ansi-color"
    "accept-string"
} [ delete-vocab ] each

in: feral-config

empty

f constant winui?

in: editor

empty

feline-home "feral" path-append add-source-directory

use: directories

initialize-directories

using: feral-core feline accessors modes accept-string directories feral-config ;

: status-y                              // -> n
    terminal-rows 2 - ;

: message-y                             // -> n
    status-y 1+ ;

: message                               // string ->
    0 message-y at-xy write-string ;

: clear-message hide-cursor 0 message-y at-xy clear-to-eol ;

"display.feline" load

"undo.feline" load

"move.feline" load

: minibuffer-accept-string              // prompt-string -> string
    0 message-y at-xy
    accept-string
    clear-message
;

: gotoline
    "Line number: " minibuffer-accept-string
    string>number [ gotoline-internal ] when*
;

"edit.feline" load

"save.feline" load

"asm-mode.feline" load
"feline-mode.feline" load

: exit-feral t done?! ;

: do-quit
    buffer-list [ buffer-modified? ] count :> n

    n zero? [
        exit-feral
    ] [
        n dup 1 > "s" "" ?
        "Really exit with %s modified buffer%s? (yes or no) " format
        minibuffer-accept-string
        "yes" = [ exit-feral ] when
    ] if
;

"buffer.feline" load

"list-buffers.feline" load

"git.feline" load

: find-file-to-edit ( arg )             // arg -> path/f
    arg find-file [
        arg ensure-feline-extension find-file
    ] unless*
;

: open-file
    "File: " minibuffer-accept-string :> arg

    arg find-file-to-edit :> filename

    filename [
        filename find-buffer [
            current-buffer!
            t repaint?!
        ] [
            filename 1 create-buffer/2
            t repaint?!
        ] if*
    ] when
;

"find-definition.feline" load

: execute-command
    "Command: " minibuffer-accept-string :> command
    command find-name [
        call-symbol
    ] [
        "%S is not a valid command name." format message
    ] if
;

use: search

"keymaps.feline" load

: do-mouse                              // key -> void
    dup fixnum? not [ drop ] return-if

    :> keycode
    f :> button! f :> x! f :> y!
//     keycode fixnum>hex log
    keycode 24 rshift 0x1b5b4d = [
        // "\e[M"
        keycode 0xff bitand 32 - y!
        keycode 0xff00 bitand 8 rshift 32 - x!
        keycode 0xff0000 bitand 16 rshift 3 bitand zero? [
            // left button pressed
//             x y "left button pressed x = %d y = %d" format log
            top-line-number y + gotoline-internal
            x 1- 0 max dot-line-length min dot-offset!
        ] when
    ] when
;

: do-command ( key )                    // key -> void

    f :> command!

    // try local map first
    current-buffer local-map>> :> local-map
    local-map [
        key local-map at command!
    ] when

    // global map
    command [
        key lookup-key command!
    ] unless

    command [
        command dup current-command! call-symbol
    ] [
        linux? [ key do-mouse ] when
    ] if
;

: dispatch                              // key -> void
    current-command last-command!
    f current-command!
    dup printable-char? [ do-normal-char ] [ do-command ] if ;

: edit-loop
    f done?!
    [ done? ] [
        update-display
        ekey
        clear-message
        dispatch
    ] until

    // clean up
    f current-buffer!
    f buffer-list!
    gc
;

: initialize-editor
    16 <vector> buffer-list!
    initialize-global-keymaps
;

: edit1
    use-alternate-screen-buffer

    page
    normal
    maybe-reframe
    t repaint?!

    linux? [
        // enable mouse tracking
        "\e[?1000h" write-string-escaped
    ] when

    edit-loop

    clear-status-line
    clear-message
    0 textview-rows at-xy
    show-cursor

    use-default-screen-buffer
;

: edit-file ( name )                    // name -> void
    name find-file-to-edit [
        initialize-editor
        1 create-buffer/2
        edit1
    ] [
        name error-file-not-found
    ] if*
;

: edit-definition                       // symbol ->
    symbol-location 2dup and
    [
        initialize-editor
        create-buffer/2
        edit1
    ] [
        2drop
    ] if
;

: edit-new
    initialize-editor
    create-buffer
    edit1
;

: edit
    parse-token dup [
        find-name [ edit-definition ] [ edit-file ] if
    ] [
        drop edit-new
    ] if
;

: ed
    use-alternate-screen-buffer
    page
    normal
    t repaint?!
    edit-loop
    clear-status-line
    clear-message
    0 textview-rows at-xy
    show-cursor
    use-default-screen-buffer
;
