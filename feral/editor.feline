-- Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: user

{
    "directories"
    "accept-string"
    "search"
    "modes"
    "ansi-color"
    "feline-mode"
    "kill-ring"
} [ delete-vocab ] each

in: editor

empty

f constant winui?

feline-home "feral" path-append add-source-directory

use: directories

initialize-directories

using: feline accessors modes accept-string logging directories ;

"defs.feline" load

: renumber
    first-line :> line!
    0 :> n!
    [ line ] [
        n line number<<
        n 1+ n!
        line next>> line!
    ] while
;

: nth-line ( line-number )              -- line-number -> line

    line-number 0 < [ f ] return-if

    first-line :> line!
    0 :> n!
    [ n line-number < ] [
        n 1+ n!
        line next>> line!
    ] while
    line
;

: insert-after ( line prev )            -- line prev -> void
    -- insert line after prev

    prev [ prev next>> ] [ first-line ] if :> next

    prev [
        line prev next<<
    ] [
        line dup first-line! top-line!
    ] if
    prev line prev<<

    next line next<<
    next [ line next prev<< ] [ line last-line! ] if
;

: insert-before ( line next )           -- line next -> void
    -- insert line before next

    next [ next prev>> ] [ f ] if :> prev

    prev [ line prev insert-after ] return-if

    -- prev is null
    line first-line prev<<
    first-line line next<<
    line first-line!
;

: unlink ( line )                       -- line -> void
    line next>> :> next
    line prev>> :> prev

    prev [ next prev next<< ] when
    next [ prev next prev<< ] when

    f line next<<
    f line prev<<

    renumber
;

: text-rows                             -- -> n
    terminal-height 2 - ;

: bottom-line                           -- -> line
    top-line :> line!
    0 :> i!

    [ i text-rows 1- < ] [
        line next>> [ line! ] when*
        i 1+ i!
    ] while

    line
;

: bottom-line-number                    -- -> n
    bottom-line number>> ;

: tab-width                             -- -> n
    8 ;

: position-column ( pos )               -- position -> column
    pos line>> :> line
    pos offset>> line text>> length min :> limit
    0 :> column!
    limit [
        line text>> string-nth '\t' eq? [
            column tab-width column tab-width mod - + column!
        ] [
            column 1+ column!
        ] if
    ] each-integer
    column ;

: dot-column                            -- -> column
    dot position-column ;

: mark-column                           -- -> column
    mark [ mark position-column ] [ f ] if ;

: .cursor
    dot-column
    dot-line-number top-line-number -
    at-xy ;

: dot-y                                 -- -> n
    dot-line-number top-line-number - ;

: detab ( s )                           -- string1 -> string2
    '\t' s string-index :> i
    i f eq? [ s ] return-if

    256 <sbuf> :> sb

    s [
        dup '\t' eq? [
            drop
            '\s' sb sbuf-push
            [ sb sbuf-length 8 mod 0 eq? ] [ '\s' sb sbuf-push ] until
        ] [
            sb sbuf-push
        ] if
    ] each

    sb sbuf>string
;

: format-line ( s )
    current-buffer mode>> :> mode
    mode [
        s mode formatter>> call-symbol
    ] [
        s
    ] if
;

: status-y                              -- -> n
    terminal-height 2 - ;

: reverse esc[ "7m" write-string-escaped ;

: normal esc[ "m" write-string-escaped ;

: status
    reverse
    0 status-y at-xy
    modified? [ '*' write-char ] [ space ] if
    current-buffer filename>> :> filename!
    filename [ "untitled" filename! ] unless
    filename write-string

    dot-line-number 1+
    line-count
    dot-column 1+
    "Line %d of %d Col %d " format
    terminal-width over length - :> x
    x filename length 1+ - 1 max spaces
    write-string
    normal
;

: clear-status-line 0 status-y at-xy clear-to-eol ;

: message-y                             -- -> n
    status-y 1+ ;

: message                               -- string ->
    0 message-y at-xy write-string ;

: clear-message-line hide-cursor 0 message-y at-xy clear-to-eol ;

: line-selected? ( line )               -- line -> ?
    mark null? [ f ] return-if

    line number>> mark-line-number >= [
        line number>> dot-line-number <
    ] [
        f
    ] if
;

use: ansi-color

 64  64  64 rgb-background-prefix constant selection-prefix

: repaint-line ( line )                 -- line -> void
    line text>> detab :> detabbed-text

    detabbed-text format-line :> formatted-text

    line line-selected? [
        selection-prefix write-string-escaped
        formatted-text write
        selection-prefix write-string-escaped
        terminal-width detabbed-text string-length - spaces
        "\e[0m" write-string-escaped
    ] return-if

    output-style
    line mark-line eq? [
        0 dot-column detabbed-text string-substring write
        reverse
        dot-column mark-column detabbed-text string-substring write
        normal
        detabbed-text mark-column string-tail write
        terminal-width detabbed-text string-length - spaces
    ] [
        detabbed-text length terminal-width < [
            formatted-text write
            terminal-width detabbed-text string-length - spaces
        ] [
            0 terminal-width detabbed-text substring write
        ] if
    ] if
;

: repaint
    top-line :> line!
    0 :> y!

    [ line y text-rows < and ] [
        0 y at-xy
        line repaint-line
        y 1+ y! line next>> line!
    ] while

    [ y text-rows < ] [
        0 y at-xy terminal-width spaces
        y 1+ y!
    ] while

    f repaint?!
;

: update-display
    hide-cursor
    repaint? [
        repaint
    ] [
        dot-line-changed? [
            0 dot-y at-xy
            dot-line repaint-line
            f dot-line-changed?!
        ] when
    ] if
    status
    .cursor
    mark [ show-cursor ] unless
;

: adjust-cursor-x
    goal-column dot-offset!
    dot-offset dot-line-length > [
        dot-line-length dot-offset!
    ] when
;

: reframe?                              -- -> ?
    dot-line-number
    top-line-number
    dup text-rows 1- +
    between? not ;

: reframe
    text-rows 2 /i verify-index :> i!
    dot-line :> line!

    [ i 0 > line prev>> and ] [
        line prev>> line!
        i 1- i!
    ] while

    line top-line!

    t repaint?!
;

: maybe-reframe reframe? [ reframe ] when ;

"undo.feline" load

"move.feline" load

: minibuffer-accept-string              -- prompt-string -> string
    0 message-y at-xy
    accept-string
    clear-message-line
;

: gotoline
    "Line number: " minibuffer-accept-string
    string>number [ gotoline-internal ] when*
;

"edit.feline" load

use: kill-ring

: kill-line
    dot-line-tail length zero? [
        delete-line-separator
        current-buffer eol>> verify-string append-kill
    ] [
        add-undo-line-edit
        dot-line-tail append-kill
        dot-line-head dot-line-text!
        t dot-line-changed?!
    ] if
    modified
;

: select-line
    dot-line-prev dup line-selected? and [
        -- extend selection if possible
        dot-line-next [
            dot-line-next dot-line! 0 dot-offset!
        ] when
    ] [
        dot-line-next [
            add-undo-move
            dot-line 0 make-position mark!
            dot-line-next dot-line! 0 dot-offset!
        ] when
    ] if

    t repaint?!
;

: do-anchor
    unmark
    copy-dot anchor! ;

: insert-multiline-string               -- string --> void
    -- insert string before line containing dot
    add-undo-insert-multiline-string

    dot-line-prev :> prev!

    string-lines [
        make-line/1 dup prev insert-after prev!
    ] each

    renumber
;

: cut-region ( region )
    region begin-line region end-line eq? [

        region begin-line dot-line assert-eq

        region region-as-string append-kill

        add-undo-line-edit
        dot-line-text region begin-offset string-head
        dot-line-text region end-offset string-tail
        string-append dot-line-text!

        unmark
        region begin-offset dot-offset!
        t dot-line-changed?!
        modified
    ] return-if

;

: copy-line
    dot-line-text "\n" string-append append-kill
    "Line copied to kill ring" message
;

: copy-region                           -- region -> void
    region-as-string append-kill
    "Region copied to kill ring" message
;

: copy
    { [ anchor ] [ mark ] } ||
    [ dot make-region/2 copy-region ] [ copy-line ] if*
;

: delete-line
    reset-redo

    add-undo-delete-line

    dot-line-prev :> prev
    dot-line-next :> next

    {
        { [ prev next and ] [
            dot-line
            next dot-line! 0 dot-offset!
            unlink
        ] }
        { [ prev null? ] [
            -- deleting first line
            dot-line
            next dot-line! 0 dot-offset!
            unlink
            next dup first-line! top-line!
        ] }
        { [ next null? ] [
            -- deleting last line
            dot-line
            prev dot-line! prev length dot-offset!
            unlink
            prev last-line!
        ] }
    } cond

    modified
    t repaint?!
    renumber
;

: cut-line
    copy-line
    delete-line ;

: cut
    mark [ dot make-region/2 cut-region ] [ cut-line ] if* ;

: paste/1                               -- string -> void
    1 ?enough
    :> s
    '\n' s string-index [
        s insert-multiline-string
        t repaint?!
    ] [
        add-undo-line-edit
        dot-line-head s string-append
        dot-line-tail string-append
        dot-line-text!
        dot-offset s string-length + dot-offset!
        t dot-line-changed?!
    ] if
    modified
;

: paste
    last-kill [ paste/1 ] [ "Kill ring is empty" message ] if*
;

: redo1                                 -- undo-record -> void
    log-redo
    dup action>> {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ drop delete-line-separator ] }
        { +insert-line-separator+ [ drop insert-line-separator ] }
        { +delete-line+ [ drop delete-line ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: redo
    redo-stack empty? [
        "Nothing to redo" message
    ] [
        t in-redo?!
        pop-redo dup compound-undo? [
            "redo compound-undo" log
            [ records>> vector-reverse! ' redo1 each ] with-compound-undo
        ] [
            "redo" log
            redo1
        ] if
        f in-redo?!
        "Redo!" message
    ] if
;

: cycle-paste
    last-command ' paste eq? [
        next-kill [ undo paste/1 ] when*
    ] [
        paste
    ] if

    ' paste current-command!
;

"save.feline" load

: do-quit
    buffer-list [ buffer-modified? ] count :> n

    n zero? [
        t done?!
    ] [
        n dup 1 > "s" "" ?
        "Really exit with %s modified buffer%s? (yes or no) " format
        minibuffer-accept-string
        "yes" string= done?!
    ] if
;

: confirm-kill-current-buffer           -- -> ?
    f :> confirmed?!

    modified? [
        "Save file? (y or n) " minibuffer-accept-string
        "y" = [ do-save ] when
    ] when

    modified? [
        "Abandon changes? (yes or no) " minibuffer-accept-string
        "yes" = [ t confirmed?! ] when
    ] when

    confirmed?
;

: kill-current-buffer
    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    :> n!                                       --

    n buffer-list vector-remove-nth!

    n buffer-list length < [ n 1- n! ] unless

    n buffer-list vector-nth current-buffer!
    t repaint?!
;

: kill-buffer
    f :> confirmed?!

    modified? [ confirm-kill-current-buffer confirmed?! ] when

    modified? not confirmed? or [
        buffer-list length 1 = [
            0 buffer-list vector-set-length
            t done?!
        ] [
            kill-current-buffer
        ] if
    ] when
;

: buffer-append-line ( line buf )       -- line buffer -> void
    buf last-line>> line prev<<
    buf last-line>> [ line swap next<< ] when*
    line buf last-line<<
    buf first-line>> [
        line buf first-line<<
    ] unless
;

: create-buffer                         -- void -> void
    make-buffer :> buf
    "" 0 make-line/2

    [ buf buffer-append-line ]
    [ 0 make-position buf dot<< ]
    bi

    buf buffer-list vector-push
    buf current-buffer!

    dot-line top-line!
;

: create-buffer/2                       -- filename line-number -> void
    verify-index  :> line-number
    verify-string :> filename

    make-buffer :> buf

    filename buf filename<<

    filename path-extension [ modes at buf mode<< ] when*

    filename file-contents :> contents

    contents string-lines verify-vector :> lines

    contents empty? [
        "" lines vector-push
    ] [
        -- detect eol
        '\r' contents string-index CR+LF LF ? buf eol<<
        contents string-last-char '\n' eq? [
            "" lines vector-push
        ] when
    ] if

    lines [
        make-line/2 buf buffer-append-line
    ] each-index

    buf first-line>> line? assert
    buf last-line>>  line? assert

    buf first-line>> 0 make-position buf dot<<
    buf first-line>> buf top-line<<

    buf buffer-list vector-push

    buf current-buffer!

    line-number 1- 0 max line-count 1- min nth-line dot-line!
    0 dot-offset!

    maybe-reframe
;

: find-file-to-edit ( arg )             -- arg -> path/f
    arg find-file [
        arg ensure-feline-extension find-file
    ] unless*
;

: find-buffer ( filename )              -- filename -> buffer/f
    buffer-list [ filename>> filename = ] find  -- index/f element/f
    nip
;

: open-file
    "File: " minibuffer-accept-string :> arg

    arg find-file-to-edit :> filename

    filename [
        filename find-buffer [
            current-buffer!
            t repaint?!
        ] [
            filename 1 create-buffer/2
            t repaint?!
        ] if*
    ] when
;

: next-buffer
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1+ dup buffer-list length < [ drop 0 ] unless

    buffer-list vector-nth current-buffer!
    t repaint?!
;

: previous-buffer
    buffer-list length 2 < [ ] return-if

    buffer-list [ current-buffer eq? ] find     -- index/f element/f
    current-buffer assert-eq                    -- index
    1 - dup 0 >= [ drop buffer-list length 1 - ] unless

    buffer-list vector-nth current-buffer!
    t repaint?!
;

: identifier-at-dot                     -- -> string/f
    dot-offset dot-line-length 1- min 0 max :> offset!

    offset dot-line-text [ '\s' eq? ] find-last-from drop :> start!

    -- get to first non-blank char
    start [ start 1+ start! ] [ 0 start! ] if

    start dot-line-text string-skip-to-whitespace       -- -> index/f
    dot-line-length or [
        start swap dot-line-text string-substring
    ] [
        f
    ] if* ;

: goto-definition                       -- symbol -> void
    symbol-location :> line-number :> filename
    filename [
        filename find-buffer [
            current-buffer!
            line-number gotoline-internal
        ] [
            filename line-number create-buffer/2
        ] if*
        maybe-reframe
        t repaint?!
    ] when
;

: find-definition
    "Word: " minibuffer-accept-string
    find-qualified-name [
        goto-definition
    ] [
        all-words [ symbol-name over = ] filter nip
        dup length {
            { 0 [ drop ] }
            { 1 [ first goto-definition ] }
            [
                -- more than 1 match
                drop
                0 message-y at-xy
                [ symbol-qualified-name write-string space ] each
            ]
        } case
    ] if ;

: find-definition-at-dot
    identifier-at-dot
    find-qualified-name [
        goto-definition
    ] [
        all-words [ symbol-name over = ] filter nip
        dup length {
            { 0 [ drop ] }
            { 1 [ first goto-definition ] }
            [
                -- more than 1 match
                drop
                0 message-y at-xy
                [ symbol-qualified-name write-string space ] each
            ]
        } case
    ] if ;

: execute-command
    "Command: " minibuffer-accept-string :> command
    command find-name [
        call-symbol
    ] [
        "%S is not a valid command name." format message
    ] if
;

use: search

"keymaps.feline" load

: do-mouse                              -- key -> void
    dup fixnum? not [ drop ] return-if

    :> keycode
    f :> button! f :> x! f :> y!
--     keycode fixnum>hex log
    keycode 24 rshift 0x1b5b4d = [
        -- "\e[M"
        keycode 0xff bitand 32 - y!
        keycode 0xff00 bitand 8 rshift 32 - x!
        keycode 0xff0000 bitand 16 rshift 3 bitand zero? [
            -- left button pressed
--             x y "left button pressed x = %d y = %d" format log
            top-line-number y + gotoline-internal
            x 1- 0 max dot-line-length min dot-offset!
        ] when
    ] when
;

: do-command                            -- key ->
    dup lookup-key [
        nip dup current-command! call-symbol
    ] [
        linux? [ do-mouse ] [ drop ] if
    ] if* ;

: dispatch                              -- key ->
    current-command last-command!
    f current-command!
    dup printable-char? [ do-normal-char ] [ do-command ] if ;

: edit-loop
    f done?!
    [ done? ] [
        update-display
        ekey
        clear-message-line
        dispatch
    ] until

    -- clean up
    f current-buffer!
    f buffer-list!
    gc
    close-log
;

: initialize-editor
    16 <vector> buffer-list!
    initialize-kill-ring
    initialize-global-keymaps
;

: edit1
    use-alternate-screen-buffer

    page
    normal
    maybe-reframe
    t repaint?!

    linux? [
        -- enable mouse tracking
        "\e[?1000h" write-string-escaped
    ] when

    edit-loop

    clear-status-line
    clear-message-line
    0 text-rows at-xy
    show-cursor

    use-default-screen-buffer
;

: edit-file ( name )                    -- name -> void
    name find-file-to-edit [
        initialize-editor
        1 create-buffer/2
        edit1
    ] [
        name error-file-not-found
    ] if*
;

: edit-definition                       -- symbol ->
    symbol-location 2dup and
    [
        initialize-editor
        create-buffer/2
        edit1
    ] [
        2drop
    ] if
;

: edit-new
    initialize-editor
    create-buffer
    edit1
;

: edit
    parse-token dup [
        find-name [ edit-definition ] [ edit-file ] if
    ] [
        drop edit-new
    ] if
;

: ed
    use-alternate-screen-buffer
    page
    normal
    t repaint?!
    edit-loop
    clear-status-line
    clear-message-line
    0 text-rows at-xy
    show-cursor
    use-default-screen-buffer
;
