// Copyright (C) 2018-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feline ;
in: feline

public

: alphanumeric?                         // char -> ?

    dup char? not [ error-not-char ] return-if

    char-code :> c

    { [ 'A' char-code c <= ] [ c 'Z' char-code <= ] } && [ t ] return-if
    { [ 'a' char-code c <= ] [ c 'z' char-code <= ] } && [ t ] return-if
    { [ '0' char-code c <= ] [ c '9' char-code <= ] } && [ t ] return-if

    f
;

using: feral-core modes feline accessors segments ;
in: asm-mode

private

tuple: asm-mode
    formatter ;

: asm-mode-identifier-char? ( x )       // x -> ?
    { [ x alphanumeric? ] [ x "_$#@~.?" member-eq? ] } ||
;

: asm-mode-identifier-at-dot            // void -> start/f string/f

    { [ mark ] [ mark-line dot-line eq? ] } && [
        mark dot make-region/2 begin-offset
    ] [
        dot-offset dot-line-length 1- min 0 max
    ] if :> offset

    offset dot-line-text [ asm-mode-identifier-char? not ] find-last-from drop :> start!

    // advance to first identifier char
    start [ start 1+ start! ] [ 0 start! ] if

    start dot-line-text [ asm-mode-identifier-char? not ] find-from drop :> end!

    end [ dot-line-length end! ] unless

    start
    start end dot-line-text string-substring
;

method: asm-mode identifier-at-dot      // void -> start/f string/f
    drop
    asm-mode-identifier-at-dot ;

: asm-format-line ( s )                 // string -> string'
    ";" s substring-start :> comment-start

    comment-start [
        s comment-start string-head 0 color-text make-segment/3
        s comment-start string-tail comment-start color-comment make-segment/3
        2array
    ] [
        s 0 color-text make-segment/3
        1array
    ] if ;

: initialize-asm-mode
    asm-mode make-instance :> m
    ' asm-format-line m formatter<<
    m ".asm" modes set-at ;

initialize-asm-mode
