// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors ;
in: editor

: check-read-only // void -> ?
    current-buffer read-only>> dup [ "Buffer is read-only" message ] when ;

: delete-region/1 ( region ) // region -> void
    region add-undo-delete-region

    0 region begin-offset region begin-line substring :> head
    region end-offset region end-line length region end-line substring :> tail

    head tail + region begin-line text<<

    region end-line next>> :> next
    next region begin-line next<<
    next [ region begin-line next prev<< ] when

    unmark
    region begin copy-position dot!

    modified
    renumber
    maybe-reframe
    true repaint?! ;

: delete-region // void -> void
    mark [ dot mark make-region/2 delete-region/1 ] when ;

: insert-line-separator
    add-undo-insert-line-separator
    insert-line-separator-internal
    0 goal-column!
    modified
    true repaint?!
    renumber ;

: insert-spaces ( n )                   // n ->
    // no undo
    dot-line-head string>sbuf :> sb
    n [ '\s' sb sbuf-push ] times
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line-text!
    dot-offset n + dot-offset!
    true dot-line-changed?!
    modified ;

: do-tab
    add-undo-line-edit
    indent-size dot-offset indent-size mod - insert-spaces
    update-goal-column ;

: get-indentation-column                // line -> column
    dup empty? [ drop 0 ] ?return

    detab
    [ char-code 32 > ] find             // index/f element/f
    [ drop 0 ] unless ;

: delete-indentation                    // string -> string'
    dup empty? ?exit

    :> text

    text [ char-code 32 > ] find        // index/f element/f
    [ text string-tail ] [ drop "" ] if ;

: newline-and-indent
    check-read-only ?exit

    reset-redo

    dot-line-text get-indentation-column :> indent-col

    [
        mark [ delete-region ] when
        insert-line-separator
        add-undo-line-edit
        dot-line-text delete-indentation dot-line-text!
        indent-col 0 > [
            indent-col insert-spaces
        ] when
    ] with-compound-undo

    reframe? [
        dot-line-number textview-rows 1- - nth-line top-line!
        true repaint?!
    ] when ;

: make-indentation-string ( n )         // n -> string
    n <sbuf> :> sb
    n [ '\s' sb push ] times
    sb sbuf>string ;

: indent-line
    mark ?exit
    add-undo-line-edit
    dot-offset :> old-dot-offset
    indent-size make-indentation-string dot-line-text + dot-line-text!
    old-dot-offset indent-size + dot-offset!
    modified
    true dot-line-changed?! ;

: indent-region
    mark null? ?exit
    indent-size make-indentation-string :> s
    dot mark make-region/2 :> region
    region editor:add-undo-edit-region
    region [ s over text>> + swap text<< ] region-each-line
    modified
    true repaint?! ;

: indent
    mark [ indent-region ] [ indent-line ] if ;

: unindent-line
    mark ?exit
    dot-line indentation-length indent-size min :> n
    n 0 > [
        add-undo-line-edit
        n dot-line-text tail dot-line-text!
        dot-offset n - 0 max dot-offset!
    ] when
    modified
    true dot-line-changed?! ;

: unindent-line-internal ( line )
    // no undo
    line indentation-length indent-size min :> n
    n 0 > [
        n line text>> tail line text<<
        modified
    ] when ;

: unindent-region
    mark null? ?exit
    dot mark make-region/2 :> region
    region editor:add-undo-edit-region
    region [
        unindent-line-internal
    ] region-each-line
    true repaint?! ;

: unindent
    mark [ unindent-region ] [ unindent-line ] if ;

: comment-region
    // REVIEW comment-padding

    current-mode comment-start>> :> s
    s empty? ?exit

    nil !> region
    mark [
        dot mark make-region/2 region!
        [
            region editor:add-undo-edit-region
            region [ s over text>> + swap text<< ] region-each-line
            add-undo-move
            unmark
        ] with-compound-undo
    ] [
        editor:add-undo-line-edit
        s dot-line-text + dot-line-text!
        dot-offset s length + dot-offset!
        true dot-line-changed?!
    ] if
    modified ;

: uncomment-region
    // REVIEW comment-padding

    current-mode comment-start>> :> s
    s empty? ?exit

    nil !> region
    mark [
        dot mark make-region/2 region!
        [
            region editor:add-undo-edit-region
            region [
                s over text>> head? [
                    s length over text>> tail swap text<<
                ] [
                    drop
                ] if
            ] region-each-line
            add-undo-move
            unmark
        ] with-compound-undo
    ] [
        s dot-line-text head? [
            editor:add-undo-line-edit
            s length dot-line-text tail dot-line-text!
            dot-offset s length - 0 max dot-offset!
            true dot-line-changed?!
        ] when
    ] if
    modified ;

: string-remove-nth                     // n string1 -> string2
    check-bounds

    :> s
    :> n

    n s string-head
    n 1+ s string-length < [
        n 1+ s string-tail string-append
    ] when ;

: delete-normal-char
    add-undo-line-edit
    dot-offset dot-line-text string-remove-nth dot-line-text!
    true dot-line-changed?! ;

: delete-line-separator
    dot-line-next at-eol? and [
        add-undo-delete-line-separator
        dot-line-text dot-line-next text>> + dot-line-text!
        dot-line-next unlink
        renumber
        true repaint?!
    ] when ;

: backspace
    at-bof? ?exit
    check-read-only ?exit
    mark [ delete-region ] ?return
    dot-offset 0> [
        add-undo-line-edit
        dot-offset 1-
        [ dot-line text>> string-remove-nth dot-line text<< ] [ dot-offset! ] bi
        true dot-line-changed?!
        modified
    ] [
        dot-line-prev assert
        [ move-left delete-line-separator modified ] with-compound-undo
    ] if
    update-goal-column ;

private: insert-char-internal // char -> void
    // no undo

    dot-offset dot-line-length <= assert

    dot-line-head string>sbuf :> sb
    sb sbuf-push
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line text<<

    dot-offset 1+ dot-offset!
    true dot-line-changed?!
    modified
    dot-offset goal-column! ;

: insert-char // char -> void
    check-read-only ?exit

    reset-redo

    current-command assert-false
    ' insert-char current-command!

    mark [
        [ delete-region add-undo-line-edit insert-char-internal ] with-compound-undo
    ] [
        last-command ' insert-char eq? [ add-undo-line-edit ] unless
        insert-char-internal
    ] if ;

// REVIEW
feral-config:winui? feral-config:gtkui? or #if
' insert-char is mini:minibuffer-insert-char
#endif

use: kill-ring

: kill-line
    dot-line-tail length zero? [
        delete-line-separator
        current-buffer eol>> verify-string append-kill
    ] [
        add-undo-line-edit
        dot-line-tail append-kill
        dot-line-head dot-line-text!
        true dot-line-changed?!
    ] if
    modified ;

: select-line
    dot-line-next null? ?exit

    reset-redo

    add-undo-move

    dot-line-prev dup line-selected? and [
        // we're not extending an existing selection
        dot-line 0 make-position mark!
    ] unless

    dot-line-next 0 make-position dot!

    reframe? [
        dot-line-number textview-rows 1- - nth-line top-line!
    ] when

    true repaint?! ;

: do-anchor
    unmark
    copy-dot anchor! ;

: insert-multiline-string               // string -> void
    // insert multiline string at dot
    [ add-undo-insert-multiline-string ]
    [ insert-multiline-string-internal ] bi ;

: delete-word-right
    mark [ delete-region ] ?return

    at-eof? ?exit

    at-eol? [ delete-line-separator modified ] ?return

    [
        add-undo-move
        dot copy-position mark!

        {
            [ in-word? ] =>
            [
                // delete to end of word
                [ in-word? ] [ ++dot-offset ] while
            ]

            [ in-whitespace? ] =>
            [
                ++dot-offset

                {
                    [ in-whitespace? ] =>
                    [
                        // delete rest of whitespace
                        [ in-whitespace? ] [ ++dot-offset ] while
                    ]

                    [ in-word? ] =>
                    [
                        // delete to end of word
                        [ in-word? ] [ ++dot-offset ] while
                    ]

                    // not in word, not in whitespace
                    [ true ] =>
                    [
                        [ in-word? in-whitespace? or at-eol? or ]
                        [ ++dot-offset ] until
                    ]
                } cond
            ]

            // not in word, not in whitespace
            [ true ] =>
            [
                [ in-word? in-whitespace? or at-eol? or ] [ ++dot-offset ] until
            ]
        } cond

        delete-region

    ] with-compound-undo ;

: delete-word-left
    mark [ delete-region ] ?return

    at-bof? ?exit

    at-bol? [
        [
            add-undo-move
            char-left-internal
            delete-line-separator
            modified
        ] with-compound-undo
    ] ?return

    [
        add-undo-move
        dot copy-position mark!

        --dot-offset

        {
            [ in-word? ] =>
            [
                // move left to beginning of word
                [ in-word? at-bol? not and ] [ --dot-offset ] while
                in-word? [ ++dot-offset ] unless
            ]

            [ in-whitespace? ] =>
            [
                --dot-offset

                {
                    [ in-whitespace? ] =>
                    [
                        // delete rest of whitespace
                        [ in-whitespace? at-bol? not and ] [ --dot-offset ] while
                        in-whitespace? [ ++dot-offset ] unless
                    ]

                    [ in-word? ] =>
                    [
                        // move left to beginning of word
                        [ in-word? at-bol? not and ] [ --dot-offset ] while
                        in-word? [ ++dot-offset ] unless
                    ]

                    // not in word, not in whitespace
                    [ true ] =>
                    [
                        [ in-word? in-whitespace? or at-bol? or ] [ --dot-offset ] until
                        [ in-word? in-whitespace? or ] [ ++dot-offset ] when
                    ]
                } cond
            ]

            // not in word, not in whitespace
            [ true ] =>
            [
                [ in-word? in-whitespace? or at-bol? or ] [ --dot-offset ] until
                [ in-word? in-whitespace? or ] [ ++dot-offset ] when
            ]
        } cond

        delete-region

    ] with-compound-undo ;

: do-delete
    check-read-only ?exit
    {
        { [ mark ] [ delete-region ] }
        { [ dot-offset dot-line-length < ] [ delete-normal-char ] }
        // otherwise...
        [ delete-line-separator ]
    } cond
    modified
    update-goal-column ;

: cut-region ( region )
    region region-as-string append-kill
    region delete-region/1 ;

: copy-line
    dot-line-text "\n" string-append append-kill
    "Line copied to kill ring" message ;

: copy-region                           // region -> void
    region-as-string append-kill
    "Region copied to kill ring" message ;

: copy
    [ anchor ] [ mark ] either?
    [ dot make-region/2 copy-region ] [ copy-line ] if* ;

: delete-line-internal
    dot-line-prev :> prev
    dot-line-next :> next

    {
        {
            [ prev next and ]
            [
                dot-line
                next dot-line! 0 dot-offset!
                unlink
            ]
        }
        {
            [ prev null? ]
            [
                // deleting first line
                dot-line
                next dot-line! 0 dot-offset!
                unlink
                next dup first-line! top-line!
            ]
        }
        {
            [ next null? ]
            [
                // deleting last line
                dot-line
                prev dot-line! prev length dot-offset!
                unlink
                prev last-line!
            ]
        }
    } cond
    modified
    renumber
    true repaint?! ;

: delete-line
    unmark
    reset-redo
    add-undo-delete-line
    delete-line-internal ;

: join-lines
    dot-line-next null? ?exit

    dot-line-next text>> string-trim-head :> next-line-trimmed-text
    dot-line-length :> new-dot-offset

    next-line-trimmed-text length zero? [
        dot-line-text
    ] [
        dot-line-text " " + next-line-trimmed-text +
    ] if :> new-dot-line-text

    [
        move-to-eol
        delete-line-separator
        next-line-trimmed-text length zero? [
            add-undo-line-edit
            new-dot-line-text dot-line-text!
            add-undo-move
            new-dot-offset dot-offset!
        ] unless
    ] with-compound-undo

    modified
    renumber
    true repaint?! ;

: cut-line
    copy-line
    delete-line ;

: cut
    mark [ dot make-region/2 cut-region ] [ cut-line ] if* ;

: paste1-internal ( s )                 // string -> void
    {
        {
            [ s string-?last '\n' eq? ]
            [
                // one or more full lines (to a first approximation)
                // insert string before line containing dot
                [
                    dot-offset
                    add-undo-move
                    0 dot-offset!
                    s insert-multiline-string
                    add-undo-move
                    dot-offset!
                ] with-compound-undo
                maybe-reframe
                true repaint?!
            ]
        }

        {
            [ '\n' s string-index ]
            [
                s insert-multiline-string
                maybe-reframe
                true repaint?!
            ]
        }

        [
            // default case
            // no newlines in string
            add-undo-line-edit
            dot-line-head s + dot-line-tail + dot-line-text!
            dot-offset s length + dot-offset!
            true dot-line-changed?!
        ]
    } cond

    modified ;

: paste1                                // string -> void
    1 ?enough :> s
    reset-redo
    mark [
        [ delete-region s paste1-internal ] with-compound-undo
    ] [
        s paste1-internal
    ] if ;

: paste
    last-kill [ paste1 ] [ "Kill ring is empty" message ] if* ;

: cycle-paste
    last-command ' paste eq? [
        next-kill [ undo paste1 ] when*
    ] [
        paste
    ] if

    ' paste current-command! ;

: redo-insert-multiline-string          // undo-record -> void
    data>> insert-multiline-string
    modified
    renumber
    true repaint?! ;

: redo-delete-region                    // undo-record -> void
    drop
    delete-region ;

: redo-delete-line                      // undo-record -> void
    drop
    delete-line-internal ;

: redo1                                 // undo-record -> void
    dup action>> {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +edit-region+ [ redo-edit-region ] }
        { +delete-line-separator+ [ drop delete-line-separator ] }
        { +insert-line-separator+ [ drop insert-line-separator ] }
        { +delete-line+ [ redo-delete-line ] }
        { +delete-region+ [ redo-delete-region ] }
        { +insert-multiline-string+ [ redo-insert-multiline-string ] }
        [ error "unsupported" ]
    } case
    maybe-reframe ;

: redo
    redo-stack empty? [
        "Nothing to redo" message
    ] [
        true in-redo?!
        pop-redo dup compound-undo? [
            [ records>> vector-reverse! ' redo1 each ] with-compound-undo
        ] [
            redo1
        ] if
        nil in-redo?!
        "Redo!" message
    ] if ;
