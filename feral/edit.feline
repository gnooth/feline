// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors mini ;
in: editor

: insert-line-separator
    add-undo-insert-line-separator
    dot-line-tail make-line/1 :> new-line
    dot-line-head dot-line-text!
    new-line dot-line insert-after
    new-line dot-line!
    0 dot-offset!
    0 goal-column!
    modified
    t repaint?!
    renumber
;

: insert-spaces ( n )                   // n ->
    // no undo
    dot-line-head string>sbuf :> sb
    n [ '\s' sb sbuf-push ] times
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line-text!
    dot-offset n + dot-offset!
    t dot-line-changed?!
    modified
;

: do-tab
    add-undo-line-edit
    4 dot-offset 4 mod - insert-spaces
;

: get-indentation-column                // line -> column
    dup empty? [ drop 0 ] return-if

    detab
    [ char-code 32 > ] find             // index/f element/f
    [ drop 0 ] unless
;

: delete-indentation                    // string -> string'
    dup empty? [ ] return-if

    :> text

    text [ char-code 32 > ] find        // index/f element/f
    [ text string-tail ] [ drop "" ] if
;

: newline-and-indent
    reset-redo

    dot-line-text get-indentation-column :> indent-col

    [
        insert-line-separator
        add-undo-line-edit
        dot-line-text delete-indentation dot-line-text!
        indent-col 0 > [
            indent-col insert-spaces
        ] when
    ] with-compound-undo

    reframe? [
        dot-line-number textview-rows 1- - nth-line top-line!
        t repaint?!
    ] when
;

: string-remove-nth                     // n string1 -> string2
    check-bounds

    :> s
    :> n

    n s string-head
    n 1+ s string-length < [
        n 1+ s string-tail string-append
    ] when
;

: delete-normal-char
    add-undo-line-edit
    dot-offset dot-line-text string-remove-nth dot-line-text!
    t dot-line-changed?!
;

: delete-line-separator
    dot-line-next [
        dot-offset dot-line-length eq? [
            add-undo-delete-line-separator
            dot-line-text dot-line-next text>> string-append dot-line-text!
            dot-line-next unlink
            renumber
            t repaint?!
        ] when
    ] when
;

: do-delete
    dot-offset dot-line-length < [
        delete-normal-char
    ] [
        delete-line-separator
    ] if
    modified
;

: do-bs
    {
        { [ dot-offset 0 > ] [
            add-undo-line-edit
            dot-offset 1-
            [ dot-line text>> string-remove-nth dot-line text<< ] [ dot-offset! ] bi
            t dot-line-changed?!
            modified
        ] }
        { [ dot-line-prev ] [
            [
                do-left
                delete-line-separator
                modified
            ] with-compound-undo
        ] }
        // do nothing if dot is at beginning of buffer
        [ ]
    } cond
;

: do-normal-char                        // char ->
    reset-redo

    current-command assert-false
    ' do-normal-char current-command!
    last-command ' do-normal-char eq? [ add-undo-line-edit ] unless

    dot-line-head string>sbuf :> sb
    sb sbuf-push
    dot-line-tail sb sbuf-append-string
    sb sbuf>string dot-line text<<
    dot-offset 1+ dot-offset!
    t dot-line-changed?!
    modified
    dot-offset goal-column!
;

use: kill-ring

: kill-line
    dot-line-tail length zero? [
        delete-line-separator
        current-buffer eol>> verify-string append-kill
    ] [
        add-undo-line-edit
        dot-line-tail append-kill
        dot-line-head dot-line-text!
        t dot-line-changed?!
    ] if
    modified
;

: select-line
    dot-line-prev dup line-selected? and [
        // extend selection if possible
        dot-line-next [
            dot-line-next dot-line! 0 dot-offset!
        ] when
    ] [
        dot-line-next [
            add-undo-move
            dot-line 0 make-position mark!
            dot-line-next dot-line! 0 dot-offset!
        ] when
    ] if

    t repaint?!
;

: do-anchor
    unmark
    copy-dot anchor! ;

: insert-multiline-string               // string -> void
    // insert string before line containing dot
    add-undo-insert-multiline-string

    dot-line-prev :> prev!

    string-lines [
        make-line/1 dup prev insert-after prev!
    ] each

    renumber
;

: cut-region ( region )
    region begin-line region end-line eq? [

        region begin-line dot-line assert-eq

        region region-as-string append-kill

        add-undo-line-edit
        region begin-offset dot-line-text string-head
        region end-offset dot-line-text string-tail
        string-append dot-line-text!

        unmark
        region begin-offset dot-offset!
        t dot-line-changed?!
        modified
    ] return-if

;

: copy-line
    dot-line-text "\n" string-append append-kill
    "Line copied to kill ring" message
;

: copy-region                           // region -> void
    region-as-string append-kill
    "Region copied to kill ring" message
;

: copy
    { [ anchor ] [ mark ] } ||
    [ dot make-region/2 copy-region ] [ copy-line ] if*
;

: delete-line
    reset-redo

    add-undo-delete-line

    dot-line-prev :> prev
    dot-line-next :> next

    {
        { [ prev next and ] [
            dot-line
            next dot-line! 0 dot-offset!
            unlink
        ] }
        { [ prev null? ] [
            // deleting first line
            dot-line
            next dot-line! 0 dot-offset!
            unlink
            next dup first-line! top-line!
        ] }
        { [ next null? ] [
            // deleting last line
            dot-line
            prev dot-line! prev length dot-offset!
            unlink
            prev last-line!
        ] }
    } cond

    modified
    t repaint?!
    renumber
;

: cut-line
    copy-line
    delete-line ;

: cut
    mark [ dot make-region/2 cut-region ] [ cut-line ] if* ;

: paste/1                               // string -> void
    1 ?enough
    :> s
    '\n' s string-index [
        s insert-multiline-string
        t repaint?!
    ] [
        add-undo-line-edit
        dot-line-head s string-append
        dot-line-tail string-append
        dot-line-text!
        dot-offset s string-length + dot-offset!
        t dot-line-changed?!
    ] if
    modified
;

: paste
    last-kill [ paste/1 ] [ "Kill ring is empty" message ] if*
;

: redo1                                 // undo-record -> void
    dup action>> {
        { +move+ [ undo-move ] }
        { +line-edit+ [ undo-line-edit ] }
        { +delete-line-separator+ [ drop delete-line-separator ] }
        { +insert-line-separator+ [ drop insert-line-separator ] }
        { +delete-line+ [ drop delete-line ] }
        [ error "unsupported" ]
    } case
    maybe-reframe
;

: redo
    redo-stack empty? [
        "Nothing to redo" message
    ] [
        t in-redo?!
        pop-redo dup compound-undo? [
            [ records>> vector-reverse! ' redo1 each ] with-compound-undo
        ] [
            redo1
        ] if
        f in-redo?!
        "Redo!" message
    ] if
;

: cycle-paste
    last-command ' paste eq? [
        next-kill [ undo paste/1 ] when*
    ] [
        paste
    ] if

    ' paste current-command!
;
