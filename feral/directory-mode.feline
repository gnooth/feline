// Copyright (C) 2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors ;
in: directory-mode

private

global instance

global directory-mode-local-map

: name-offset // string -> index/nil
    1 ?enough verify-string :> s

    nil !> index

    win64? [
        // Windows
        // 09/25/2017  12:32 PM               190 .gitignore
        // 05/24/2019  09:37 AM             3,019 directory-mode.feline
        //                                      ^^^

        // For an ordinary file, we require a digit at offset 37, followed
        // by a space, followed by an alphanumeric character or '.'.
        {
            [ 37 s ?nth digit? ]
            [ 38 s ?nth '\s' eq? ]
            [ 39 s ?nth dup alphanumeric? swap '.' eq? or ]
        } && // -> ?
        [
            // The string qualifies. The name begins at offset 39.
            39
        ] [
            // For a directory...
            "<DIR>          " s substring-start // -> index/nil
            [ 15 + ] [ nil ] if*
        ] if
    ] [
        // Linux
        // -rw-rw-r-- 1 peter peter  3224 May 24 10:10 directory-mode.feline
        //                                           ^^^

        s length 1- s [ '\s' eq? ] find-last-from // -> index/nil element/nil
        [
            index!
            {
                [ index 1-  s ?nth digit? ]
                [ index s ?nth '\s' eq? ]
                [ index 1+ s ?nth dup alphanumeric? swap '.' eq? or ]
            } && // -> ?
            index 1+ nil ?
        ] when
    ] if ;

: get-instance // void -> mode
    instance ;

: directory-contents ( dirname )        // dirname -> string
    win64? [
        "dir /A:-L "
        // Quotes are needed here for filenames that contain spaces.
        // Filenames without spaces don't seem to mind being quoted.
        "\"" + dirname + "\"" +
    ] [
        "ls -la " dirname +
    ] if
    shell-command-to-string ;

: directory-mode-initialize-buffer // buffer -> void
    1 ?enough :> buf
    directory-mode-local-map buf local-map<< ;

: create-directory-buffer ( dirname )   // dirname -> buffer/nil
    dirname directory-contents :> s

    s empty? [ nil ] ?return

    nil !> buf
    s length 0> [
        make-buffer buf!
        s buf editor:buffer-set-contents
        buf first-line>> 0 make-position buf dot<<
        buf first-line>> buf top-line<<
        t buf read-only<<
        dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri

        directory-mode:get-instance buf mode<<
        buf directory-mode-initialize-buffer

        buf buffer-list vector-push
    ] when
    buf ;

: open-directory ( dirname ) // dirname -> void
    dirname directory? [
        dirname create-directory-buffer [
            current-buffer!
            t repaint!
        ] when*
    ] when ;

: open-directory-in-current-buffer ( dirname ) // dirname -> void
    current-buffer :> buf
    dirname directory-contents :> s
    s empty? [
        s buf editor:buffer-set-contents
        buf first-line>> 0 make-position buf dot<<
        buf first-line>> buf top-line<<
        t buf read-only<<
        dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri
        renumber
        maybe-reframe
        t repaint!
    ] unless ;

: dir
    current-buffer filename>> [
        file-name-directory
    ] [
        get-current-directory
    ] if* :> dirname

    dirname editor:find-buffer-from-file-name [
        set-current-buffer
    ] [
        dirname open-directory
    ] if* ;

: dir-open-file                         // void -> void
    dot-line-text :> s

    nil !> name
    s name-offset [
        s tail name!
        current-buffer filename>> name path-append
        canonical-path
    ] [ nil ] if* :> filename

    filename [
        filename editor:find-buffer-from-file-name [
            set-current-buffer
        ] [
            filename directory? [
                filename open-directory-in-current-buffer
            ] [
                filename 1 editor:create-buffer/2
            ] if
        ] if*
    ] when ;

: dir-up-dir
    nil !> dirname
    current-buffer :> buf
    buf filename>> [
        file-name-directory dirname!
        dirname [
            dirname directory? [
                dirname directory-contents buf editor:buffer-set-contents
                buf first-line>> 0 make-position buf dot<<
                buf first-line>> buf top-line<<
                t buf read-only<<
                dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri
                t repaint!
            ] when
        ] when
    ] when* ;

: initialize-local-map
    128 <hashtable> :> m
    ' dir-open-file     feral-key:enter     m set-at
    ' dir-up-dir        'u'                 m set-at
    ' dir-up-dir        '^'                 m set-at // Emacs
    m directory-mode-local-map! ;

initialize-local-map

feral-config:winui? #if
' dir-open-file feral-key:double-mouse-1 directory-mode-local-map set-at
#endif

: initialize-directory-mode
    mode make-instance :> m
    "Directory" m name<<
    ' directory-mode-initialize-buffer m initialize-buffer-function<<
    m instance! ;

initialize-directory-mode

using: feline ;
in: editor

public

: dir directory-mode:dir ;
