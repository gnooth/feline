// Copyright (C) 2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors directories mini ;
in: directory-mode

private

tuple: directory-mode ;

global instance

global directory-mode-local-map

public

: name-offset                           // string -> index/f
    1 ?enough verify-string :> s

    f :> index!

    win64? [
        // Windows
        // 09/25/2017  12:32 PM               190 .gitignore
        // 05/24/2019  09:37 AM             3,019 directory-mode.feline
        //                                      ^^^

        // For an ordinary file, we require a digit at offset 37, followed
        // by a space, followed by an alphanumeric character or '.'.
        {
            [ 37 s ?nth digit? ]
            [ 38 s ?nth '\s' eq? ]
            [ 39 s ?nth dup alphanumeric? swap '.' eq? or ]
        } && // -> ?
        [
            // The string qualifies. The name begins at offset 39.
            39
        ] [
            // For a directory...
            "<DIR>          " s substring-start // -> index/f
            [ 15 + ] [ f ] if*
        ] if
    ] [
        // Linux
        // -rw-rw-r-- 1 peter peter  3224 May 24 10:10 directory-mode.feline
        //                                           ^^^

        s length 1- s [ '\s' eq? ] find-last-from // -> index/f element/f
        [
            index!
            {
                [ index 1-  s ?nth digit? ]
                [ index s ?nth '\s' eq? ]
                [ index 1+ s ?nth dup alphanumeric? swap '.' eq? or ]
            } && // -> ?
            index 1+ f ?
        ] when
    ] if ;

: get-instance                          // void -> directory-mode
    instance [
        directory-mode make-instance dup instance!
    ] unless* ;

method: directory-mode initialize-buffer // buffer mode -> void
    2 ?enough
    drop :> buf
    get-instance dup assert buf mode<<
    directory-mode-local-map buf local-map<<
    t buf read-only<< ;

: directory-contents ( dirname )        // dirname -> string
    win64? [
        "dir /A:-L "
        // Quotes are needed here for filenames that contain spaces.
        // Filenames without spaces don't seem to mind being quoted.
        "\"" + dirname + "\"" +
    ] [
        "ls -la " dirname +
    ] if
    shell-command-to-string ;

: create-directory-buffer ( dirname )   // dirname -> buffer/f
    dirname directory-contents :> s

    s empty? [ f ] return-if

    f :> buf!
    s length 0 > [
        make-buffer buf!
        s buf editor:buffer-set-contents
        buf first-line>> 0 make-position buf dot<<
        buf first-line>> buf top-line<<
        t buf read-only<<
        dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri

        directory-mode:get-instance dup buf mode<<
        buf swap initialize-buffer

        buf buffer-list vector-push
    ] when
    buf ;

: open-directory ( dirname ) // dirname -> void
    dirname directory? [
        dirname create-directory-buffer [
            current-buffer!
            t repaint!
        ] when*
    ] when ;

: open-directory-in-current-buffer ( dirname ) // dirname -> void
    current-buffer :> buf
    dirname directory-contents :> s
    s empty? [
        s buf editor:buffer-set-contents
        buf first-line>> 0 make-position buf dot<<
        buf first-line>> buf top-line<<
        t buf read-only<<
        dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri
        renumber
        maybe-reframe
        t repaint!
    ] unless ;

using: directory-mode feral-core feline accessors ;
in: editor

public

: dir
    current-buffer filename>> [
        file-name-directory
    ] [
        get-current-directory
    ] if* :> dirname

    dirname find-buffer-from-file-name [
        set-current-buffer
    ] [
        dirname open-directory
    ] if* ;

: dir-open-file                         // void -> void
    dot-line-text :> s

    f :> name!
    s name-offset [
        s tail name!
        current-buffer filename>> name path-append
        canonical-path
    ] [ f ] if* :> filename

    filename [
        filename find-buffer-from-file-name [
            set-current-buffer
        ] [
            filename directory? [
                filename open-directory-in-current-buffer
            ] [
                filename 1 create-buffer/2
            ] if
        ] if*
    ] when ;

: dir-up-dir
    f :> dirname!
    current-buffer :> buf
    buf filename>> [
        file-name-directory dirname!
        dirname [
            dirname directory? [
                dirname directory-contents buf buffer-set-contents
                buf first-line>> 0 make-position buf dot<<
                buf first-line>> buf top-line<<
                t buf read-only<<
                dirname buf [ filename<< ] [ directory<< ] [ name<< ] 2tri
                t repaint!
            ] when
        ] when
    ] when* ;

using: feline ;
in: directory-mode

private

: initialize-local-map
    128 <hashtable> :> m
    ' editor:dir-open-file      feral-key:enter     m set-at
    ' editor:dir-up-dir         'u'                 m set-at
    ' editor:dir-up-dir         '^'                 m set-at // Emacs
    m directory-mode-local-map!
;

initialize-local-map

feral-config:winui? #if

' editor:dir-open-file feral-key:double-mouse-1 directory-mode-local-map set-at

#endif
