// Copyright (C) 2017-2020 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors editor search-mode history feral-config mini ;
in: search

empty

private

: current-pattern                       // -> string/nil
    current-search [ pattern>> ] [ nil ] if* ;

: whole-words-only?                     // -> ?
    current-search [ whole-words-only>> ] [ nil ] if* ;

: found ( pos )                         // position -> void
    reset-redo

    add-undo-move
    pos mark!
    mark-line mark-offset current-pattern string-length + make-position dot!
    dot-offset goal-column!

    maybe-reframe
    true repaint?! ;

: not-found
    current-pattern "%S not found" format
    message ;

: find-char-in-range ( char string start end )  // char string start end -> i/nil
    start end [ string string-nth-unsafe char eq? ] find-integer-in-range ;

: find-substring-in-range ( pattern string start end )  // pattern string start end -> i/nil
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start end [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-integer-in-range ;

: find-substring-from ( pattern string start )  // pattern string start -> i/nil
    string string-length pattern string-length - 1+ :> end
    pattern string start end find-substring-in-range ;

: find-substring-in-line ( pattern line )       // pattern line -> position/nil
    pattern line text>> 0 find-substring-from
    [ line swap make-position ] [ nil ] if* ;

: search-forward ( pattern startpos )   // string position -> position/nil
    startpos line>> !> line
    startpos offset>> :> offset

    pattern line text>> offset find-substring-from !> index

    index [ line index make-position ] ?return

    line next>> line!

    nil !> result

    [ line ] [
        pattern line find-substring-in-line [
            result!
            nil line!
        ] [
            line next>> line!
        ] if*
    ] while

    result ;

: find-last-substring-in-range ( pattern string start end ) // string1 string2 start end -> i/nil
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start string string-length pattern-length - 1+ end min [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-last-integer-in-range ;

: find-last-substring-from ( pattern string from ) // pattern string from -> i/nil
    pattern string 0
    string string-length pattern string-length - 1+ from min
    find-last-substring-in-range ;

: find-last-substring-in-line ( pattern line ) // pattern line -> position/nil
    pattern line text>> line length find-last-substring-from
    [ line swap make-position ] [ nil ] if* ;

: search-backward ( pattern startpos )  // pattern startpos -> position/nil
    startpos line>> !> line
    startpos offset>> :> offset

    pattern line text>> offset find-last-substring-from !> index

    index [ line index make-position ] ?return

    line prev>> line!

    nil !> result

    [ line ] [
        pattern line find-last-substring-in-line [
            result!
            nil line!
        ] [
            line prev>> line!
        ] if*
    ] while

    result ;

: delimited? ( pos len )                // position length -> ?
    pos line>> :> line
    pos offset>> :> offset

    true !> result

    offset 0> [
        offset 1- line text>> string-nth identifier-char? [
            nil result!
        ] when
    ] when

    result nil? [ nil ] ?return

    offset len + :> after

    after line length < [
        after line text>> string-nth identifier-char? [
            nil result!
        ] when
    ] when

    result ;

: find-word-in-line ( pattern line )    // pattern line -> position/nil
    0 !> index
    nil !> pos

    [ index pos nil? and ] [
        pattern line text>> index find-substring-from index!
        index [
            line index make-position pos!
            pos pattern string-length delimited? [ nil pos! ] unless
            index line length < [ index 1+ ] [ nil ] if index!
        ] when
    ] while

    pos ;

: find-in-line ( search line )          // search line -> position/nil
    search whole-words-only>> [
        search pattern>> line find-word-in-line
    ] [
        search pattern>> line find-substring-in-line
    ] if ;

: search-forward-word ( startpos )      // position -> position/nil
    current-pattern :> pattern
    pattern string-length :> pattern-length
    startpos copy-position !> pos
    nil !> result

    [ result nil? pos and ] [
        pos move-next [
            pattern pos search-forward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result ;

: search-backward-word ( startpos )     // startpos -> pos/?
    current-pattern :> pattern
    pattern string-length :> pattern-length
    startpos copy-position !> pos
    nil !> result

    [ result nil? pos and ] [
        pos move-prev [
            pattern pos search-backward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result ;

public

: find-command
    "find" set-history
    whole-words-only-default "Find word: " "Find: " ? :> prompt
    prompt minibuffer-accept-string :> pattern
    pattern empty? ?exit
    pattern make-search current-search!

    whole-words-only? [
        dot search-forward-word
    ] [
        pattern dot search-forward
    ] if // -> pattern/nil
    [ found ] [ not-found ] if* ;

: find-under
// sublime find_under ctrl-f3
// atom find-next-selected ctrl-f3
// vscode Find Next Selection ctrl-f3
// Find next occurrence of identifier at dot.
    identifier-at-dot                   // -> index/nil string/nil
    :> pattern :> start
    pattern empty? [
        pattern make-search current-search!
        true current-search whole-words-only<< // don't change default!
        dot-line start pattern length + make-position search-forward-word // -> position/nil
        [ found ] [ not-found ] if*
    ] unless ;

: find-under-prev
// sublime find_under_prev ctrl-shift-f3
// atom ctrl-shift-f3 find-previous-selected ctrl-shift-f3
// vscode Find Previous Selection ctrl-f3
// Find previous occurrence of identifier at dot.
    identifier-at-dot                   // -> index/nil string/nil
    :> pattern :> start
    nil !> pos
    pattern empty? [
        pattern make-search current-search!
        true current-search whole-words-only<< // don't change default!
        dot-line start make-position pos!
        pos move-prev [
            pos search-backward-word    // -> position/nil
            [ found ] [ not-found ] if*
        ] when
    ] unless ;

: repeat-search-forward
    current-pattern empty? [ find-command ] ?return

    mark [ dot mark make-region/2 end ] [ copy-dot ] if :> startpos

    whole-words-only? [
        startpos search-forward-word
    ] [
        current-pattern startpos search-forward
    ] if [ found ] [ not-found ] if* ;

: repeat-search-backward
    current-pattern empty? [ find-command ] ?return

    mark [ dot mark make-region/2 begin ] [ copy-dot ] if :> startpos

    whole-words-only? [
        startpos search-backward-word
    ] [
        current-pattern startpos search-backward
    ] if [ found ] [ not-found ] if* ;

: search-list-occurrences
    current-search nil? ?exit

    local buf

    local sourcelinenumber
    local outputline
    local pos
    first-line !> sourceline
    [ sourceline ]
    [
        // while
        current-search sourceline find-in-line  // -> position/nil
        [
            pos!
            buf [ make-buffer buf! ] unless
            sourceline number>> 1+ sourcelinenumber!
            sourcelinenumber sourceline text>> "%d:%s" format make-line/1 outputline!
            sourcelinenumber :source-line-number outputline line-set-property
            pos offset>> :source-offset outputline line-set-property
            buf top-line>> [ outputline buf top-line<< ] unless
            outputline buf buffer-append-line
        ] when*

        sourceline next>> sourceline!

    ] while

    buf nil? [ not-found ] ?return

    buf top-line>> 0 make-position buf dot<<
    true buf read-only<<

    // REVIEW
    current-buffer name>>
    current-search pattern>> " [%S]" format +
    buf name<<

    current-buffer buf parent<<
    current-buffer-directory buf directory<<
    current-search :search buf buffer-set-property
    search-mode:get-instance buf mode<<
    buf dup mode>> initialize-buffer-function>> call

    buf in-buffer-list? [ buf buffer-list vector-push ] unless
    buf set-current-buffer

    renumber
    true repaint?! ;

: toggle-whole-words-only
    whole-words-only-default not whole-words-only-default!
    current-search [ whole-words-only-default swap whole-words-only<< ] when*
    whole-words-only-default "Match whole words only" "Match any occurrence" ?
    current-buffer minibuffer? [ show-message-briefly ] [ message ] if ;

: toggle-ignore-case
    ignore-case-default not ignore-case-default!
    current-search [ ignore-case-default swap ignore-case<< ] when*
    ignore-case-default "Ignore case" "Match case" ? message ;

global replacement

: replace1
    add-undo-line-edit

    // mark is at the beginning of the pattern
    mark-offset dot-line-text string-head

    replacement +

    // dot is at the end of the pattern
    dot-offset dot-line-text string-tail +

    dot-line-text!

    unmark
    modified
    true dot-line-changed?! ;

: query-replace-command
    "find" set-history
    "Find: " minibuffer-accept-string :> pattern
    pattern empty? ?exit

    "replacement" set-history
    pattern "Replace %S with: " format
    minibuffer-accept-string replacement!

    replacement empty? ?exit

    pattern make-search current-search!

    local found?
    local done?
    local response

    0 !> count

    [ done? ]
    [
        whole-words-only? [
            dot search-forward-word
        ] [
            pattern dot search-forward
        ] if

        // -> position/nil
        [
            true found?!
            found
            update-display

            "Replace? " minibuffer-accept-char response!

            response {
                { 'y' [ replace1 count 1+ count! ] }
                { 'n' [ ] }
                { 'q' [ true done?! ] }
                [
                    // default
                    drop
                ]
            } case
        ] [
            found? [
                count 0> [
                    count dup 1 > "s" "" ? "%d occurrence%s replaced" format
                    message
                ] when
            ] [
                not-found
            ] if
            true done?!
        ] if*
        true repaint?!
        update-display
    ] until ;
