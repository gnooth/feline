-- Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors editor history feral-config ;
in: search

empty

private

tuple: search
    pattern
    whole-words-only ;

: make-search                           -- pattern whole-words-only -> search
    search make-instance
    tuck
    whole-words-only<<
    tuck
    pattern<< ;

var current-search

: current-pattern                       -- -> string
    current-search pattern>> ;

: whole-words-only?                     -- -> ?
    current-search whole-words-only>> ;

: mark-found-pattern
    dot-line dot-offset current-pattern string-length + make-position mark! ;

: found ( pos )                         -- position -> void
    reset-redo

    add-undo-move
    pos dot!
    dot-offset goal-column!
    mark-found-pattern
    maybe-reframe
    t repaint?! ;

: not-found
    current-pattern "%S not found" format
    message ;

: find-char-in-range ( char string start end )  -- char string start end -> i/f
    start end [ string string-nth-unsafe char eq? ] find-integer-in-range
;

: find-substring-in-range ( pattern string start end )  -- pattern string start end -> i/f
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start end [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-integer-in-range
;

: find-substring-from ( pattern string start )  -- pattern string start -> i/f
    string string-length pattern string-length - 1+ :> end
    pattern string start end find-substring-in-range
;

: find-substring-in-line ( pattern line )       -- pattern line -> position/f
    pattern line text>> 0 find-substring-from
    [ line swap make-position ] [ f ] if*
;

: search-forward ( pattern startpos )   -- string position -> position/f
    startpos line>> :> line!
    startpos offset>> :> offset

    pattern line text>> offset find-substring-from :> index!

    index [ line index make-position ] return-if

    line next>> line!

    f :> result!

    [ line ] [
        pattern line find-substring-in-line [
            result!
            f line!
        ] [
            line next>> line!
        ] if*
    ] while

    result
;

: find-last-substring-in-range ( pattern string start end )     -- string1 string2 start end -> i/f
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start string string-length pattern-length - 1+ end min [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-last-integer-in-range ;

: find-last-substring-from ( pattern string from )      -- pattern string from -> i/f
    pattern string 0
    string string-length pattern string-length - 1+ from min
    find-last-substring-in-range ;

: find-last-substring-in-line ( pattern line )  -- pattern line -> position/f
    pattern line text>> line length find-last-substring-from
    [ line swap make-position ] [ f ] if*
;

: search-backward ( pattern startpos )  -- pattern startpos -> position/f
    startpos line>> :> line!
    startpos offset>> :> offset

    pattern line text>> offset find-last-substring-from :> index!

    index [ line index make-position ] return-if

    line prev>> line!

    f :> result!

    [ line ] [
        pattern line find-last-substring-in-line [
            result!
            f line!
        ] [
            line prev>> line!
        ] if*
    ] while

    result
;

: delimited? ( pos len )                -- position length -> ?
    pos line>> :> line
    pos offset>> :> offset

    t :> result!

    offset 0 > [
        offset 1- line text>> string-nth blank? [
            f result!
        ] unless
    ] when

    result f eq? [ f ] return-if

    offset len + :> after

    after line length < [
        after line text>> string-nth blank? [
            f result!
        ] unless
    ] when

    result
;

: find-word-in-line ( pattern line )    -- pattern line -> position/f
    0 :> index!
    f :> pos!

    [ index pos null? and ] [
        pattern line text>> index find-substring-from index!
        index [
            line index make-position pos!
            pos pattern string-length delimited? [ f pos! ] unless
            index line length < [ index 1+ ] [ f ] if index!
        ] when
    ] while

    pos ;

: find-in-line                          -- pattern line -> position/?
    whole-words-only? [
        find-word-in-line
    ] [
        find-substring-in-line
    ] if ;

: search-forward-word
    current-pattern :> pattern
    pattern string-length :> pattern-length
    copy-dot :> pos!
    f :> result!

    [ result null? pos and ] [
        pos move-next [
            pattern pos search-forward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result [ found ] [ not-found ] if*
;

: search-backward-word
    current-pattern :> pattern
    pattern string-length :> pattern-length
    copy-dot :> pos!
    f :> result!

    [ result null? pos and ] [
        pos move-prev [
            pattern pos search-backward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result [ found ] [ not-found ] if*
;

public

winui? #if
use: mini
#endif

: do-find
    "Find: " minibuffer-accept-string :> pattern
    pattern empty? [ ] return-if
    pattern f make-search current-search!
    pattern dot search-forward [ found ] [ not-found ] if*
;

: search-forward-word-at-dot
    identifier-at-dot                   // -> start/f string/f
    nip                                 // -> string/f
    :> pattern
    pattern empty? [
        pattern t make-search current-search!
        search-forward-word
    ] unless ;

: search-backward-word-at-dot
    identifier-at-dot                   // -> start/f string/f
    nip                                 // -> string/f
    :> pattern
    pattern empty? [
        pattern t make-search current-search!
        search-backward-word
    ] unless ;

: repeat-search-forward
    current-pattern empty? [ do-find ] return-if

    mark [ dot mark make-region/2 end ] [ copy-dot ] if :> startpos

    whole-words-only? [
        search-forward-word
    ] [
        current-pattern startpos search-forward [ found ] [ not-found ] if*
    ] if
;

: repeat-search-backward
    current-pattern empty? [ do-find ] return-if

    mark [ dot mark make-region/2 begin ] [ copy-dot ] if :> startpos

    whole-words-only? [
        search-backward-word
    ] [
        current-pattern startpos search-backward [ found ] [ not-found ] if*
    ] if
;

: search-list-occurrences
    current-search null? [ ] return-if

    make-buffer :> buf

    current-pattern :> pattern
    first-line :> line!

    "List Occurrences" make-line/1 buf
    2dup buffer-append-line top-line<<

    pattern "Pattern: %S" format make-line/1 buf buffer-append-line

    [ line ] [
        pattern line find-in-line [
            line number>> 1+ line text>> "%d:%s" format
            make-line/1 buf buffer-append-line
        ] when
        line next>> line!
    ] while

    buf top-line>> 0 make-position buf dot<<

    buf buffer-list vector-push
    buf current-buffer!

    renumber
    t repaint?!
;
