// Copyright (C) 2017-2019 Peter Graves <gnooth@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using: feral-core feline accessors editor history feral-config mini ;
in: search

empty

private

tuple: search
    pattern
    whole-words-only ;

: make-search                           // pattern whole-words-only -> search
    search make-instance
    tuck
    whole-words-only<<
    tuck
    pattern<< ;

var current-search

: current-pattern                       // -> string/f
    current-search [ pattern>> ] [ f ] if* ;

: whole-words-only?                     // -> ?
    current-search [ whole-words-only>> ] [ f ] if* ;

: found ( pos )                         // position -> void
    reset-redo

    add-undo-move
    pos mark!
    mark-line mark-offset current-pattern string-length + make-position dot!
    dot-offset goal-column!

    maybe-reframe
    t repaint! ;

: not-found
    current-pattern "%S not found" format
    message ;

: find-char-in-range ( char string start end )  // char string start end -> i/f
    start end [ string string-nth-unsafe char eq? ] find-integer-in-range
;

: find-substring-in-range ( pattern string start end )  // pattern string start end -> i/f
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start end [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-integer-in-range
;

: find-substring-from ( pattern string start )  // pattern string start -> i/f
    string string-length pattern string-length - 1+ :> end
    pattern string start end find-substring-in-range
;

: find-substring-in-line ( pattern line )       // pattern line -> position/f
    pattern line text>> 0 find-substring-from
    [ line swap make-position ] [ f ] if*
;

: search-forward ( pattern startpos )   // string position -> position/f
    startpos line>> :> line!
    startpos offset>> :> offset

    pattern line text>> offset find-substring-from :> index!

    index [ line index make-position ] return-if

    line next>> line!

    f :> result!

    [ line ] [
        pattern line find-substring-in-line [
            result!
            f line!
        ] [
            line next>> line!
        ] if*
    ] while

    result
;

: find-last-substring-in-range ( pattern string start end )     // string1 string2 start end -> i/f
    pattern unsafe-string-data-address :> pattern-data-address
    string unsafe-string-data-address :> string-data-address
    pattern string-length :> pattern-length

    start string string-length pattern-length - 1+ end min [
        string-data-address +
        pattern-data-address
        pattern-length unsafe-memequal
    ] find-last-integer-in-range ;

: find-last-substring-from ( pattern string from )      // pattern string from -> i/f
    pattern string 0
    string string-length pattern string-length - 1+ from min
    find-last-substring-in-range ;

: find-last-substring-in-line ( pattern line )  // pattern line -> position/f
    pattern line text>> line length find-last-substring-from
    [ line swap make-position ] [ f ] if*
;

: search-backward ( pattern startpos )  // pattern startpos -> position/f
    startpos line>> :> line!
    startpos offset>> :> offset

    pattern line text>> offset find-last-substring-from :> index!

    index [ line index make-position ] return-if

    line prev>> line!

    f :> result!

    [ line ] [
        pattern line find-last-substring-in-line [
            result!
            f line!
        ] [
            line prev>> line!
        ] if*
    ] while

    result
;

: delimited? ( pos len )                // position length -> ?
    pos line>> :> line
    pos offset>> :> offset

    t :> result!

    offset 0 > [
        offset 1- line text>> string-nth current-mode identifier-char? [
            f result!
        ] when
    ] when

    result f eq? [ f ] return-if

    offset len + :> after

    after line length < [
        after line text>> string-nth current-mode identifier-char? [
            f result!
        ] when
    ] when

    result
;

: find-word-in-line ( pattern line )    // pattern line -> position/f
    0 :> index!
    f :> pos!

    [ index pos null? and ] [
        pattern line text>> index find-substring-from index!
        index [
            line index make-position pos!
            pos pattern string-length delimited? [ f pos! ] unless
            index line length < [ index 1+ ] [ f ] if index!
        ] when
    ] while

    pos ;

: find-in-line                          // pattern line -> position/?
    whole-words-only? [
        find-word-in-line
    ] [
        find-substring-in-line
    ] if ;

: search-forward-word ( startpos )      // position -> position/?
    current-pattern :> pattern
    pattern string-length :> pattern-length
    startpos copy-position :> pos!
    f :> result!

    [ result null? pos and ] [
        pos move-next [
            pattern pos search-forward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result
;

: search-backward-word ( startpos )     // startpos -> pos/?
    current-pattern :> pattern
    pattern string-length :> pattern-length
    startpos copy-position :> pos!
    f :> result!

    [ result null? pos and ] [
        pos move-prev [
            pattern pos search-backward pos!
            pos [
                pos pattern-length delimited? [
                    pos result!
                ] when
            ] when
        ] when
    ] while

    result
;

public

winui? #if
use: mini
#endif

: find-command
    "find" set-history
    "Find: " minibuffer-accept-string :> pattern
    pattern empty? ?exit
    pattern nil make-search current-search!
    pattern dot search-forward [ found ] [ not-found ] if* ;

: search-forward-word-at-dot
    current-mode identifier-at-dot      // -> index/f string/f
    :> pattern :> start
    f :> pos!
    pattern empty? [
        pattern t make-search current-search!
        dot-line start pattern length + make-position search-forward-word // -> position/f
        [ found ] [ not-found ] if*
    ] unless ;

: search-backward-word-at-dot
    current-mode identifier-at-dot      // -> index/f string/f
    :> pattern :> start
    f :> pos!
    pattern empty? [
        pattern t make-search current-search!
        dot-line start make-position pos!
        pos move-prev [
            pos search-backward-word    // -> position/f
            [ found ] [ not-found ] if*
        ] when
    ] unless ;

: repeat-search-forward
    current-pattern empty? [ find-command ] ?return

    mark [ dot mark make-region/2 end ] [ copy-dot ] if :> startpos

    whole-words-only? [
        startpos search-forward-word
    ] [
        current-pattern startpos search-forward
    ] if [ found ] [ not-found ] if*
;

: repeat-search-backward
    current-pattern empty? [ find-command ] ?return

    mark [ dot mark make-region/2 begin ] [ copy-dot ] if :> startpos

    whole-words-only? [
        startpos search-backward-word
    ] [
        current-pattern startpos search-backward
    ] if [ found ] [ not-found ] if*
;

: search-list-occurrences
    current-search null? [ ] return-if

    make-buffer :> buf

    current-pattern :> pattern
    first-line :> line!

    "List Occurrences" dup buf name<<
    make-line/1 buf 2dup buffer-append-line top-line<<

    pattern "Pattern: %S" format make-line/1 buf buffer-append-line

    [ line ] [
        pattern line find-in-line [
            line number>> 1+ line text>> "%d:%s" format
            make-line/1 buf buffer-append-line
        ] when
        line next>> line!
    ] while

    buf top-line>> 0 make-position buf dot<<

    buf buffer-list vector-push
    buf current-buffer!

    renumber
    t repaint?!
;
